[{"content":"객체들의 상호작용을 나타내는 다이어그램 중 하나로 객체들 사이의 메시지 송신과 그들의 순서를 나타낸다.\n구성요소 객체  가장 윗부분에 표현 왼쪽에서 오른쪽으로 객체들을 나열 객체이름 : 클래스이름 형식으로 표기  생명선  객체 아래에 이어지는 점선 해당 객체가 존재함을 의미  활성 구간  생명선을 따라서 좁고 긴 사각형 객체가 연산을 실행하는 상태 실행 시간을 고려해서 적당히 설정  메시지  형식  [시퀸스 번호][가드]: 반환 값:=메시지 이름([인자 리스트])   화살표로 표시  시작 부분: 송신 객체 끝 부분: 수신 객체   가드(Guard)  메시지가 송신되는 데 만족해야 하는 조건    유형     유형 의미     동기 메시지 메시지 실행이 종료될 때까지 다음 작업을 수행할 수 없음   비동기 메시지 메시지 실행이 끝나기를 기다리지 않고 다음 작업 수행 가능   반환 메시지 메시지가 종료되었음을 의미하며 반드시 표기해야 하는 것은 아님   자체 메시지 자신에게 보내는 메시지    스테레오 타입  \u0026laquo;create\u0026raquo;  객체를 생성하는 메시지   \u0026laquo;destroy\u0026raquo;  객체를 소멸시키는 메시지 생명선 끝에 X를 넣음    프레임  모든 다이어그램에 경계, 타입, 이름을 포함한 레이블의 장소를 제공(UML 2.0) 다이어그램을 에워싸는 박스로 표시 박스 안 왼쪽 모서리에 다이어그램 타입과 이름을 표시  sd: 순차 다이어그램 uc: 유스케이스 다이어그램 act: 액티비티 다이어그램     도서관에서 회원에게 도서를 대여하는 과정을 순차 다이어그램 프레임으로 표시한 것이다. 다만 위 다이어그램에는 대여에 성공한 경우만 나타내고 있다. 만약에 실패한 경우도 나타내고 싶다면 어떻게 해야 할까?\n 이 경우에는 alt 키워드를 사용해서 상호작용을 조건에 따라 선택적으로 수행할 수 있게 하면 된다.\n 회원의 비밀번호를 검증하는 과정을 몇 차례 반복하는 것을 표현하고 싶은 경우 loop 키워드를 사용하면 된다.\n 단순히 다른 순차 다이어그램을 참조할 때는 ref 키워드를 사용한다.\n 참고문헌  정인성, 채흥석,『JAVA 객체지향 디자인 패턴』, 한빛미디어  ","description":"객체들의 상호작용을 나타내는 다이어그램\n","id":0,"section":"posts","tags":["UML","OOP","Java"],"title":"[UML 2.0] 순차 다이어그램(Sequence Diagram)","uri":"https://jeonghun-ban.github.io/posts/uml/sequence-diagram/"},{"content":" UML 2.0에서 디자인 패턴을 표현하는 도구 객체들이 특정 상황에서 수행하는 역할의 상호작용을 작성   UML 1.X에서 사용되던 컬레보레이션 다이어그램은 2.0에서 통신 다이어그램(Communication diagram)으로 변경되었다. 버전에 따라 다이어그램 이름이 상이하니 혼동하지 않도록 주의해야 한다.\n 작성법  점선으로 된 타원 기호 사용 타원 내부에 협력을 필요로 하는 역할들과 그들 사이의 연결 관계를 표현 역할의 클래스를 명시하고자 할 때는 \u0026lt;role_name\u0026gt;:\u0026lt;class_name\u0026gt;으로 표현  컬레보레이션   담보 대출 관계를 보여주는 컬레보레이션  대출자, 대출인, 담보라는 역할이 필요 그들 사이의 협력이 요구되므로 이 역할들을 커넥터로 연결   컬레보레이션은 역할들의 상호작용을 추상화한 것  특별한 상황에 적용하면 많은 시스템 개발에 재사용 가능    컬레보레이션 어커런스  컬레보레이션에 대한 특별한 상황에 대한 적용\n 컬레보레이션 어커런스(Collaboration Occurence)는 구체적인 상황에서의 컬레보레이션 적용을 표현해준다.\n  담보 대출 컬레보레이션을 은행에서 집을 담보로 대출하는 경우에 적용  대출자 = 은행 담보 = 집 대출인 = 사람   이 경우 은행집담보대출은 담보대출의 한 예이며 컬레보레이션 어커런스이다.  참고문헌  정인성, 채흥석,『JAVA 객체지향 디자인 패턴』, 한빛미디어  ","description":"UML2.0에서 디자인 패턴을 표현하는 도구\n","id":1,"section":"posts","tags":["UML","OOP","Java"],"title":"[UML 2.0] 컬레보레이션 다이어그램(Collaboration Diagram)","uri":"https://jeonghun-ban.github.io/posts/uml/collaboration-diagram/"},{"content":"단일 책임 원칙(SRP)  단일 책임 원칙(Single Responsiblity Principle, SRP): 단 하나의 책임만 가져야 한다는 원칙\n 책임의 의미 SRP에서 말하는 책임의 기본 단위는 객체를 지칭한다. 따라서 객체는 하나의 책임만 가져야 한다는 의미이다.\n그렇다면 책임이란 무엇인가? 보통 책임은 해야 하는 것이나 할 수 있는 것으로 간주한다. 그리고 객체에 책임을 할당할 때는 어떤 객체보다도 작업을 잘 할 수 있는 객체에 책임을 할당해야 한다. 또한 객체는 책임에 수반되는 모든 일을 자신만이 수행해야 한다.\n예를 들어 학생 클래스가 수강 과목을 추가하거나 조회하고, DB에 객체 정보를 저장하고 불러오는 작업을 처리하고, 성적표와 출석부에 출력하는 일까지 한다고 가정하자.\n1 2 3 4 5 6 7 8 9 10  public class Student { public void getCourses() { ... } public void addCourse(Course c) { ... } public void save() { ... } public Student load() { ... } public void printOnReportCard() { ... } public void printOnAttendanceBook() { ... } }   이러한 경우 학생 클래스는 너무나 많은 책임을 수행해야만 한다. 단일 책임 원칙(SRP)을 만족하기 위해서는 학생 클래스가 가장 잘할 수 있는 책임(수강 과목 추가/조회)만을 남겨두는 것이다. DB작업이나 성적표/출석부 출력의 경우 다른 클래스가 잘할 수 있는 여지가 많다.\n변경 SRP를 따르는 실효성 있는 설계가 되려면 책임을 좀 더 현실적인 개념으로 파악할 필요가 있다. 우리가 설계 원칙을 학습하는 이유는 예측하지 못한 변경사항에 유연하고 확장성 있는 시스템 구조를 설계하기 위해서이다.\n좋은 설계란 기본적으로 시스템에 새로운 요구사항이나 변경이 있을 때 가능한 한 영향 받는 부분을 줄여야 한다. 가령 어떤 클래스가 잘 설계되었는지를 판단하려면 언제 변경되어야 하는지를 물어보는 것이 좋다.\n그렇다면 학생 클래스는 언제 변경되어야 하나?\n DB 스키마 변경 시? 학생이 지도 교수를 찾는 기능이 추가된다면? 새로운 형식으로 출력하고 싶다면?  이러한 사항은 모두 학생 클래스를 변경해야 하는 이유가 된다. 또한 책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높다.\n책임 분리 학생 클래스는 여러 책임을 수행하므로 이것의 도움을 필요로 하는 코드가 많을 수 밖에 없다. 그렇기 때문에 학생 클래스에 변경사항이 생기면 직접 또는 간접적으로 연관되어 있는 모든 코드들을 다시 테스트해야 한다.\n 참고로 어떤 변화가 있을 때 기존 시스템 기능에 영향을 주는지 평가하는 테스트를 회귀 테스트라고 한다.\n 모든 코드를 테스트하지 않기 위해서는 한 클래스에 너무 많은 책임을 부여하지 말고 단 하나의 책임만 수행하도록 해서 변경 사유가 될 수 있는 것을 하나로 만들어야 한다. 이것을 책임 분리라 한다.\n 학생 클래스의 경우 변경 사유가 될 수 있는 것은 학생의 고유 정보, DB 스키마, 출력 형식의 변화 등 3가지이다. 따라서 학생 클래스는 고유의 역할만 수행하고 DB작업은 DAO(Data Access Object) 클래스, 출석부와 성적표에 출력을 담당하는 클래스로 분리하는 것이 좋다.\n산탄총 수술 지금까지는 한 클래스가 여러 가지 책임을 가진 상황을 살펴봤다. 반대로 하나의 책임이 여러 클래스들로 분산되어 있는 경우도 단일 책임 원칙에 입각해 설계를 변경해야 한다. 이러한 경우를 산탄총 수술(shotgun surgery)라고 한다.\n하나의 책임이 여러 개의 클래스로 분리되어 있는 예는 로깅, 보안, 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능이 대표적이다. 횡단 관심에 속하는 기능은 대부분 시스템 핵심 기능 안에 포함되는 부가 기능이다.\n 가령 시스템에서 실행하는 특정 메시지들의 실행 로그를 DB에 저장하는 코드가 있다고 할 때, 이것을 파일로 저장하게 변경한다면 로그 기능이 삽입된 메서드를 모두 찾아야만 한다.\n이를 해결하는 방법은 이러한 부가 기능을 별개의 클래스로 분리해 책임을 담당하게 하는 것이다. 즉, 여러 곳에 흩어진 공통 책임을 한 곳에 모으면서 응집도를 높인다. 그러나 여전히 구현된 기능들을 호출하고 사용하는 코드는 해당 기능을 사용하는 코드 어딘가에 포함될 수밖에 없다.\n횡단 관심 문제를 해결하기 위한 방법으로 관심지향 프로그래밍(AOP)라는 기법이 있다. AOP는 횡단 관심을 수행하는 코드를 애스펙트(aspect)라는 특별한 객체로 모듈화하고, 위빙(weaving)이라는 작업을 통해 모듈화한 코드를 핵심 기능에 끼워넣는다. 만약 횡단 관심에 변경이 생기면 기존 코드를 전혀 변경하지 않고 해당 애스팩트만 수정한다.\n개방-폐쇄 원칙(OCP)  개방-폐쇄 원칙(Open-Closed Principle, OCP): 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙\n  만약 도서관 대여 명부와 같은 새로운 매체에 학생의 대여 기록을 출력하는 기능을 추가하려면 어떻게 해야할까? 도서관 대여 명부 클래스를 새로 만들어서 Client 클래스가 이 기능을 이용하면 될 것처럼 보인다. 하지만 이러한 방식은 OCP를 위반한다. 새로운 기능을 추가함에 따라서 client를 수정해야만 하기 때문이다.\n 새로운 기능을 추가하더라도 Client 클래스에 영향을 주지 않게 하려면 개별적인 클래스를 직접 접근하는 것이 아닌 인터페이스를 통해 구체적인 기능을 캡슐화하여 처리해야 한다.\n클래스는 변경하지 않고도(closed) 대상 클래스의 환경을 변경(open)할 수 있는 설계가 되어야 한다.\n리스코프 치환 원칙(LSP)  리스코프 치환 원칙(Liskov Substitution Principle, LSP): 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 원칙\n 일반화 관계는 다른 말로 is-a-kind-of 관계라고 한다. 예를 들어 원숭이와 포유류 사이에는 해당 관계가 성립한다(원숭이 is a kind of 포유류). 이때 부모 클래스로 포유류, 자식 클래스로 원숭이를 설정할 수 있다.\n1 2 3  - 포유류는 새끼를 낳아 번식한다. - 포유류는 젖을 먹여서 새끼를 키우고 폐를 통해 호흡한다. - 포유류는 체온이 일정한 정온 동물이다.   위는 포유류의 여러 특징을 설명한 것이다.\n1 2 3  - 원숭이는 새끼를 낳아 번식한다. - 원숭이는 젖을 먹여서 새끼를 키우고 폐를 통해 호흡한다. - 원숭이는 체온이 일정한 정온 동물이다.   리스코프 치환 원칙에 의해 자식 클래스는 부모 클래스에서 가능한 행위는 수행할 수 있다. 따라서 포유류의 특성은 원숭이도 마찬가지로 수행할 수 있다.\n오리너구리는 포유류일까? 1 2 3  - 오리너구리는 새끼를 낳아 번식한다. - 오리너구리는 젖을 먹여서 새끼를 키우고 폐를 통해 호흡한다. - 오리너구리는 체온이 일정한 정온 동물이다.   이와 같은 상황을 오리너구리에 적용해보자. 오리너구리는 포유류임에도 새끼를 낳지 않고 알을 낳는 동물이다. 이러한 경우는 부모 클래스에서 가능한 행위를 수행하지 못한다. 따라서 위 포유류에 대한 설명이 잘못되었다고 결론을 내릴 수 있다.\nLSP를 만족하려면 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대신할 수 있어야 한다.\n 실제로 포유류를 분류하는 데에는 태생을 기준으로 두지 않는다. 참고로 알을 낳는 포유류를 단공류라 한다. 따라서 단공류를 제외한 포유류는 태생이다라는 명제는 참이다.\n 오버라이딩(override) 하지만 이러한 의문을 가질 수도 있을 것이다. 포유류 중에 알을 낳는 경우는 소수이므로 예외적인 경우만 재정의(override)해서 사용하면 안되는 걸까?\n1 2 3  - 오리너구리는 알을 낳아 번식한다. (override) - 오리너구리는 젖을 먹여서 새끼를 키우고 폐를 통해 호흡한다. - 오리너구리는 체온이 일정한 정온 동물이다.   만약 재정의를 사용하게 된다면 오리너구리는 위와 같이 정의할 수 있을 것이며, 실제로 코드는 잘 동작할 수 있다. 다만 아래와 같은 두 가지 OOP 규칙 위배가 발생한다.\n LSP를 만족하지 않음  오리너구리 클래스의 구현은 포유류 클래스의 행위와 일관되지 않음   피터 코드의 상속 규칙 위반  서브 클래스가 슈퍼 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행한다라는 규칙    피터 코드의 상속 규칙에서 말하는 재정의하지 않고 확장만 한다는 말은 결국 오버라이드하지 않는다는 것과 같은 의미이다. 따라서, 피터 코드의 상속 규칙을 따르는 것은 LSP를 만족시키는 방법 중 하나이다. Do Not Override!\n의존 역전 원칙(DIP)  의존 역전 원칙(Dependency Inversion Principle, DIP): 의존 관계를 맺을 때 변화가 어렵거나, 거의 변화가 없는 것에 의존하라는 원칙\n 사람이 음료를 마시는 경우를 가정해보자. 우리는 날마다 물을 먹기도 하지만 커피를 마시거나 콜라를 즐기기도 한다. 구체적으로 무엇을 마시는가는 변하기 쉬운 것이지만 무언가를 마신다는 사실 자체는 변하기 어렵다.\n 객체지향에서는 이와 같이 변화하기 어려운 추상적인 것을 표현하기 위해 추상 클래스나 인터페이스를 사용한다. DIP를 만족하기 위해서는 구체 클래스보다는 인터페이스나 추상 클래스와 의존 관계를 맺도록 설계해야 한다.\n의존성 주입(DI) 의존성 주입(Dependency Injection, DI)란 클래스 외부에서 의존되는 것을 대상 객체의 인스턴스 변수에 주입하는 기술이다. 이것을 이용하면 대상 객체를 변경하지 않고도 외부에서 대상 객체의 외부 의존 객체를 바꿀 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Person { private Beverage beverage public void Person() { this.beverage = new Water(); // this.beverage = new Coffee();  // this.beverage = new Coke();  } public void drink(){ beverage.drink(); } }   우선 의존성 주입을 사용하지 않는 경우부터 살펴보겠다. 마시고 싶은 음료에 따라서 사람은 생성자에서 생성되는 음료를 선택할 수 있다. 하지만 위 같은 설계의 경우 마시는 음료가 변화함에 따라 생성자 코드를 변경해야만 한다.\n1 2 3 4 5 6 7 8 9 10 11  public class Person { private Beverage beverage public void setBeverage(Beverage beverage) { this.beverage = beverage; } public void drink(){ beverage.drink(); } }   의존성 주입을 이용하는 경우 필요한 객체를 클래스 내부에서 직접 생성하는 것이 아니라 외부에서 주입하여 객체 간의 결합도를 줄이고 코드를 유연하게 할 수 있다. 의존성 주입은 외부에서 필요한 객체를 받아서 사용하는 것이다.\n인터페이스 분리 원칙(ISP)  인터페이스 분리 원칙(Interface Segregation Principle, ISP): 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다는 원칙\n  복합기의 경우를 생각해보자. 복합기는 프린트 기능뿐 아니라 다양한 기능을 복합적으로 사용가능한 장치이다. 그렇기 때문에 여러 클라이언트의 작업 요청을 처리할 수 있어야만 한다.\n프린트 기능을 사용중인 클라이언트는 팩스나 복사 기능의 영향을 받아서는 안된다. 하지만 위와 같은 구조는 한 클래스 내에서 모든 기능을 구현하므로 관련 없는 기능에도 영향을 줄 가능성이 높다. 따라서 인터페이스를 통해 클라이언트에 특화되로록 분리시켜야 한다.\n 복합기를 사용하는 객체들마다 자신이 관심을 갖는 메서드들만 있는 인터페이스를 제공받도록 설계했다. 이렇게 설계하면 인터페이스가 일종의 방화벽 역할을 수행해 클라이언트는 자신이 사용하지 않는 메서드에 생긴 변화로 인한 영향을 받지 않게 된다.\nSRP와 ISP 어떤 클래스가 단일 책임을 수행하지 않고 여러 책임을 수행하게 되면 방대한 메서드를 가진 비대한 클래스가 될 것이다. 이러한 클래스를 SRP에 따라 단일 책임을 갖는 여러 클래스들로 분할하고 각자의 인터페이스를 제공한다면 ISP도 만족할 수 있다.\n그렇다면 SRP는 ISP 만족을 위한 필요조건인가? 그렇다고만 할 수는 없다. 가령 게시판의 기능을 제공하기 위한 클래스가 있다고 있다고 하자. 이 클래스가 CRUD 메서드를 구현하고 있다면, 게시판에 관련된 책임을 수행하는 것이므로 SRP를 만족한다고 볼 수 있다.\n그러나 클라이언트에 따라서 게시판의 일부 기능만 사용하도록 제한될 수 있다. 글을 삭제하는 권한이 관리자에게만 있는 경우와 같이 말이다. 이 클래스의 모든 메서드가 들어 있는 인터페이스가 클라이언트와 상관없이 사용된다면 ISP에 위배된다.\n참고문헌  정인성, 채흥석,『JAVA 객체지향 디자인 패턴』, 한빛미디어 위키피디아, 포유류 wlsdud2194, [DI] Dependency Injection이란 무엇일까?, velog  ","description":"객제지향 설계 원칙\n","id":2,"section":"posts","tags":["OOP","JAVA"],"title":"객체지향 설계 원칙: SOLID 원칙","uri":"https://jeonghun-ban.github.io/posts/oop/solid-principle/"},{"content":"추상화(Abstraction) 구체적인 사물들의 공통적인 특징을 파악해서 하나의 개념으로 다루는 수단이다. 즉 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려내는 것이다.\n이러한 추상화는 객체지향 프로그래밍(OOP)에서 클래스를 만들기 위해 필수적인 요소이다. 만약 추상화가 없다면 모든 객체를 세부적으로 정의하여 구현해야만 한다.\n캡슐화(Encapsulation) 캡슐화는 정보은닉을 통해 높은 응집도와 낮은 결합도를 갖도록 하는 객체지향 설계 원리이다.\n응집도와 결합도 클래스의 디자인은 재사용 가능하고, 확장 가능하며 유지 보수가 용이해야 한다. 이를 위해서는 결합도는 낮아야 하며, 응집도은 높아야 한다.\n 응집도(Cohesion)  클래스나 모듈 안의 요소들이 밀접하게 관련되어 있는 정도   결합도(Coupling)  어떤 기능을 실행하는 데 다른 클래스나 모듈들에 의존적인 정도    정보 은닉(information hiding) 알 필요 없는 정보는 외부에서 접근하지 못하도록 제한하는 것이다. 우리는 자동차가 어떻게 동작하는 지 몰라도 운전을 할 수 있으며, 컴퓨터가 동작하는 원리를 몰라도 잘 이용할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class ArrayStack { public int top; public int[] itemArray; public int stackSize; public ArrayStack(int stackSize) { itemArray = new int[stackSize]; top = -1; this.stackSize = stackSize; } public void push(int item) { // item 추가  ... } public int pop() { // item 반환  ... } public int peak() { // item 출력  ... } ... }   ArrayStack은 배열을 사용해서 구현된 스택이다. push 함수를 이용해서 아이템을 추가하고 pop을 통해서 반환할 수 있다.\n1 2 3 4 5 6 7  public class StackClient { public static void main(String[] args){ ArrayStack st = new ArrayStack(10); st.itemArray[++st.top] = 20; System.out.print(st.itemArray[st.top]); } }   하지만 ArrayStack의 속성은 모두 public으로 지정되어 있어, 외부에서도 접근이 가능하다. 이러한 경우 push함수를 이용하지 않고 직접 배열을 다룰 수 있게 되며, StackClient와 ArrayStack 사이에는 강한 결합이 발생한다.\n만약 스택의 구현이 변경되는 경우 StackClient의 소스코드도 변경해야 할 수 있다. 그렇기 때문에 직접 스택의 속성을 다루는 것은 피해야 한다. 따라서 ArrayStack의 속성들은 접근 제어자를 private으로 설정해서 외부 클래스가 접근할 수 없도록 막는다. 이제 더 이상 직접 배열을 조작할 수 없게 되었으므로 StackClient는 아래와 같이 수정되어야 한다.\n1 2 3 4 5 6 7  public class StackClient { public static void main(String[] args){ ArrayStack st = new ArrayStack(10); st.push(20); System.out.print(st.peek()); } }   일반화(Generalization) 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정이다.\n 일반화 관계는 객체지향 프로그래밍 관점에서 상속 관계라고 한다. 따라서 속성이나 기능의 재사용만 강조해서 사용하는 경우가 많다. 이는 일반화 관계를 극히 한정되게 바라보는 시각이다.  캡슐화를 위한 일반화 일반화는 외부 세계에 자식 클래스를 캡슐화(또는 은닉)하는 개념으로 볼 수도 있다.\n 예를 들어 우리는 자동차를 구분할 때 BMW, 현대, 벤츠와 같은 여러 제조사들로 구분한다. 대리 운전 기사가 운전을 하는 상황을 가정해보면 차종은 운전에 큰 영향을 주지 않는다. 사람 클래스 관점에서는 구체적인 자동차가 아닌 자동차 클래스만 관심을 가지면 된다. 따라서 구체적인 자동차 클래스는 은닉되어 있다고 볼 수 있다.\n집합론 관점에서 일반화 일반화 관계는 집합론적인 관점에서 해석할 수도 있다.\n 부모 클래스 A는 전체 집합 A에 해당하고 그 부분 집합 A1, A2, A3는 각각 A의 자식 클래스에 해당한다. 이때 다음 관계가 성립되어야 한다.\n A = A1 ∪ A2 ∪ A3 A1 ∩ A2 ∩ A3 = ø  그리고 아래와 같은 제약 조건도 존재한다.\n  {disjoint}: 자식 클래스 객체가 동시에 두 클래스에 속할 수 없다 {complate}: 자식 클래스의 객체에 해당하는 부모 클래스의 객체와 부모 클래스의 객체에 해당하는 자식 클래스의 객체가 하나만 존재  집합론 관점에서 일반화 관계를 만들면 연관 관계를 단순하게 할 수 있다.\n 만약 인터넷 쇼핑몰에서 VIP 고객과 일반 고객을 분류하고 있다고 한다면 위와 같은 다이어그램을 그릴 수 있을 것이다. 각 회원은 각각 물건과 연관 관계를 맺게 할 수 있지만, 물건을 구매하는 것은 등급과는 무관하다.\n 다시 말해 물건 클래스와의 연관 관계는 물건 클래스의 자식 클래스가 가지는 공통적인 연관 관계이다. 따라서 물건 클래스를 회원 클래스와 연관을 갖게 하여 다이어그램을 간결화할 수 있다,\n 집합론적인 관점에서의 일반화는 상호 배타적인 부분 집합으로 나누는 과정으로 간주할 수 있다.\n 만약 회원을 구분하는 기준이 추가된다면 어떻게 해야 할까? 웹 쇼핑몰에서는 국내 회원만 아니라 외국의 회원에게도 서비스를 제공하는 경우가 있다. 회원의 국가에 따라서 다른 서비스를 제공한다고 할 때, 이러한 구분은 꼭 필요할 것이다.\nUML에서는 이러한 구분을 변별자라 하며 일반화 관계를 표시하는 선 옆에 변별자 정보를 표시한다. 하지만 이러한 경우 회원은 구 가지 기준(결재금액, 지역)에 따라 구분되게 되는데, 이와 같이 한 인스턴스가 동시에 여러 클래스에 속할 수 있는 것을 다중 분류라고 한다. \u0026lt;\u0026lt;다중\u0026gt;\u0026gt; 스테레오 타입을 사용해서 표현한다.\n 일반적으로 각 변별자에 따른 일반화 관계가 완전히 독립적이라면 별다른 문제가 없다. 하지만 요구사항의 변경/추가로 인해 두 일반화 관계가 독립적이지 않은 상황도 고려해야 한다.\n예를 들어 위 다이어그램에서 VIP 회원에게 할인 쿠폰을 제공한다는 것은 쉽게 구현이 가능하지만, 일반 등급인 외국 회원에게 선물을 제공한다는 것은 불가능하다.\n 이를 처리하기 한 가지 방법은 모든 분류 가능한 조합에 대응하는 클래스를 만드는 것이다.\n다형성(Polymorphism) 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력이다.\n앞서 캡슐화를 위한 일반화에서 보았던 자동차 사례를 생각해보자. 우리는 차의 브랜드와는 무관하게 운전하는 것이 가능하다. 그래서 사람 클래스의 관점에서는 자동차 클래스만을 관심을 가지면 된다고 했다. 이것이 가능한 이유는 다형성이 있기 때문이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  abstract class Car { public abstract void ride(); } public class BMW extends Car { public void ride() { ... } } public class HYUNDAI extends Car { public void ride() { ... } } public class BENZ extends Car { public void ride() { ... } } public class Main { public static void rideCars(Car[] cars) { for(Car car: cars){ car.ride(); } } public static void main(String[] args){ Car[] cars = {new BMW(), new HYUNDAI(), new BENZ()}; rideCars(cars); } }   다형성을 사용하는 경우 구체적으로 현재 어떤 클래스 객체가 참조되는지와 무관하게 프로그래밍할 수 있다. 따라서 새로운 자동차 클래스가 자식 클래스로 추가되더라도 코드는 영향을 받지 않는다.\n이것이 가능한 이유는 일반화 관계에 있을 때 부모 클래스의 참조 변수가 자식 클래스의 객체를 참조할 수 있기 때문이다. 단, 부모 클래스의 참조 변수가 접근할 수 있는 것은 부모 클래스가 물려준 변수와 메서드뿐이다.\n피터 코드의 상속 규칙 피터 코드는 상속의 오용을 막기 위해 상속의 사용을 엄격하게 제한하는 규칙들을 만들었다.\n 자식 클래스와 부모 클래스 사이는 역할 수행 관계가 아니어야 한다. 한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 절대 없어야 한다. 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장(extends)만 수행해야 한다. 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다. 자식 클래스가 역할, 트랜잭션, 디바이스 등을 특수화해야 한다.  참고문헌  정인성, 채흥석,『JAVA 객체지향 디자인 패턴』, 한빛미디어  ","description":"객체지향 프로그래밍(OOP)의 네가지 특징\n","id":3,"section":"posts","tags":["OOP","Java"],"title":"객체지향 프로그래밍(OOP) 특징","uri":"https://jeonghun-ban.github.io/posts/oop/oop-features/"},{"content":"클래스란? 클래스는 동일한 속성과 행위를 수행하는 객체들의 집합이다. 예를 들어 소프트웨어를 전공중인 학생들의 공통점은 소프트웨어를 전공한다는 사실과 동일한 전공 수업을 듣는다는 점이다. 이러한 경우 소프트웨어 전공 중인 학생은 실제 학생들의 클래스라고 말할 수 있다.\n클래스를 정의하는 또 다른 관점은 인스턴스(객체)를 생성하는 설계도로 보는 것이다. 아래 소스코드는 소프트웨어를 전공하는 학생 클래스를 정의한 것이다. 클래스가 객체를 생성하는 설계도라는 관점에서 코드를 한 번 살펴보자\n1 2 3 4 5 6 7 8 9 10 11 12  public class Student{ private String name; private String major = \u0026#34;SW\u0026#34;; public Student(String name){ this.name = name; } public void study() { System.out.println(\u0026#34;객체 지향 모델링 수업을 수강합니다.\u0026#34;); } }   1 2 3 4 5  Student student1 = new Student(\u0026#34;학생1\u0026#34;); Student student2 = new Student(\u0026#34;학생2\u0026#34;); student1.study(); student2.study();   위 코드를 통해서 같은 스펙을 가진 학생 객체가 두 개 생겨났다. 두 객체는 이름을 제외하면 모두 동일한 특성을 가진다. major 속성은 SW로 동일하며 study() 메소드를 실행하면 동일한 문장이 출력된다. 이것이 바로 클래스가 객체를 생성하는 설계도인 이유이다.\n 동일한 설계도에서는 항상 동일한 객체가 생성된다.\n UML 모델링  UML을 이용해서 Student 클래스를 표기한 결과는 위와 같다. 가장 위에서부터 구획별로 클래스명(ClassName), 속성(Property), 연산(Operation)을 기술한다. 만약 속성이나 연산이 없다면 생략할 수 있다.\n접근 제어자    접근 제어자 표시 설명     public + 어떤 클래스의 객체든 접근 가능   private - 이 클래스에서 생성한 객체들만 접근 가능   protected # 이 클래스와 동일 패키지에 있거나, 상속 관계에 있는 하위 클래스의 객체들만 접근 가능   package ~ 동일 패키지에 있는 클래스의 객체들만 접근 가능    클래스의 속성과 연산을 정의할 때 -나 +와 같은 기호를 사용하는데, 이것은 가시화를 정의하는 접근 제어자이다. 자바에서의 private과 public를 위와 같이 표기한다고 생각하면 된다.\n속성과 연산    구분 표기법     속성 [접근 제어자]이름: 타입[다중성 정보] [=초기값]   연산 [접근 제어자]이름(인자: 타입): 리턴 타입    속성과 연산을 표기하는 형식은 위와 같다. 클래스 다이어그램은 개념 분석 단계에서 구현에 이르기까지 광범위하게 사용되는데, 분석 단계에서는 속성이나 연산을 구체적으로 표현하기 보다는 정의하는 것이 주를 이룬다. 이후 설계 단계에서 구체적인 타입 정보나 가시화 정보를 기술하게 된다.\n [] 안에 들어있는 것은 생략해도 괜찮다는 의미이다.\n 관계 객체 지향 프로그래밍에서 객체 하나만을 사용하는 경우는 드물다. 보통 기능별로 객체를 나누어 지고 이들의 상호작용이 하나의 소프트웨어를 동작하게 한다. 이러한 클래스 간의 관계를 UML에서는 아래와 같이 표현한다.\n연관 관계 클래스들이 개념상 연결되어 있음을 의미하며 실선으로 표시한다.\n 양방향 연관 관계 교수와 학생 클래스의 연관 관계와 같이 서로를 인식하는 경우를 양방향 연관 관계라고 하며, 화살표 없는 실선으로 표기한다.\n 만약 이들이 상담한다는 것을 나타내고 싶다면 위와 같이 실선 상단에 명시해주면 된다. 연관 관계에서의 역할 이름(rule name)도 정할 수 있는데 실선의 양 끝단에 정의해주면 된다. 이것은 이후 프로그램을 구현하는 단계에서 서로를 참조하는 속성으로 활용될 수 있다.\n단방향 연관 관계 학생 한 명은 여러 수업을 수강할 수 있다. 이것을 UML을 통해서 모델링한다면 다음과 같이 표기할 수 있다.\n 이때 화살표는 학생에서 수업으로 향하는데 이는 학생이 수업을 인식하고 있음을 의미하며, 반대로 수업은 학생을 인식하지 못한다. 이러한 경우를 단방향 연관 관계라고 한다.\n위 다이어그램에는 1..*이라는 표기가 있는데 이것은 다중성을 나타낸 것이다. 다중성은 연관되어 있는 객체의 수를 의미한다.\n *은 0 이상을 의미하며, ..은 범위를 나타낸다. 따라서 1..*는 1 이상이라는 의미이다. 객체가 하나인 경우는 생략하기도 한다.\n 다대다 연관 관계 앞선 예시를 잘 생각해보면 뭔가 이상하다는 사실을 깨닫을 수 있다. 실세계에서는 한 명의 학생만이 수업을 수강하는 경우는 없다. 보통은 다수의 학생이 다수의 수업을 수강한다. 이것을 표현하면 아래와 같은 그림이 나올 것이다.\n 이렇게 다수의 객체 - 다수의 객체가 가지는 관계를 다대다 연관 관계라 하며, 이것은 일반적으로 UML에서 양방향 연관 관계로 표현된다.\n 그런데 만약에 학생이 수업을 수강하면서 발생하는 성적 정보를 저장하고 싶다면 어디에 저장해야 할까? 학생이나 수업 클래스에 그대로 성적 정보를 저장한다면 다음과 같이 표현될 것이다.\n홍길동 학생이 A+이다 또는 객체 지향 모델링 수업에서 A+을 받았다\n다만 여기에는 어떤 수업에서 누가 해당 성적을 얻었는가에 대한 정보가 빠져 있다. 따라서 학생 성적은 학생이나 수업 클래스에 저장하는 것보다는 별도의 클래스를 만들어 저장하는 것이 옳다. 이때 사용되는 Transcript와 같은 클래스를 연관 클래스라 한다.\n 연관 클래스의 실제 구현은 일반 클래스의 단방향 연관 관계로 변환되어 이루어진다.\n 실제로 프로그램을 구현할 때, 양방향 연관 관계는 사용되지 않는다!\n 재귀적 연관 관계  연관 관계는 때로는 재귀적이다. 예를 들면 군대에는 선임과 후임이라는 관계가 존재한다. 내게 선임인 군인도 누구에게는 후임이며, 내게 후임인 군인도 누군가에겐 선임이다.\n 이러한 경우 군인이라는 클래스는 선임과 후임이라는 두 클래스에 동시에 속하는 모순이 발생한다. 하지만 그렇다고 해서 두 클래스를 별도로 만드는 것은 유연성이 부족하다. 이러한 경우 재귀적 연관 관계가 사용된다.\n하지만 재귀적 연관 관계에는 관계의 루프라는 문제가 남아 있다. 예를 들어 가위바위보는 가위가 보를 이기고 보는 바위를 이기고 바위는 가위를 이기는 게임이다. 이렇게 루프가 존재하는 경우는 {계층}으로 제약을 설정하여 배제해야만 한다.\n {계층}은 객체 사이에는 상하 관계가 존재하며, 사이클이 존재하지 않음을 의미한다.\n 일반화 관계 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 간의 관계이다.\n 자식 클래스(서브 클래스)는 부모 클래스(슈퍼 클래스)로부터 속성이나 연산을 물려 받을 수 있다. 그렇기 때문에 일반화 관계를 상속 관계라고도 한다.\n 보통 일반화 관계는 is-a-kind-of 관계라고 말한다. 가전 제품과 세탁기의 관계는 세탁기 is-a-kind-of 가전 제품라고 설명할 수 있다.\n집합 관계 집합 관계는 연관 관계의 특별한 경우로 전체와 부분의 관계를 명확하게 명시하고자 할 때 사용한다. 집약(aggregation)과 합성(composition) 두 종류의 집합 관계가 존재한다.\n집약 관계 한 객체가 다른 객체를 포함하는 것을 나타낸다.\n  전체를 가리키는 클래스 방향에 빈 마름모 표시 부분 객체를 다른 객체와 공유할 수 있음 전체 객체와 부분 객체의 라이프타임은 독립적  합성 관계 부분 객체가 전체 객체에 속하는 관계이다.\n  전체를 가리키는 클래스 방향에 채워진 마름모 표시 부분 객체를 다른 객체와 공유할 수 없음 부분 객체의 라이프타임은 전체 객체에 의존  차이점 집약 관계와 합성 관계는 얼핏보면 비슷해 보이지만 큰 차이를 가지고 있다. 가장 중요한 차이는 라이프타임이다. 전체 객체가 소멸되었을 때 부분 객체가 남아 있다면 그것은 집약 관계이다. 반대의 경우는 합성 관계라고 생각하면 된다.\n컴퓨터를 조립하는 예시를 가지고 이 둘의 차이를 알아 보겠다.\n 1 2 3 4 5 6 7 8 9 10 11 12 13  public class Computer { private MainBoard mainBoard; private CPU cpu; private Memory memory; private PowerSupply powerSupply; public Computer(MainBoard mainBoard, CPU cpu, Memory memory, PowerSupply powerSupply){ this.mainBoard = mainBoard; this.cpu = cpu; this.memory = memory; this.powerSupply = powerSupply; } }   컴퓨터 객체는 외부에서 만들어진 메인보드, CPU, 메모리, 파워서플라이를 받아서 생성된다. 따라서 컴퓨터 객체가 소멸되더라도 컴퓨터를 구성하는 부분 객체들은 사라지지 않고 메모리에 남아 있게 된다. 따라서 위 소스코드는 집약 관계를 나타낸 것이라는 사실을 알 수 있다.\n 1 2 3 4 5 6 7 8 9 10 11 12 13  public class Computer { private MainBoard mainBoard; private CPU cpu; private Memory memory; private PowerSupply powerSupply; public Computer(){ this.mainBoard = new MainBoard(); this.cpu = new CPU(); this.memory = new Memory(); this.powerSupply = new PowerSupply(); } }   이전 예시와 달리 위 코드는 컴퓨터를 생성하는 동시에 구성품들이 생성된다. 따라서 해당 요소들의 생명주기는 전체 객체에 의존하게 된다. 컴퓨터가 소멸되는 동시에 부분 객체들도 사라지기 때문에 합성 관계라고 볼 수 있다.\n의존 관계 다른 클래스에서 제공하는 기능을 사용할 때 나타나는 관계이다.\n 일반적으로 한 클래스가 다른 클래스를 사용하는 경우 다음 3가지이다.\n 클래스의 속성에서 참조 연산의 인자로 사용 메서드 내부의 지역 객체로 참조   사람이 차를 소유하고 있고, 이 차는 주유소에서 충전한다는 것을 다이어그램으로 나타내면 위와 같다. 이때, 사람-차 간의 관계는 연관 관계이지만 차-주유소 간의 관게는 의존 관계이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Person { private Car car; public void setCar(Car car){ this.car = car; } ... } public class Car { public void fillGas(GasPump p){ p.getGas(amount); ... } }   사람이 타고 다니는 차는 매번 변화하는 것이 아니므로 Person클래스의 속성으로 Car객체를 참조한다. 반면 차를 주유하는 주요소는 매번 같지 않으므로 인자나 지역 객체를 통해 구현한다.\n실체화 관계 인터페이스와 이것의 책임들을 실체화한 클래스 간의 관계이다.\n 책임이란 객체가 해야 하는 일 내지 할 수 있는 일을 말한다.\n  인터페이스 자체는 실제로 책임을 수행하는 객체가 아니다. 실체화를 통해서 만들어진 객체가 인터페이스에 정의된 책임을 수행하게 된다.\n 예를 들어 날기 위한 책임을 담은 Flyable이라는 인터페이스를 실체화한 Plane과 Bird 클래스는 해당 인터페이스의 책임을 구현해야만 한다. 이러한 점에서 인터페이스는 어떤 공통되는 능력이 있는 것들을 대표한다는 관점으로 볼 수도 있다. 그렇기 때문에 실체화 관계를 can-do-this 관계라고 부른다.\n참고문헌  정인성, 채흥석,『JAVA 객체지향 디자인 패턴』, 한빛미디어  ","description":"","id":4,"section":"posts","tags":["UML","OOP","Java","Class","Modeling"],"title":"[UML 2.0] 클래스 다이어그램(Class Diagram)","uri":"https://jeonghun-ban.github.io/posts/uml/class-diagram/"},{"content":"개념 요구 분석, 시스템 설계, 시스템 구현 등의 시스템 개발 과정에서 개발자 사이의 의사 소통이 원활하게 이루어지도록 표준화한 통합 모델링 언어(United Modeling Language)\n다이어그램으로 프로그램을 설명하는 UML이 처음이 아니다. 과거에는 객체 지향 모델링을 위해 OMT를 사용하였는데 이것이 UML의 원형이 되었다.\n다이어그램 구조 다이어그램    다이어그램 유형 목적     클래스(Class) 시스템을 구성하는 클래스들 사이의 관계 표현   객체(Object) 객체 정보를 보여줌   복합체 구조(Composite Structure) 복합 구조의 클래스와 컴포넌트 내부 구조 표현   배치(Deployment) S/W, H/W, N/W를 포함한 실행 시스템의 물리 구조 표현   컴포넌트(Component) 컴포넌트 구조 사이의 관계 표현   패키지(Package) 클래스나 유스 케이스 등을 포함한 여러 모델 요소들을 그룹화해 패키지를 구성하고 패키지들 사이의 관계를 표현    행위 다이어그램    다이어그램 유형 목적     활동(Activity) 업무 처리 과정이나 연산이 수행되는 과정 표현   상태 머신(State Machine) 객체의 생명주기 표현   유스 케이스(Use Case) 사용자 관점에서 시스템 행위를 표현   상호작용(Interaction) 목적에 따라 4가지로 분류됨    상호작용 다이어그램    다이어그램 유형 목적     순차(Sequence) 시간 흐름에 따른 객체 사이의 상호작용 표현   상호작용 개요(Interaction overview) 여러 상호작용 다이어그램 사이의 제어 흐름을 표현   통신(Communication) 객체 사이의 관계를 중심으로 상호작용 표현   타이밍(Timing) 객체 상태 변화와 시간 제약을 명시적으로 표현    UML 2.0에서는 시스템 구조와 동작을 표현하는 13개 다이어그램을 제공한다. 이렇게 많은 종류가 존재하는 이유는 다양한 관점으로 시스템을 모델링하기 위함이다.\n특징  가시화 언어  모델링 결과를 가시적으로 나타냄   명세화 언어  정확하고 완전하게 모델링 하는 것   구축 언어  시스템을 구축할 수 있게 함   문서화 언어  시스템에 대한 통제, 평가, 의사소통의 역할    도구  draw.io  무료 웹 기반 UML 드로잉 애플리케이션   starUML  무료 데스크톱 기반 UML 드로잉 애플리케이션    참고문헌  정인성, 채흥석,『JAVA 객체지향 디자인 패턴』, 한빛미디어  ","description":"객체 지향 애플리케이션을 모델링하기 위한 언어, UML\n","id":5,"section":"posts","tags":["UML","OOP","Modeling"],"title":"UML이란?","uri":"https://jeonghun-ban.github.io/posts/uml/what-is-uml/"},{"content":"이번년도는 돌이켜보면 참으로 다사다난한 해였다. 1년동안 활동한 멋쟁이 사자처럼 7기를 무사히 마치고, 8기 운영진을 선발했다. 그리고 운영진 교육을 진행하면서 취업 준비를 동시에 준비하였다. 실제로 산업체 복무에 성공하기도 했지만, 결국에는 퇴사하고 군대에 오기까지 별에 별 일이 다 있었다. 2020년은 내게 여러모로 아쉬움이 남는 해이다. 이번 회고를 통해 부족한 점을 돌아보고 개선하고자 한다.\n멋쟁이 사자처럼 목표는 중요하다. 중학생 때부터 나는 줄곧 컴퓨터를 좋아했고, 네이버 블로그를 통해 IT 관련 지식을 공유하기도 하였다. 그러다보니 자연스래 코딩에 대한 관심을 가지게 되었다. 하지만 그렇다고 코딩에 본격적으로 빠져든 것은 아니었다. 첫째로 처음 접한 C언어가 너무 어려웠고 둘째로 뭔가를 하고 싶다는 목표가 뚜렷하게 없었기 때문이다.\n운영진 활동을 하며 꿈을 찾다. 그런 나에게 있어서 멋쟁이 사자처럼은 내게 있어서 단비같은 존재였다. 멋사는 대학교 1학년 때 사귄 친구의 권유로 알게 되었고, 덕분에 7기 운영진까지 지원하였다. 처음에는 사람들 앞에 나서서 수업을 진행해야 한다는 점 때문에 운영진을 하고 싶지 않았었다. 하지만 지금 돌이켜보면 운영진 활동을 하게 된 것은 내게 큰 도움이 되었다. 운영진이라는 역할을 해내이기 위해서는 수많은 공부를 필요로 했는데, 이것이 나를 끊임없이 발전시키는 원동력이 되었다.\n멋사 7기 운영진으로의 활동은 2020년 초 수료하는 것으로 무사히 마무리를 지었다. 7기 운영을 하면서 해커톤에서 특별한 성적을 얻지는 못했지만, 수업을 진행하는 과정 자체가 내겐 큰 의미였다. 수업 교안을 준비하면서 나는 백엔드 개발자라는 목표를 가지게 되었으며, 코딩이 어렵지 않고 재미있다고 생각하게 되었기 때문이다. 이때부터 나는 본격적으로 프로그래머의 꿈을 꾸기 시작하였다.\n아쉬운 점 나는 경험 상 프로그래밍은 이론이나 개념도 중요하지만 직접 만들어보면서 느끼고 배우는 것이 컸다. 그래서 수업 진행을 PPT위주가 아닌 실습 위주로 진행하였고, 필요한 개념은 Notion에 정리한 내용과 판서를 통해서 설명하였다. 당시 이러한 방식이 학습하는 데 효율적이다라고 생각하고 진행했는데, 수업을 잘 이해하지 못하는 사람들도 있었을 것이다. 수업을 준비하면서 학업까지 동시에 진행하다보니 수업 진행에 있어서 준비가 부족한 점이 많았다고 생각하고 이 부분에 대해서는 여전히 동아리원들에게 미안하다.\n군대 대신 취업을 결심하다. 계기 나는 군대를 가기 싫었다. 이제 막 백엔드 개발자라는 꿈을 설계하기 시작했는데, 이것을 잠시 내려두고 어디론가 가야 한다는 것 자체가 내겐 어려운 일이었다. 계속해서 나는 앞으로 나아가고 싶었고, 그것을 위한 방법이 바로 산업체에 취직하는 것이었다. 산업체에 들어가면 경력 단절이 없음은 물론 3년의 복무 기간동안 군복무와는 비교도 안되는 월급을 받을 수 있다는 장점도 있었다. 무조건 회사에 들어가야 한다는 생각으로 3학년 1학기를 휴학하였다. 멋쟁이 사자처럼 8기 운영진 교육을 진행하면서 동시에 취업 준비를 하고 있었다.\n취준생이 되다. 몇 개월에 걸친 취업 준비 끝에 성공할 수 있었다. 취업에 필요한 정보들은 보통 Awesome Alternative Military Service와 미필자 정보공유 카페에서 얻을 수 있었고, 입사 지원은 대개 로켓펀치와 산업지원 병역일터에서 이루어졌다. 이곳들에 올라오는 공고를 보고 여러 회사에 지원한 결과 한 회사에서 연락이 돌아왔고, 취업의 기회를 얻을 수 있었다.\n취업에 성공하다. 일주일 동안 해야하는 과제는 플라스크를 기반으로 하는 API 서버를 구축하고, postgresql와 sqlalchemy, redis를 이용해서 데이터와 사용자 세션을 관리하는 간단한 서비스를 만들어보는 것이었다. 해당 기간동안 나는 과제를 하는 데에만 집중한 채 다른 것은 미루어 두었다. 요구사항에 기재된 기술 스택들이 내게는 생소한 것들이었기 때문이다. Docker 컨테이너 상에 웹서버, WAS서버, DB서버마저 올려야 하는 상황에서 나는 모르는 것이 너무나 많았다.\n당장 구축해야하는 도커를 사용하지 못하는 상황에 나머지 기술들도 사용해본 적도 없었다. 그래서 일주일을 오로지 투자하여 잠 자는 시간을 빼고는 개발에 전념했다. 그 결과 모든 요구사항을 만족하는 API서버를 구축할 수 있었다. 짧은 입사 테스트 기간동안 배운 것들이 너무나 값지다 생각했기에 떨어지더라도 후회가 없었다. 게다가 이후 면접에서 많은 질문에 대답을 잘 못했기 때문에 분명 떨어질거라 생각하고 반쯤 포기하고 있었다. 내 예상과는 달리 나는 입사 테스트에 합격해 있었다.\n 합격 이메일이 스팸함이 있었다는 사실을 몰라 하마터면 자동으로 탈락될 뻔 했다.\n 회사 생활에서 얻은 것들 회사는 강남에 위치한 공유 오피스에 있었다. 학교가 아닌 회사로 출퇴근하는 풍경은 새로웠고 설레는 일이었다. 회사에서는 맥북 15인치과 델 모니터 하나를 제공해주는 점도 마음에 들었다. 회사에 들어가자마자 일을 하지는 않았고 약 10일 동안 부여된 적응기간이 내게 주어졌다. 이 기간 동안 깃랩에 있는 서버 소스코드를 개발 서버에서 구동해보는 과제를 수행하며 서비스에 대한 이해를 높여 갔다.\n이후에는 테스트코드를 작성하는 작업을 하였고, 이슈에 등록되어 있는 버그를 조치하였다. 가장 기억에 남는 작업은 회사에서 마지막으로 한 작업인 슬랙봇 기능개선이다. 서비스 기능 중에 채팅이 있었는데 해당 기능은 사용자들이 서비스를 이용하다가 궁금한 점을 물어보기 위한 것이다. 사용자는 채팅을 시작(open)한 이후 더 이상 질문을 이어나갈 필요가 없어지는 경우 채팅을 닫고(close) 그만두게 되는데, 이러한 방식은 깃헙에 이슈를 생성하고 그 아래에서 댓글을 이어나가는 것과 유사하다.\n회사에서는 이러한 사용자들의 채팅(문의사항)들을 효과적으로 관리하기 위해서 슬랙봇으로 슬랙 채팅방에 동일한 메시지를 전송하게 하였다. 하지만 해당 기능은 사용자가 보내는 메시지를 하나씩 슬랙에 출력하는 바람에 내용을 한 눈에 파악하기 힘들었다. 다시 말해 하나의 문의에 해당하는 채팅이 여러 개로 분리된 모습은 그리 가독성이 좋지는 않았다.\n그래서 동일한 문의에 대한 메시지들은 하나로 합쳐서 보여주는 기능을 만들자는 깃허브 이슈가 올라와 있었고, 나는 이것을 해결하는 역할을 맡았다. Slack API를 찾아보니 메시지를 merge하는 기능은 없었다. 대신에 chat.update와 search.messages를 이용해서 새로운 메시지가 이미 존재하는 문의에 해당하는 것이라면 합쳐서 보여주고, 그렇지 않다면 새로운 메시지를 만들 수 있도록 하는 방법으로 해결하였다.\n결국 퇴사하다. 회사를 다닌지 한달이 될 무렵, 사수분이 나와 직장 동료를 조용히 불렀다. 우리들처럼 회사에는 산업요원으로 복무를 희망하는 사람들이 많고, 그들 중 한두명을 선발하는데 그것이 우리가 아니라는 이야기였다. 회사를 더 다니고 싶다면 다녀도 좋지만 그렇지 않다면 회사를 나가도 좋다고 하였다.\n내가 회사에 입사하게 된 목적은 돈을 벌기 위한 것도 있었겠지만, 군복무를 대체하기 위한 목적이 가장 컸기에 이러한 제안은 내게 결과적으로 회사를 나가달라는 말과 다름없었다. 나는 결국 짤린.. 아니 퇴사를 결심하게 된 것이었다.\n그때 당시 내가 회사를 나와야 했던 이유는 다음과 같다.\n 부족한 기여도 시간 약속 지키기 열정(?)  기억이 정확하게 다 나지는 않지만 사수가 말하길 스타트업에서는 신입이더라도 충분히 성장하기를 기다려줄 여유는 없고 바로 성과를 낼 수 있는 인재를 원한다고 했다. 나는 어떠한 업무를 실행할 때 기간을 설정하고 지키는 과정이 잘 이루어지지 않는다는 부분으로 자주 지적받았다. 또한 성과를 못내면 늦게까지 회사에 남아서 일하는 열정이라도 보여주어야 했다는 말도 들었다.\n이러한 사수분의 말들은 결국 내게 따끔한 일침으로 돌아왔고, 진심으로 내가 부족한 부분을 돌아 볼 수 있는 계기가 되었다. 다음에 회사에 입사할 때는 늦은 시간까지 남아서 일하지 않아도 회사에서 한 몫을 다할 수 있는 능력있는 사람이 되어야겠다고 다짐한다.\n 당시 회사에서 나오면서 인생의 쓴 맛을 맛보았지만, 아이러니하게도 그 당일에 입금된 첫 월급은 무척 달았다.\n 이번년도의 끝은 군복무 다시 회사에 지원했으나 결국에 회사를 그만두고 할 수 있는 것은 다음 회사를 찾거나 군대를 가는 것이었다. 이후에도 몇 차례 회사에 지원했지만 가고 싶은 회사에 붙지는 못했다. 한 회사에서는 내가 맘에 들었는지 다음년도(2021년)에 나오는 TO를 줄테니 회사에 다니면서 기다려보라고 이야기했다. 심지어는 취준을 병행해도 된다는 파격 조건을 내걸었으나 내가 싫다고 하고 기회를 걷어찼다. (지금 생각해보면 왜그랬는지 모르겠다..) 그리고 다른 회사는 면접을 가면 붙을 거 같기는 했는데 내 커리어에 도움될 것 같지는 않은 회사라서 가지 않겠다고 정중히 거절했다.\n정보보호병 지원 나는 앞서 말했다싶이 군대를 가기 싫어하던 이유가 경력단절에 있다. 이제 꿈을 찾아서 앞으로 나가가려는 나에게 있어서 군대는 장애물에 불과했다. 부모님이 아무리 남자는 군대를 가야한다는 말을 해도 들리지 않았다. 하지만 확실하게 산업체에서 일할 수 있는게 아닌 만큼 끝없이 휴학하고 집에만 있을 수는 없는 일이었다. 그래서 결국에는 군대를 선택하게 되었고, 정보보호병이라는 그래도 전공과 연관이 있는 보직에 지원하게 되었다. 게다가 사단보다는 군단 이상 급으로 자대가 나온다는 이야기를 듣고 많은 기대를 가지고 있었다.\n자대배치, 절망 정보보호병 중에서도 다섯 손가락에 드는 성적이었음에도 불구하고, 나는 28사단에 배정받게 되었다. 후반기 때 친구들이 다 지작사나 군단을 간 것을 생각하면 아직도 배가 아프다. 후반기 마지막 주차 때는 거의 정신 나간 채로 살았던 거 같다. 왜 내가 무엇때문에 사단으로 배정이 난 것일까 계속 생각했다. 그 결과 결국 깨달았다. 도박은 하지 말자. 그게 내가 내린 결론이다. 내 인생은 내가 개척하는 것이지 군대처럼 내가 어디갈지 모르는 것에 몸을 맡기니 이렇게 되는 것이라고, 후회해도 어쩔 수 없다. 군대에 지원한 결정 자체는 내가 내린 것이기에\u0026hellip;\n앞으로의 목표 군대에 온 이상 일정 시간이 지나가기 이전에는 절대로 나갈 수 없다. 그것이 군대의 룰이다. 그렇다면 그 시간 안에 얼마나 많은 것을 해낼 수 있느냐가 중요한 관건이다. 계획을 세우고 이것을 실행하는 것으로 후회없는 군생활을 보내고 싶다. 아래는 그것을 위한 개략적인 목표이다.\n 꾸준한 블로그 활동 코딩 테스트 준비  백준 문제 등 활용   소프트웨어 아키텍처 공부하기  GoF 디자인 패턴 Java 객체지향 디자인 패턴 클린 아키텍처   애자일 공부하기  리팩토링 클린 코드   부족한 자바 공부  이펙티브 자바   이외에 60권 독서 100일 동안 다이어트 및 운동  군대라는 공간 특성상 코딩을 제대로 하기란 쉽지 않고, 나는 전역 이후의 내가 지금보다 더 나은 개발자가 되어있기를 원한다. 그렇기에 개발자로서 갖추어야 할 지식들을 군대 내에서 최대한 많이 공부하기로 결정했다. 그리고 여기에는 사람은 끊임없이 공부하는 삶을 영위해야 행복함을 느낀다라고 생각하는 나의 가치관이 드러난다.\n나는 군대에 온 것을 진심으로 후회했다. 특히 자대배치 이후에 말이다. 하지만 또 생각해보면 언제 또 이렇게 많은 공부를 할 수 있는 기회가 있을까? 학교나 회사를 다니는 동안에는 바쁘다는 핑계로 하지 못했을 공부를 지금하는 거라 생각하면 좋은 기회이다. 나는 절대로 1년 남은 시간을 가벼이 버릴 생각은 눈꼽만큼도 없다. 내가 결정한 선택의 책임에 있어서 후회는 남기고 싶지 않다.\n","description":"2020년을 되돌아보며, 그리고 그 이후\n","id":6,"section":"posts","tags":["회고","멋쟁이 사자처럼","취업","군대","목표"],"title":"2020년 백엔드 개발자 회고","uri":"https://jeonghun-ban.github.io/posts/retrospective/2020-backend-developer-retrospective/"},{"content":" 이 블로그는 제가 배운 내용을 정리하여 공유하기 위해 만들어진 공간입니다.\n단순히 공부한 것을 정리하는 것을 넘어 개인적인 견해도 담는 것을 목표로 하고 있습니다.\n 저는 작년부터 TIL을 통해서 공부한 내용을 정리하고 있었습니다.\n하지만, 이 레파지토리는 개인적인 생각을 드러내기 위한 목적이 아닌 객관적인 사실을 정리하기 위한 것이었습니다.\n이는 결국 단지 제가 공부한 것을 까먹지 않기 위한 수단밖에 되지 않는다는 생각이 들었습니다.\n하지만 저는 배운 것을 정리하는 것도 물론 중요하지만,\n다른 사람과 공유하는 것이 더 큰 의미를 지닌다고 믿습니다.\n객관적인 사실 전달뿐 아니라 제 개인적인 생각을 담은 포스팅을 쓰고 싶었습니다.\n이것이 바로 제가 블로그를 만들게 된 계기입니다.\n정보를 나누는 것이 목적인 블로그인 만큼,\n다른 의견이 있거나 잘못된 부분이 있다면 아낌없이 말씀해주시기 바랍니다.\n언제든지 댓글을 통해서 이슈를 남겨주시면 확인해서 반영하도록 하겠습니다!\n","description":"","id":7,"section":"","tags":null,"title":"About","uri":"https://jeonghun-ban.github.io/about/"},{"content":"서론 나는 백엔드 개발자라는 꿈을 가지고 열심히 달려왔다고 생각한다. 그 결과 엘리스라는 산업체에서 짧게나마 복무를 해보기도 했었다. 하지만 지금 생각해보면 백엔드만을 공부하다보니 전반적인 웹에 대한 지식이나 프론트엔드의 트랜드를 많이 놓치고 있지 않았나 하는 생각이 들었다. 군대에 와서는 블로그도 만들어보는 과정에서 프론트엔드 단의 개발에 관심이 생겼다. 그렇다고 지금 프론트 개발자로 전향하겠다 선언하는 것은 아니다. 단지 백엔드 개발자라는 이유로 프론트를 외면해서는 안되겠다는 생각을 하게 된 것이다. 그래서 이번 글을 통해서 최근 웹 프론트엔드에서 트랜드인 용어들(SSR, CSR, SPA, MPA)를 공부해보기로 했다.\nStatic Page 정적 페이지란 웹 서버 상에 저장된 파일(HTML, JS)이 사용자에게 그대로 전달되는 웹 페이지를 말한다. 데이터가 직접 변경되지 않는 한 페이지는 동일하게 보여지며 빠른 렌더링 속도를 가진다. 개인 블로그와 같이 정해진 내용을 렌더링하는 사이트를 만드는 경우에는 정적 페이지가 많이 사용된다. 보통은 정적 사이트를 처음부터 만드지 않고 Static Site Generator를 이용하는데 대표적인 툴로는 jekyll, hexo, gatsby, hugo 등이 있다.\nDynamic Page 말 그대로 동적인 웹페이지를 말한다. 정적 페이지와 달리 애플리케이션에서 전달하는 데이터에 따라 동일한 페이지여도 다른 정보를 표현할 수 있다. 예를 들어 페이스북에 접속했을 때 사용자별로 보이는 정보는 각자 다르다. 하지만 분명히 동일한 페이지(www.facebook.com)에 접속하고 있다는 사실은 모두가 잘 알고 있을 것이다. 현대의 대다수의 웹페이지는 이러한 방식을 통해 만들어지고 있다.\nCSR(Clent-Side Rendering)  클라이언트 단에서 렌더링을 하는 방식을 말한다. 브라우저 상에서 HTML, JS 등 렌더링을 위해 필요한 것들을 모두 다운로드하고 렌더링한다. 이후에 필요한 데이터만 서버에 요청해서 JS로 동적으로 처리한다.\nSSR(Server-Side Rendering)  전통적인 웹 애플리케이션의 동작방식이다. 서버 상에서 렌더링을 마치고 클라이언트는 이것을 받아서 실행한다. CSR과 달리 페이지를 처음 접속할 때만이 아니라 다른 페이지로 이동할 때마다 새로고침이 일어난다.\nSPA(Single Page Application) 한 개의 페이지로 이루어진 애플리케이션이다. 이 방식으로 만들어진 사이트는 접속하는 처음에만 페이지를 로딩하고 이후는 필요한 데이터만 서버에 요청해서 업데이트한다. 그래서 페이지를 새로고침하지 않는다는 특징을 가진다. 최근 프론트엔드 개발에서 엄청난 인기를 받고 있는 라이브러리인 리액트가 대표적인 예시인데, 페이스북은 이것을 통해 만들어진 대표적인 사이트이다. 실제로 페이스북을 웹에서 사용해보면 접속하는 처음만 페이지 로딩이 일어나고 이후에는 새로고침 과정이 전혀 일어나지 않는다.\nMPA(Single Page Application) 여러 페이지로 이루어진 애플리케이션을 말하며 SPA와 상반되는 개념이다. 서버로부터 완전한 페이지를 받아오며 다른 데이터를 보기 위해서는 브라우저의 새로고침이 필요하다.\nSPA != CSR 위 내용을 읽어보면 SPA와 CSR이 유사한 개념이라는 사실을 알 수 있을 것이다. 그렇다고 같은 개념이라고 오해해서는 안된다. SPA(Single Page Application)을 구현하기 위해서 CSR(Client-Side Rendering) 방식이 사용되는 것이지 등식이 성립하는 관계는 아니다. 굳이 따지자면 SPA를 이루는 요소 중 하나가 CSR(SPA⊃CSR)이라고는 할 수 있겠다.\n MPA/SSR의 관계도 SPA/CSR의 것과 동일하다. MPA를 구현하기 위해 SSR이 사용된다.\n SPA vs MPA    구분 SPA MPA     장점 컴포넌트 재사용유연한 UI SEO에 유리   단점 초기 페이지 로딩 시간SEO에 불리 다른 페이지 이동 시 새로고침    검색 엔진 최적화 문제 SEO(Search Engine Optimization)는 검색엔진 상에서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다. 보통 검색엔진은 웹 사이트들을 크롤링한 결과를 보여주는데 구글을 제외한 대다수의 검색엔진 크롤러는 JS를 해석하지 못한다. MPA는 서버에서 이미 렌더링된 페이지를 그대로 보여주므로 SEO 문제가 발생하지 않는 반면, 빈 페이지를 로딩한 이후 데이터를 JS를 통해 렌더링하는 SPA는 검색엔진이 적절히 크롤링하지 못한다.\n결론 오늘날 우리가 사용하는 웹 페이지는 다양한 구조를 가지고 있다. 전통적인 방식으로는 웹서버 상에 위치한 자원을 그대로 보여주기만 하는 정적 페이지 그리고 서버에서 렌더링한 페이지를 JSP/Servlet 등을 통해 제공하는 방식이 있었다. 하지만 최근엔 다양한 요구사항에 따라 앱처럼 동작하는 웹 애플리케이션의 필요로 인해 SPA가 탄생했다. 이러한 패러다임의 변화로 렌더링이 이루어지는 위치에 따라 SSR과 CSR로 구분짓기 시작했다.\n 사실 따지고 보면 CSR이라는 개념은 전혀 새로운 것은 아니다. 전통적인 MPA이더라도 일부 페이지 내용을 Ajax를 통한 비동기 통신으로 변경하는 경우가 있었기 때문\n 최근에는 SEO 문제를 해결하기 위해서 SPA에 SSR을 도입하는 경우가 있다. 대표적인 예로는 리액트 기반의 프레임워크인 next.js이다. 이것을 이용하면 CSR은 물론이고 SSR까지 지원할 수 있게 된다. 이렇게 사용하는 방식을 hybrid라고 부른다. SPA를 유지하면서 검색엔진 최적화를 하고 싶다면 react-helmet이나 react-snap 등을 이용하면 된다.\n결과적으로 말하고 싶은 것은 웹 애플리케이션을 구현하는 방식은 다양하다. 어느 게 정답이라 할 수 없고 여러 방식을 혼합해서 사용해도 좋다. 결국에는 주어진 과제에 맞게 풀어나가는 것이 중요하다고 생각한다. 검색 엔진 최적화가 우선시 되어야 하는 경우 SSR를 도입해야 할 것이며, 웹 상에서 유연한 UI와 새로고침 없는 앱과 같은 사용자 경험을 제공하고 싶다면 CSR기반의 SPA를 도입해야 할 것이다.\n","description":"최근 웹 프론트엔드에서 트랜드인 용어를 정리해보았다.\n","id":9,"section":"posts","tags":["Architecture","SSR","CSR","SPA","MPA"],"title":"웹 애플리케이션 구조(SSR, CSR, SPA, MPA)","uri":"https://jeonghun-ban.github.io/posts/web/web-application-structure/"},{"content":"다층구조 아키텍쳐는 일반적으로 클라이언트-서버 애플리케이션에서 사용된다. 웹 애플리케이션을 비롯한 대다수 애플리케이션에서 활용되는 기본적인 구조인 만큼 익혀두어야 하는 개념이라 생각한다.\nlayer n-tier architecture를 구성하는 계층(layer)은 아래 3가지이다.\n 프레젠테이션: 유저 인터페이스(UI) 애플리케이션(또는 로직): 비즈니스 로직을 처리함 데이터: 데이터베이스를 의미  여기서 주의해야 할 점이 층(tier)와 계층(layer)은 구분되는 개념이다. 층은 물리적으로 분리된 것을 의미하며 계층은 논리적으로 분리되는 개념이다.\n2-tier vs 3-tier  2-tier  자바 등을 통해서 구현된 클라이언트 프로그램 직접 DB에 접속하여 가져온 데이터를 표현한다.  3-tier  웹 애플리케이션이 대표적인 예시 DB에 직접 접속하지 않고 미들웨어에 접속  참고로 2-tier 구조는 꼭 클라이언트 프로그램이 아닌 웹 애플리케이션으로 구현될 수도 있다. 또한 반대로 클라이언트 프로그램도 3-tier로 구현하는 것도 가능하다.\n구현 사례 내가 대학교 2학년 때 전공 프로젝트로 진행한 대학 수강신청 시스템은 다층구조를 설명하기 좋은 사례이다. 2학기에 걸쳐 구현한 이 프로그램은 1-tier 구조에서 시작해서 3-tier로 진화시켰다. 아래는 프로그램 버전별 특성을 간략하게 정리한 것이다.\n v1.0  1-tier Program 로컬에서 실행되는 간단한 클라이언트 프로그램 수강신청 관련 데이터 파일을 담아서 불러오게 함. UI, 비즈니스 로직, 데이터 모두 한 곳에 있음   v2.0  2-tier Program 클라이언트 프로그램은 단순히 프레젠테이션 기능만 갖춤 서버 프로그램을 만들어서 클라이언트 요청 처리 클라이언트는 UI만을 표현, 서버에서 로직 및 데이터 처리   v2.1+  3-tier Program 데이터 파일을 MySQL DB로 마이그레이션 해당 DB는 aws-rds에 deploy 모든 기능이 물리적으로 분리된 구조    지금와서 되집어보니 작년에 프로젝트를 진행할 당시에는 해당 프로젝트가 가진 진가를 몰라봤었다고 생각한다. 교수님이 진행하는 수업에 따라 열심히 만들기는 했지만 그 안에 담긴 내용을 모두 이해하지는 못하고 있었다고나 할까? 1년 동안 진행한 프로젝트에 다층 구조의 진화과정이 있었다는 사실을 왜 진작에는 몰라봤을까..\n마치며 이번 포스팅을 통해서 배움이라는 것이 꼭 새로운 것을 아는 것만이 아니라는 것을 알게되었다. 이전에 진행한 프로젝트를 되집어보는 리뷰 과정도 충분히 의미있는 시간이 될 수 있다. 물론 처음 배울 때 모든 것을 깨달을 수만 있다면 그게 최선이겠지만 아쉽게도 나는 아직 그러지는 못하는 것 같다. 군대에 있는 시간동안 블로그에 글을 쓰며 이전에 배운 개념을 정리하고, 앞으로 새로 배울 내용도 정리하고자 한다.\n","description":"전공 수업 프로젝트에서 찾은 다층구조 아키텍처\n","id":10,"section":"posts","tags":["Architecture","n-tier-architecture"],"title":"N Tier Architecture","uri":"https://jeonghun-ban.github.io/posts/architecture/n-tier-architecture/"},{"content":"서론 최근 웹으로 접속하는 개발환경인 Web IDE가 활발하게 활용되고 있다. 대표적으로 Cloud9, Codeanywhere, 구름IDE 등이 있는데, 깃헙에서도 Codespace라는 이름으로 비슷한 서비스를 준비중에 있다. 나는 VSCode를 웹에서 바로 사용 가능하다는 점이 마음에 들어 미리보기를 신청했으나 아쉽게도 당첨되지 않았다..\n그래서 방법을 찾던 중 code-server이라는 오픈소스를 찾게 되었다. 해당 서비스는 VS Code를 웹 서버에서 동작할 수 있게 하는 프로젝트이다. MIT 라이선스로 제공되는 오픈 소스인 만큼 조건 없이 사용 가능하다는 것도 장점이다. 군대에서 제약없이 코딩하고자 하는 나에게 있어서 최고의 선택지였다.\n개발 환경 구축 서론이 길었던 것 만큼 설치과정이 길거라고 생각한다면 그것은 큰 착각이다. 설치는 매우 간단하다. 다른 블로그 글을 참고해서 설치해보기도 했지만, 여타 방법보다는 github repo에 나와있는 설치법이 더 쉽고 빠르게 할 수 있다.\n설치 및 실행 1 2  curl -fsSL https://code-server.dev/install.sh | sh sudo systemctl enable --now code-server@$USER # 시스템 부팅 시 자동실행 등록   위 코드를 실행하면 code-server를 설치하고 시스템 부팅 시 자동실행이 가능하도록 등록하는 과정까지 마치게 된다. 동시에 code-server는 이미 동작 중에 있겠지만 바로 사용할 수는 없는데, 이는 기본적으로 localhost(127.0.0.1)의 접속만 허용하기 때문이다. 따라서 외부에서 접속 가능하게 하는 설정이 필요하다.\n외부 접속 허용 및 비밀번호 설정 1  vi ~/.config/code-server/config.yaml   기본적으로 code-server의 설정 파일은 위 경로에 위치한 config.yaml 파일이다.\n1 2 3 4  bind-addr:0.0.0.0:8080auth:passwordpassword:#설정할 비밀번호 입력cert:false   bind-addr: 해당 서비스 주소 auth: 패스워드 설정 여부 password: 패스워드 지정 cert: 인증서 설정   bind-addr값을 127.0.0.1에서 0.0.0.0으로 변경하는 것은 외부에서 접속하는 것도 허용함을 의미한다.\n 1  sudo systemctl restart code-server@$USER   모든 설정이 완료되었다면 code-server를 재실행해준다. 이제 브라우저에서 ip-address:8080으로 접속할 수 있게 되었다. 포트 번호를 넣지 않고 주소만으로 접속하고 싶다면 아래도 이어서 따라와주길 바란다.\nNginx 구축 Nginx는 Apache와 같은 웹 서버 소프트웨어이다. 아파치가 이전에 많이 사용되었다면 최근 만들어지는 프로젝트의 다수는 Nginx로 구성하는 추세이다. 가벼우면서도 아차피보다 더 많은 프로세스를 감당할 수 있다는 장점도 있다.\n이 Nginx는 포워드 프록시라는 기능을 제공하는데 이를 활용하면 서버 ip주소만으로 서비스 포트가 8080인 code-server를 접속할 수 있다.\nbind-addr 초기화 1 2  vi ~/.config/code-server/config.yaml # bind-addr: 127.0.0.1:8080 sudo systemctl restart code-server@$USER   해당 과정을 위해서는 code-server의 bind-addr를 localhost로 다시 설정해주어야 한다.\nNginx 설치 1  sudo apt install -y nginx   /etc/nginx/sites-available/code-server 파일에 아래 설정 추가(sudo 권한) 1 2 3 4 5 6 7 8 9 10 11 12 13  server { listen 80; listen [::]:80; server_name mydomain.com; # 도메인이 있다면 변경  location / { proxy_pass http://localhost:8080/; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } }    80번 포트로 listen하고 해당 프록시를 localhost의 8080 포트로 pass하는 설정이다.\n 설정 적용 1 2 3  sudo rm /etc/nginx/sites-enabled/default sudo ln -s ../sites-available/code-server /etc/nginx/sites-enabled/code-server sudo systemctl reload nginx.service   설정이 제대로 적용되었다면 이후부터는 ip주소만으로 브라우저에서 code-server을 이용할 수 있게 된다.\n버전 업데이트 이 포스팅을 쓰는 도중에도 코드 서버는 v3.7.3에서 v3.7.4로 버전 업데이트가 이루어졌다. 몇 가지 버그 픽스와 기능 추가가 있는 작은 업데이트이었지만 code-server는 접속할 때마다 새로운 버전이 나왔음을 알려주었다. 버전을 업데이트하는 방법은 매우 간단하다.\n1  curl -fsSL https://code-server.dev/install.sh | sh   설치할 때 사용한 코드를 동일하게 실행해주면 바로 적용된다. 이렇게 지속적으로 빠르게 업데이트가 되는 것은 이 프로젝트가 오픈 소스이기 때문에 얻을 수 있는 큰 장점이다. 이렇게 좋은 개발환경을 무료로 자유로이 사용할 수 있다는 것에 감사하고 있다.\n추가적인 설정 이렇게 해서 개인 서버에 code-server를 설치해서 웹 브라우저를 통해 접속할 수 있는 환경을 만들어 보았다. 공식 문서에서는 추가적으로 Nginx 등을 활용하여 https 통신으로 암호화하는 것을 권장하는데, 자세한 내용은 여기를 통해 볼 수 있다. 해당 방법은 도메인네임이 있어야만 하므로 해당 비용을 감수하기 싫다면 굳이 진행하지 않아도 무관하다.\n","description":"나만의 웹 IDE 만들기\n","id":11,"section":"posts","tags":["개발 환경","code-server"],"title":"code-server를 이용해서 웹 IDE 구축하기","uri":"https://jeonghun-ban.github.io/posts/development-environment/build-web-ide-using-code-server/"},{"content":"서론 최근 아니 이미 몇 년간 이어져온 트렌드는 Cloud이다. 어디서나 접속 가능한 컴퓨팅 자원 및 서비스를 제공하는 것인데, 이것이 가져오는 편의성은 어마어마하다. 우리는 더 이상 내가 가진 자원에 종속되지 않아도 됨을 의미하고, 어디에 있든 언제든지 간에 클라우드 자원에 접속하여 이전 작업을 이어갈 수 있다.\n실제로 클라우드의 수혜를 보는 것은 서비스를 사용하는 사용자보다도 개발자이다. 사용자 입장에서는 클라우드 서비스니 뭐니 해도 레거시한 서버와 차이를 느끼기 힘든 반면, 개발자 입장에서는 클라우드를 도입해서 서버 관리에 이점이 확실하기 때문이다.\n개발자에게 클라우드가 이로운 점이 이뿐만이 아니다. 개발서버를 구축하는 것은 개발환경에 있어서의 종속성을 벗어날 수 있게 해준다. 로컬에서 작업한 작업물은 다른 PC에서 이어서 작업하기 위해서 준비해야 할 것들이 사라진다. 물론 git으로 프로젝트를 관리한다고 하는 방법으로 해결할 수 있지 않느냐라는 질문이 있을 수 도 있겠다. 하지만 종속적인 환경들을 다른 PC에서 매번 준비한다는 것은 불편하다.\n 특히나 나와 같이 군대에서 코딩하려는 사람에게는 클라우드 환경 만큼이나 유용한 것은 없을 것이다.\n 대표적인 클라우드 제공업체로는 AWS(Amazon Web Service), MS Azure, GCP(Google Cloud Platform)이 있다. AWS는 1년간 매달 750시간 사용 가능한 리눅스 인스턴스를 제공하며, 애저 또한 무료 크레딧을 제공한다. 하지만 오늘 소개할 것은 평생 무료 인스턴스를 제공하는 GCP이다.\nGCP가 신규 회원에게 제공하는 혜택은 아래와 같다.\n1 2  - 평생 무료 이용 가능한 인스턴스 - 3달 동안 이용 가능한 $300 크레딧   인스턴스 생성 인스턴스 생성에 앞서 구글 클라우드 플랫폼(GCP)에 가입하자. 가입하는 과정은 그리 어렵지 않으니 따로 설명하진 않겠다. 회원가입이 되었다면 우선 아무런 이름이든 상관없으니 프로젝트를 생성한다. 이를 위해서 콘솔로 접속해서 진행한다.\n 앞에서의 과정이 모두 끝났다면 인스턴스를 생성해준다. 생성한 프로젝트에서 햄버거 메뉴를 눌러 Compute Engine-VM 인스턴스를 클릭해서 들어가주고, 위 사진에 보이는 플러스 버튼을 눌러 인스턴스 생성을 시작하자.\n 여기서 이름은 원하는 대로 지어주면 되고, 중요한 부분은 리전과 머신 구성 부분이다. 평생 무료 인스턴스를 만들기 위해서는 조건이 있는데, 우선 region을 us-east1-b를 사용해야 하고 머신 유형은 f1-micro를 사용해야 한다.\n 만약 제공되는 $300 크레딧 사용이 목적이라면 다른 리전과 머신 유형으로 구성하는 것을 추천한다. 평생 무료 인스턴스의 성능이 매우 낮기 때문이다.\n  이제 설정할 것은 부팅 디스크와 방화벽 설정뿐이다. 웹 서버로 이용할 서버를 구성하고 싶다면 HTTP, HTTPS를 허용을 해주어야만 한다.\n 부팅 디스크 설정의 변경 버튼을 눌러서 다른 OS를 선택할 수 있는데 나는 우분투를 선호해서 Ububtu 20.04 LTS를 선택했다. 참고로 디스크는 30GB까지가 무료로 제공되는 용량이다.\n이렇게까지 설정해서 만들기를 누르면 인스턴스가 생성되며, GCP에서 지원하는 web SSH 연결을 이용해서 쉽게 접속해서 이용할 수가 있다.\n","description":"나만의 평생 무료 인스턴스 만들기\n","id":12,"section":"posts","tags":["개발 환경","GCP","Cloud"],"title":"GCP 인스턴스 만들기","uri":"https://jeonghun-ban.github.io/posts/development-environment/create-gcp-instance/"},{"content":"대한민국 국적의 신체 건강한 남성이라면 누구나 군대라는 곳을 원치 않더라도 와야만 한다. 사회에서 떨어진 곳에서 자신이 하던 일을 지속하지 못한다는 점은 개개인들에게 경력단절이라는 큰 손해로 이어진다. 특히 개발자라는 직업은 특성상 빠르게 변화하는 트랜드에 민감하게 반응하고 공부해야 하는 만큼, 이로 인한 좌절은 더더욱 클 수밖에 없다.\n군대에 오고 얼마 지나지 않았을 무렵에는 사지방 PC에 직접 개발환경을 설치하고 개발해보려고 했으나 아래와 같은 제약조건에 인해 이 방법은 몇 번 사용하다가 포기했다.\n1 2 3  - 육군 지침에서 `자료 통신 프로토콜(ftp, telnet)`을 금하고 있다. - 이는 오픈소스 개발에 필수적인 `git`도 엄연히 사용해선 안된다는 것을 의미한다. - 사지방 PC는 자동 로그오프 기능과 초기화로 인해 개발환경 유지가 안된다.   위 제약사항을 다시보자. http나 https 프로토콜으로 웹 사이트 접속하는 것에는 전혀 문제가 없다는 것을 알 수 있다. 그렇기 때문에 웹 브라우저를 통해 통신하는 것은 지침에 위반되지 않는다. 나는 여기에 해답이 있다고 생각했고, 군대에서 코딩을 하는 방법을 찾아냈다.\n웹 기반 개발환경을 구축하면 초기화되지 않는 개인 특화된 개발환경을 사용 가능하다!\n구글링을 통해 알아본 바로 군복무를 하는 동안 cloud9이나 구름ide 등을 이용한 개발자 분들이 몇몇 계셨다. 하지만 나는 Google Cloud Platform을 활용하여 개발 환경을 구축하였다. GCP는 기본 인스턴스에 한해서는 평생 무료로 제공하며, 3달 동안 사용 가능한 $300 크레딧을 제공한다. 최소 3개월 동안은 intel의 쿼드코어 CPU, 15GB의 램 메모리로 구성된 인스턴스를 계속 운용할 수 있는 크레딧이다. 웹/앱 개발에 있어서는 충분한 성능을 제공하는 서버를 구축할 수 있다.\n 이전에는 1년 간 사용가능한 $300 크레딧을 제공했으나 사용기간이 단축되었다.\n 앞으로 포스팅을 통해서 서버를 생성해 개발환경을 구축하는 방법을 소개하고자 한다. 준비해야 할 단계는 딱 두 개뿐이다. 서버를 생성하고 개발환경을 구성한다.\n 1편 GCP 인스턴스 만들기 2편 Code-Server로 웹 IDE 구축하기  서버가 꼭 GCP로 구성되어야 하는 것은 아니다. 개인 서버를 이용해도 좋고 다른 서비스를 이용해도 좋으나, 나는 이번에 GCP를 활용해보았고 그 방법을 정리해보게 되었다.\n","description":"군대에서 코딩을 어떻게 할 수 있을까? 그 답을 찾기 위한 여정\n","id":13,"section":"posts","tags":["개발 환경"],"title":"군대에서 코딩하기","uri":"https://jeonghun-ban.github.io/posts/development-environment/coding-in-the-military/"}]