[{"content":" 이 블로그는 제가 배운 내용을 정리하여 공유하기 위해 만들어진 공간입니다.\n단순히 공부한 것을 정리하는 것을 넘어 개인적인 견해도 담는 것을 목표로 하고 있습니다.\n 저는 작년부터 TIL을 통해서 공부한 내용을 정리하고 있었습니다.\n하지만, 이 레파지토리는 개인적인 생각을 드러내기 위한 목적이 아닌 객관적인 사실을 정리하기 위한 것이었습니다.\n이는 결국 단지 제가 공부한 것을 까먹지 않기 위한 수단밖에 되지 않는다는 생각이 들었습니다.\n하지만 저는 배운 것을 정리하는 것도 물론 중요하지만,\n다른 사람과 공유하는 것이 더 큰 의미를 지닌다고 믿습니다.\n객관적인 사실 전달뿐 아니라 제 개인적인 생각을 담은 포스팅을 쓰고 싶었습니다.\n이것이 바로 제가 블로그를 만들게 된 계기입니다.\n정보를 나누는 것이 목적인 블로그인 만큼,\n다른 의견이 있거나 잘못된 부분이 있다면 아낌없이 말씀해주시기 바랍니다.\n언제든지 댓글을 통해서 이슈를 남겨주시면 확인해서 반영하도록 하겠습니다!\n","description":"","id":0,"section":"","tags":null,"title":"About","uri":"https://jeonghun-ban.github.io/about/"},{"content":"서론 나는 백엔드 개발자라는 꿈을 가지고 열심히 달려왔다고 생각한다. 그 결과 엘리스라는 산업체에서 짧게나마 복무를 해보기도 했었다. 하지만 지금 생각해보면 백엔드만을 공부하다보니 전반적인 웹에 대한 지식이나 프론트엔드의 트랜드를 많이 놓치고 있지 않았나 하는 생각이 들었다. 군대에 와서는 블로그도 만들어보는 과정에서 프론트엔드 단의 개발에 관심이 생겼다. 그렇다고 지금 프론트 개발자로 전향하겠다 선언하는 것은 아니다. 단지 백엔드 개발자라는 이유로 프론트를 외면해서는 안되겠다는 생각을 하게 된 것이다. 그래서 이번 글을 통해서 최근 웹 프론트엔드에서 트랜드인 용어들(SSR, CSR, SPA, MPA)를 공부해보기로 했다.\nStatic Page 정적 페이지란 웹 서버 상에 저장된 파일(HTML, JS)이 사용자에게 그대로 전달되는 웹 페이지를 말한다. 데이터가 직접 변경되지 않는 한 페이지는 동일하게 보여지며 빠른 렌더링 속도를 가진다. 개인 블로그와 같이 정해진 내용을 렌더링하는 사이트를 만드는 경우에는 정적 페이지가 많이 사용된다. 보통은 정적 사이트를 처음부터 만드지 않고 Static Site Generator를 이용하는데 대표적인 툴로는 jekyll, hexo, gatsby, hugo 등이 있다.\nDynamic Page 말 그대로 동적인 웹페이지를 말한다. 정적 페이지와 달리 애플리케이션에서 전달하는 데이터에 따라 동일한 페이지여도 다른 정보를 표현할 수 있다. 예를 들어 페이스북에 접속했을 때 사용자별로 보이는 정보는 각자 다르다. 하지만 분명히 동일한 페이지(www.facebook.com)에 접속하고 있다는 사실은 모두가 잘 알고 있을 것이다. 현대의 대다수의 웹페이지는 이러한 방식을 통해 만들어지고 있다.\nCSR(Clent-Side Rendering)  클라이언트 단에서 렌더링을 하는 방식을 말한다. 브라우저 상에서 HTML, JS 등 렌더링을 위해 필요한 것들을 모두 다운로드하고 렌더링한다. 이후에 필요한 데이터만 서버에 요청해서 JS로 동적으로 처리한다.\nSSR(Server-Side Rendering)  전통적인 웹 애플리케이션의 동작방식이다. 서버 상에서 렌더링을 마치고 클라이언트는 이것을 받아서 실행한다. CSR과 달리 페이지를 처음 접속할 때만이 아니라 다른 페이지로 이동할 때마다 새로고침이 일어난다.\nSPA(Single Page Application) 한 개의 페이지로 이루어진 애플리케이션이다. 이 방식으로 만들어진 사이트는 접속하는 처음에만 페이지를 로딩하고 이후는 필요한 데이터만 서버에 요청해서 업데이트한다. 그래서 페이지를 새로고침하지 않는다는 특징을 가진다. 최근 프론트엔드 개발에서 엄청난 인기를 받고 있는 라이브러리인 리액트가 대표적인 예시인데, 페이스북은 이것을 통해 만들어진 대표적인 사이트이다. 실제로 페이스북을 웹에서 사용해보면 접속하는 처음만 페이지 로딩이 일어나고 이후에는 새로고침 과정이 전혀 일어나지 않는다.\nMPA(Single Page Application) 여러 페이지로 이루어진 애플리케이션을 말하며 SPA와 상반되는 개념이다. 서버로부터 완전한 페이지를 받아오며 다른 데이터를 보기 위해서는 브라우저의 새로고침이 필요하다.\nSPA != CSR 위 내용을 읽어보면 SPA와 CSR이 유사한 개념이라는 사실을 알 수 있을 것이다. 그렇다고 같은 개념이라고 오해해서는 안된다. SPA(Single Page Application)을 구현하기 위해서 CSR(Client-Side Rendering) 방식이 사용되는 것이지 등식이 성립하는 관계는 아니다. 굳이 따지자면 SPA를 이루는 요소 중 하나가 CSR(SPA⊃CSR)이라고는 할 수 있겠다.\n MPA/SSR의 관계도 SPA/CSR의 것과 동일하다. MPA를 구현하기 위해 SSR이 사용된다.\n SPA vs MPA    구분 SPA MPA     장점 컴포넌트 재사용유연한 UI SEO에 유리   단점 초기 페이지 로딩 시간SEO에 불리 다른 페이지 이동 시 새로고침    검색 엔진 최적화 문제 SEO(Search Engine Optimization)는 검색엔진 상에서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다. 보통 검색엔진은 웹 사이트들을 크롤링한 결과를 보여주는데 구글을 제외한 대다수의 검색엔진 크롤러는 JS를 해석하지 못한다. MPA는 서버에서 이미 렌더링된 페이지를 그대로 보여주므로 SEO 문제가 발생하지 않는 반면, 빈 페이지를 로딩한 이후 데이터를 JS를 통해 렌더링하는 SPA는 검색엔진이 적절히 크롤링하지 못한다.\n결론 오늘날 우리가 사용하는 웹 페이지는 다양한 구조를 가지고 있다. 전통적인 방식으로는 웹서버 상에 위치한 자원을 그대로 보여주기만 하는 정적 페이지 그리고 서버에서 렌더링한 페이지를 JSP/Servlet 등을 통해 제공하는 방식이 있었다. 하지만 최근엔 다양한 요구사항에 따라 앱처럼 동작하는 웹 애플리케이션의 필요로 인해 SPA가 탄생했다. 이러한 패러다임의 변화로 렌더링이 이루어지는 위치에 따라 SSR과 CSR로 구분짓기 시작했다.\n 사실 따지고 보면 CSR이라는 개념은 전혀 새로운 것은 아니다. 전통적인 MPA이더라도 일부 페이지 내용을 Ajax를 통한 비동기 통신으로 변경하는 경우가 있었기 때문\n 최근에는 SEO 문제를 해결하기 위해서 SPA에 SSR을 도입하는 경우가 있다. 대표적인 예로는 리액트 기반의 프레임워크인 next.js이다. 이것을 이용하면 CSR은 물론이고 SSR까지 지원할 수 있게 된다. 이렇게 사용하는 방식을 hybrid라고 부른다. SPA를 유지하면서 검색엔진 최적화를 하고 싶다면 react-helmet이나 react-snap 등을 이용하면 된다.\n결과적으로 말하고 싶은 것은 웹 애플리케이션을 구현하는 방식은 다양하다. 어느 게 정답이라 할 수 없고 여러 방식을 혼합해서 사용해도 좋다. 결국에는 주어진 과제에 맞게 풀어나가는 것이 중요하다고 생각한다. 검색 엔진 최적화가 우선시 되어야 하는 경우 SSR를 도입해야 할 것이며, 웹 상에서 유연한 UI와 새로고침 없는 앱과 같은 사용자 경험을 제공하고 싶다면 CSR기반의 SPA를 도입해야 할 것이다.\n","description":"최근 웹 프론트엔드에서 트랜드인 용어를 정리해보았다.\n","id":2,"section":"posts","tags":["structure","n-tier-architecture"],"title":"웹 애플리케이션 구조(SSR, CSR, SPA, MPA)","uri":"https://jeonghun-ban.github.io/posts/development/web-application-structure/"},{"content":"다층구조 아키텍쳐는 일반적으로 클라이언트-서버 애플리케이션에서 사용된다. 웹 애플리케이션을 비롯한 대다수 애플리케이션에서 활용되는 기본적인 구조인 만큼 익혀두어야 하는 개념이라 생각한다.\nlayer n-tier architecture를 구성하는 계층(layer)은 아래 3가지이다.\n 프레젠테이션: 유저 인터페이스(UI) 애플리케이션(또는 로직): 비즈니스 로직을 처리함 데이터: 데이터베이스를 의미  여기서 주의해야 할 점이 층(tier)와 계층(layer)은 구분되는 개념이다. 층은 물리적으로 분리된 것을 의미하며 계층은 논리적으로 분리되는 개념이다.\n2-tier vs 3-tier  2-tier  자바 등을 통해서 구현된 클라이언트 프로그램 직접 DB에 접속하여 가져온 데이터를 표현한다.  3-tier  웹 애플리케이션이 대표적인 예시 DB에 직접 접속하지 않고 미들웨어에 접속  참고로 2-tier 구조는 꼭 클라이언트 프로그램이 아닌 웹 애플리케이션으로 구현될 수도 있다. 또한 반대로 클라이언트 프로그램도 3-tier로 구현하는 것도 가능하다.\n구현 사례 내가 대학교 2학년 때 전공 프로젝트로 진행한 대학 수강신청 시스템은 다층구조를 설명하기 좋은 사례이다. 2학기에 걸쳐 구현한 이 프로그램은 1-tier 구조에서 시작해서 3-tier로 진화시켰다. 아래는 프로그램 버전별 특성을 간략하게 정리한 것이다.\n v1.0  1-tier Program 로컬에서 실행되는 간단한 클라이언트 프로그램 수강신청 관련 데이터 파일을 담아서 불러오게 함. UI, 비즈니스 로직, 데이터 모두 한 곳에 있음   v2.0  2-tier Program 클라이언트 프로그램은 단순히 프레젠테이션 기능만 갖춤 서버 프로그램을 만들어서 클라이언트 요청 처리 클라이언트는 UI만을 표현, 서버에서 로직 및 데이터 처리   v2.1+  3-tier Program 데이터 파일을 MySQL DB로 마이그레이션 해당 DB는 aws-rds에 deploy 모든 기능이 물리적으로 분리된 구조    지금와서 되집어보니 작년에 프로젝트를 진행할 당시에는 해당 프로젝트가 가진 진가를 몰라봤었다고 생각한다. 교수님이 진행하는 수업에 따라 열심히 만들기는 했지만 그 안에 담긴 내용을 모두 이해하지는 못하고 있었다고나 할까? 1년 동안 진행한 프로젝트에 다층 구조의 진화과정이 있었다는 사실을 왜 진작에는 몰라봤을까..\n마치며 이번 포스팅을 통해서 배움이라는 것이 꼭 새로운 것을 아는 것만이 아니라는 것을 알게되었다. 이전에 진행한 프로젝트를 되집어보는 리뷰 과정도 충분히 의미있는 시간이 될 수 있다. 물론 처음 배울 때 모든 것을 깨달을 수만 있다면 그게 최선이겠지만 아쉽게도 나는 아직 그러지는 못하는 것 같다. 군대에 있는 시간동안 블로그에 글을 쓰며 이전에 배운 개념을 정리하고, 앞으로 새로 배울 내용도 정리하고자 한다.\n","description":"전공 수업 프로젝트에서 찾은 다층구조 아키텍처\n","id":3,"section":"posts","tags":["n-tier-architecture"],"title":"N Tier Architecture","uri":"https://jeonghun-ban.github.io/posts/development/n-tier-architecture/"},{"content":"서론 최근 웹으로 접속하는 개발환경인 Web IDE가 활발하게 활용되고 있다. 대표적으로 Cloud9, Codeanywhere, 구름IDE 등이 있는데, 깃헙에서도 Codespace라는 이름으로 비슷한 서비스를 준비중에 있다. 나는 VSCode를 웹에서 바로 사용 가능하다는 점이 마음에 들어 미리보기를 신청했으나 아쉽게도 당첨되지 않았다..\n그래서 방법을 찾던 중 code-server이라는 오픈소스를 찾게 되었다. 해당 서비스는 VS Code를 웹 서버에서 동작할 수 있게 하는 프로젝트이다. MIT 라이선스로 제공되는 오픈 소스인 만큼 조건 없이 사용 가능하다는 것도 장점이다. 군대에서 제약없이 코딩하고자 하는 나에게 있어서 최고의 선택지였다.\n개발 환경 구축 서론이 길었던 것 만큼 설치과정이 길거라고 생각한다면 그것은 큰 착각이다. 설치는 매우 간단하다. 다른 블로그 글을 참고해서 설치해보기도 했지만, 여타 방법보다는 github repo에 나와있는 설치법이 더 쉽고 빠르게 할 수 있다.\n설치 및 실행 1 2  curl -fsSL https://code-server.dev/install.sh | sh sudo systemctl enable --now code-server@$USER # 시스템 부팅 시 자동실행 등록   위 코드를 실행하면 code-server를 설치하고 시스템 부팅 시 자동실행이 가능하도록 등록하는 과정까지 마치게 된다. 동시에 code-server는 이미 동작 중에 있겠지만 바로 사용할 수는 없는데, 이는 기본적으로 localhost(127.0.0.1)의 접속만 허용하기 때문이다. 따라서 외부에서 접속 가능하게 하는 설정이 필요하다.\n외부 접속 허용 및 비밀번호 설정 1  vi ~/.config/code-server/config.yaml   기본적으로 code-server의 설정 파일은 위 경로에 위치한 config.yaml 파일이다.\n1 2 3 4  bind-addr:0.0.0.0:8080auth:passwordpassword:#설정할 비밀번호 입력cert:false   bind-addr: 해당 서비스 주소 auth: 패스워드 설정 여부 password: 패스워드 지정 cert: 인증서 설정   bind-addr값을 127.0.0.1에서 0.0.0.0으로 변경하는 것은 외부에서 접속하는 것도 허용함을 의미한다.\n 1  sudo systemctl restart code-server@$USER   모든 설정이 완료되었다면 code-server를 재실행해준다. 이제 브라우저에서 ip-address:8080으로 접속할 수 있게 되었다. 포트 번호를 넣지 않고 주소만으로 접속하고 싶다면 아래도 이어서 따라와주길 바란다.\nNginx 구축 Nginx는 Apache와 같은 웹 서버 소프트웨어이다. 아파치가 이전에 많이 사용되었다면 최근 만들어지는 프로젝트의 다수는 Nginx로 구성하는 추세이다. 가벼우면서도 아차피보다 더 많은 프로세스를 감당할 수 있다는 장점도 있다.\n이 Nginx는 포워드 프록시라는 기능을 제공하는데 이를 활용하면 서버 ip주소만으로 서비스 포트가 8080인 code-server를 접속할 수 있다.\nbind-addr 초기화 1 2  vi ~/.config/code-server/config.yaml # bind-addr: 127.0.0.1:8080 sudo systemctl restart code-server@$USER   해당 과정을 위해서는 code-server의 bind-addr를 localhost로 다시 설정해주어야 한다.\nNginx 설치 1  sudo apt install -y nginx   /etc/nginx/sites-available/code-server 파일에 아래 설정 추가(sudo 권한) 1 2 3 4 5 6 7 8 9 10 11 12 13  server { listen 80; listen [::]:80; server_name mydomain.com; # 도메인이 있다면 변경  location / { proxy_pass http://localhost:8080/; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } }    80번 포트로 listen하고 해당 프록시를 localhost의 8080 포트로 pass하는 설정이다.\n 설정 적용 sudo rm /etc/nginx/sites-enabled/default sudo ln -s ../sites-available/code-server /etc/nginx/sites-enabled/code-server sudo systemctl reload nginx.service 설정이 제대로 적용되었다면 이후부터는 ip주소만으로 브라우저에서 code-server을 이용할 수 있게 된다.\n버전 업데이트 이 포스팅을 쓰는 도중에도 코드 서버는 v3.7.3에서 v3.7.4로 버전 업데이트가 이루어졌다. 몇 가지 버그 픽스와 기능 추가가 있는 작은 업데이트이었지만 code-server는 접속할 때마다 새로운 버전이 나왔음을 알려주었다. 버전을 업데이트하는 방법은 매우 간단하다.\n1  curl -fsSL https://code-server.dev/install.sh | sh   설치할 때 사용한 코드를 동일하게 실행해주면 바로 적용된다. 이렇게 지속적으로 빠르게 업데이트가 되는 것은 이 프로젝트가 오픈 소스이기 때문에 얻을 수 있는 큰 장점이다. 이렇게 좋은 개발환경을 무료로 자유로이 사용할 수 있다는 것에 감사하고 있다.\n추가적인 설정 이렇게 해서 개인 서버에 code-server를 설치해서 웹 브라우저를 통해 접속할 수 있는 환경을 만들어 보았다. 공식 문서에서는 추가적으로 Nginx 등을 활용하여 https 통신으로 암호화하는 것을 권장하는데, 자세한 내용은 여기를 통해 볼 수 있다. 해당 방법은 도메인네임이 있어야만 하므로 해당 비용을 감수하기 싫다면 굳이 진행하지 않아도 무관하다.\n","description":"나만의 웹 IDE 만들기\n","id":4,"section":"posts","tags":["code-server"],"title":"code-server를 이용해서 웹 IDE 구축하기","uri":"https://jeonghun-ban.github.io/posts/development/build-web-ide-using-code-server/"},{"content":"서론 최근 아니 이미 몇 년간 이어져온 트렌드는 Cloud이다. 어디서나 접속 가능한 컴퓨팅 자원 및 서비스를 제공하는 것인데, 이것이 가져오는 편의성은 어마어마하다. 우리는 더 이상 내가 가진 자원에 종속되지 않아도 됨을 의미하고, 어디에 있든 언제든지 간에 클라우드 자원에 접속하여 이전 작업을 이어갈 수 있다.\n실제로 클라우드의 수혜를 보는 것은 서비스를 사용하는 사용자보다도 개발자이다. 사용자 입장에서는 클라우드 서비스니 뭐니 해도 레거시한 서버와 차이를 느끼기 힘든 반면, 개발자 입장에서는 클라우드를 도입해서 서버 관리에 이점이 확실하기 때문이다.\n개발자에게 클라우드가 이로운 점이 이뿐만이 아니다. 개발서버를 구축하는 것은 개발환경에 있어서의 종속성을 벗어날 수 있게 해준다. 로컬에서 작업한 작업물은 다른 PC에서 이어서 작업하기 위해서 준비해야 할 것들이 사라진다. 물론 git으로 프로젝트를 관리한다고 하는 방법으로 해결할 수 있지 않느냐라는 질문이 있을 수 도 있겠다. 하지만 종속적인 환경들을 다른 PC에서 매번 준비한다는 것은 불편하다.\n 특히나 나와 같이 군대에서 코딩하려는 사람에게는 클라우드 환경 만큼이나 유용한 것은 없을 것이다.\n 대표적인 클라우드 제공업체로는 AWS(Amazon Web Service), MS Azure, GCP(Google Cloud Platform)이 있다. AWS는 1년간 매달 750시간 사용 가능한 리눅스 인스턴스를 제공하며, 애저 또한 무료 크레딧을 제공한다. 하지만 오늘 소개할 것은 평생 무료 인스턴스를 제공하는 GCP이다.\nGCP가 신규 회원에게 제공하는 혜택은 아래와 같다.\n1 2  - 평생 무료 이용 가능한 인스턴스 - 3달 동안 이용 가능한 $300 크레딧   인스턴스 생성 인스턴스 생성에 앞서 구글 클라우드 플랫폼(GCP)에 가입하자. 가입하는 과정은 그리 어렵지 않으니 따로 설명하진 않겠다. 회원가입이 되었다면 우선 아무런 이름이든 상관없으니 프로젝트를 생성한다. 이를 위해서 콘솔로 접속해서 진행한다.\n앞에서의 과정이 모두 끝났다면 인스턴스를 생성해준다. 생성한 프로젝트에서 햄버거 메뉴를 눌러 Compute Engine-VM 인스턴스를 클릭해서 들어가주고, 위 사진에 보이는 플러스 버튼을 눌러 인스턴스 생성을 시작하자.\n여기서 이름은 원하는 대로 지어주면 되고, 중요한 부분은 리전과 머신 구성 부분이다. 평생 무료 인스턴스를 만들기 위해서는 조건이 있는데, 우선 region을 us-east1-b를 사용해야 하고 머신 유형은 f1-micro를 사용해야 한다.\n 만약 제공되는 $300 크레딧 사용이 목적이라면 다른 리전과 머신 유형으로 구성하는 것을 추천한다. 평생 무료 인스턴스의 성능이 매우 낮기 때문이다.\n 이제 설정할 것은 부팅 디스크와 방화벽 설정뿐이다. 웹 서버로 이용할 서버를 구성하고 싶다면 HTTP, HTTPS를 허용을 해주어야만 한다.\n부팅 디스크 설정의 변경 버튼을 눌러서 다른 OS를 선택할 수 있는데 나는 우분투를 선호해서 Ububtu 20.04 LTS를 선택했다. 참고로 디스크는 30GB까지가 무료로 제공되는 용량이다.\n이렇게까지 설정해서 만들기를 누르면 인스턴스가 생성되며, GCP에서 지원하는 web SSH 연결을 이용해서 쉽게 접속해서 이용할 수가 있다.\n","description":"나만의 평생 무료 인스턴스 만들기\n","id":5,"section":"posts","tags":["GCP","Cloud"],"title":"GCP 인스턴스 만들기","uri":"https://jeonghun-ban.github.io/posts/development/create-gcp-instance/"},{"content":"대한민국 국적의 신체 건강한 남성이라면 누구나 군대라는 곳을 원치 않더라도 와야만 한다. 사회에서 떨어진 곳에서 자신이 하던 일을 지속하지 못한다는 점은 개개인들에게 경력단절이라는 큰 손해로 이어진다. 특히 개발자라는 직업은 특성상 빠르게 변화하는 트랜드에 민감하게 반응하고 공부해야 하는 만큼, 이로 인한 좌절은 더더욱 클 수밖에 없다.\n군대에 오고 얼마 지나지 않았을 무렵에는 사지방 PC에 직접 개발환경을 설치하고 개발해보려고 했으나 아래와 같은 제약조건에 인해 이 방법은 몇 번 사용하다가 포기했다.\n1 2 3  - 육군 지침에서 `자료 통신 프로토콜(ftp, telnet)`을 금하고 있다. - 이는 오픈소스 개발에 필수적인 `git`도 엄연히 사용해선 안된다는 것을 의미한다. - 사지방 PC는 자동 로그오프 기능과 초기화로 인해 개발환경 유지가 안된다.   위 제약사항을 다시보자. http나 https 프로토콜으로 웹 사이트 접속하는 것에는 전혀 문제가 없다는 것을 알 수 있다. 그렇기 때문에 웹 브라우저를 통해 통신하는 것은 지침에 위반되지 않는다. 나는 여기에 해답이 있다고 생각했고, 군대에서 코딩을 하는 방법을 찾아냈다.\n웹 기반 개발환경을 구축하면 초기화되지 않는 개인 특화된 개발환경을 사용 가능하다!\n구글링을 통해 알아본 바로 군복무를 하는 동안 cloud9이나 구름ide 등을 이용한 개발자 분들이 몇몇 계셨다. 하지만 나는 Google Cloud Platform을 활용하여 개발 환경을 구축하였다. GCP는 기본 인스턴스에 한해서는 평생 무료로 제공하며, 3달 동안 사용 가능한 $300 크레딧을 제공한다. 최소 3개월 동안은 intel의 쿼드코어 CPU, 15GB의 램 메모리로 구성된 인스턴스를 계속 운용할 수 있는 크레딧이다. 웹/앱 개발에 있어서는 충분한 성능을 제공하는 서버를 구축할 수 있다.\n 이전에는 1년 간 사용가능한 $300 크레딧을 제공했으나 사용기간이 단축되었다.\n 앞으로 포스팅을 통해서 서버를 생성해 개발환경을 구축하는 방법을 소개하고자 한다. 준비해야 할 단계는 딱 두 개뿐이다. 서버를 생성하고 개발환경을 구성한다.\n 1편 GCP 인스턴스 만들기 2편 Code-Server로 웹 IDE 구축하기  서버가 꼭 GCP로 구성되어야 하는 것은 아니다. 개인 서버를 이용해도 좋고 다른 서비스를 이용해도 좋으나, 나는 이번에 GCP를 활용해보았고 그 방법을 정리해보게 되었다.\n","description":"군대에서 코딩을 어떻게 할 수 있을까? 그 답을 찾기 위한 여정\n","id":6,"section":"posts","tags":null,"title":"군대에서 코딩하기","uri":"https://jeonghun-ban.github.io/posts/development/coding-in-the-military/"}]