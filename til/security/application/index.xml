<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jeonghun-Ban – Application</title><link>http://Jeonghun-Ban.github.io/til/security/application/</link><description>Recent content in Application on Jeonghun-Ban</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 16 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://Jeonghun-Ban.github.io/til/security/application/index.xml" rel="self" type="application/rss+xml"/><item><title>Til: FTP</title><link>http://Jeonghun-Ban.github.io/til/security/application/ftp/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/ftp/</guid><description>
&lt;h2 id="연결-모드">연결 모드&lt;/h2>
&lt;h3 id="능동-모드">능동 모드&lt;/h3>
&lt;p>제어 포트(TCP/21) / 데이터 전송(TCP/20)&lt;/p>
&lt;ol>
&lt;li>클라이언트는 서버의 &lt;code>21번 포트&lt;/code>로 연결(제어채널 생성)&lt;/li>
&lt;li>사용자가 파일 목록을 불러오는 명령(&lt;code>ls&lt;/code>)을 입력&lt;/li>
&lt;li>클라이언트는 &lt;code>임시 포트&lt;/code>(1024 이상)를 결정하여 서버에게 전달 (PORT 명령)&lt;/li>
&lt;li>서버는 클라이언트가 알려준 포트로 연결을 설정(데이터채널 생성)&lt;/li>
&lt;li>데이터채널을 통해 데이터를 송신한 후 연결 종료&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>FTP 클라이언트의 기본 모드&lt;/p>
&lt;/blockquote>
&lt;h3 id="수동-모드">수동 모드&lt;/h3>
&lt;p>제어 포트(TCP/21) / 데이터 전송(TCP/1024~)&lt;/p>
&lt;ol>
&lt;li>클라이언트는 서버의 &lt;code>21번 포트&lt;/code>로 연결(제어채널 생성)&lt;/li>
&lt;li>사용자가 파일 목록을 불러오는 명령(&lt;code>ls&lt;/code>)을 입력&lt;/li>
&lt;li>클라이언트는 수동모드로 연결하기 위해 &lt;code>PASV 명령&lt;/code>을 전송&lt;/li>
&lt;li>서버는 &lt;code>임시 포트&lt;/code>(1024 이상)를 결정하여 클라이언트에게 전달&lt;/li>
&lt;li>클라이언트는 서버가 알려준 포트로 연결을 설정(데이터채널 생성)&lt;/li>
&lt;li>데이터채널을 통해 데이터를 송신한 후 연결 종료&lt;/li>
&lt;/ol>
&lt;h2 id="종류">종류&lt;/h2>
&lt;h3 id="익명-ftpanonymous-ftp">익명 FTP(Anonymous FTP)&lt;/h3>
&lt;p>서버에 계정이 없는 사용자가 서버자원에 한정된 접근이 가능하도록 권한을 제공&lt;/p>
&lt;ul>
&lt;li>&lt;code>ID: anonymous, PW: email_address&lt;/code> 로 로그인&lt;/li>
&lt;li>비밀번호는 서버 로그에 기록하기 위한 용도&lt;/li>
&lt;/ul>
&lt;h3 id="tftptrivial-file-transfer-protocol">TFTP(Trivial File Transfer Protocol)&lt;/h3>
&lt;p>오직 기본적인 IP와 &lt;code>UDP&lt;/code>만을 필요로 하는 FTP (포트 : UDP/69)&lt;/p>
&lt;ul>
&lt;li>보안 기능이 없음&lt;/li>
&lt;li>FTP와의 차이
&lt;ul>
&lt;li>전송
&lt;ul>
&lt;li>프로토콜 차이&lt;/li>
&lt;li>TFTP는 부스트래핑 시 자주 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한정된 개수의 명령
&lt;ul>
&lt;li>&lt;code>파일 전송&lt;/code>만 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한정된 데이터 표현 방식
&lt;ul>
&lt;li>FTP가 지원하는 데이터 표현 방식을 전부 지원하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>인증의 부재&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="보안-위협-및-대책">보안 위협 및 대책&lt;/h2>
&lt;h3 id="ftp-보안">FTP 보안&lt;/h3>
&lt;p>비밀번호, 데이터 전송이 &lt;code>평문&lt;/code>이므로 공격자에게 노출 가능성이 있으므로 아래와 같은 프로토콜 사용이 권장된다.&lt;/p>
&lt;ul>
&lt;li>SFTP(SCP)
&lt;ul>
&lt;li>&lt;code>SSH기반&lt;/code> 파일 전송 프로토콜(TCP/22)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FTPS
&lt;ul>
&lt;li>&lt;code>SSL/TLS 기반&lt;/code> 파일 전송 프로토콜(TCP/990)&lt;/li>
&lt;li>FTP 응용계층, TCP 계층사이에 보안소켓을 추가하는 형식&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="tftp-보안">TFTP 보안&lt;/h3>
&lt;p>중요하지 않은 파일에만 접근할 수 있도록 제한하거나 TFTP 서버 근처에 있는 라우터에 보안을 구현하여, 특정 호스트만 서버에 접근하도록 해야 한다.&lt;/p>
&lt;h4 id="보안-대책">보안 대책&lt;/h4>
&lt;ul>
&lt;li>&lt;code>secure mode&lt;/code>로 운영&lt;/li>
&lt;li>지정 디렉터리를 루트 디렉터리로 지정하여 상위 디렉터리로 접근을 제한&lt;/li>
&lt;/ul>
&lt;h3 id="익명-ftp-보안">익명 FTP 보안&lt;/h3>
&lt;p>익명 사용자에게 쓰기 권한이 있을 경우 악성코드 생성이 가능&lt;/p>
&lt;h4 id="보안-대책-1">보안 대책&lt;/h4>
&lt;p>중요 디렉터리(/bin, /etc 등)의 소유자와 권한(permission)을 관리하거나 사용을 금지&lt;/p>
&lt;h3 id="bounce-attack">Bounce attack&lt;/h3>
&lt;p>FTP 서버가 데이터를 전송할 때 목적지를 검사하지 않는 문제점을 이용한 공격&lt;/p>
&lt;ul>
&lt;li>능동모드에서 &lt;code>PORT&lt;/code> 명령어로 공격자는 원하는 곳으로 데이터 전송 가늩&lt;/li>
&lt;/ul>
&lt;h4 id="보안-대책-2">보안 대책&lt;/h4>
&lt;ul>
&lt;li>FTP 규약을 어느 정도 제한
&lt;ul>
&lt;li>다른 서비스가 20번 포트 접속을 요청하면 거절&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>익명 FTP 서버의 경우 임시적으로 &lt;code>./incoming&lt;/code>에 파일 업로드 제한&lt;/li>
&lt;/ul>
&lt;h2 id="서비스-운영">서비스 운영&lt;/h2>
&lt;h3 id="proftpd">proftpd&lt;/h3>
&lt;ul>
&lt;li>보안과 기능의 중점을 둔 FTP 데몬&lt;/li>
&lt;li>매우 빠르고 안정적&lt;/li>
&lt;li>&lt;code>xinetd / standalone&lt;/code> 형태로 동작가능&lt;/li>
&lt;/ul>
&lt;h4 id="ftp-접속-시-확인-설정">FTP 접속 시 확인 설정&lt;/h4>
&lt;ul>
&lt;li>&lt;code>/etc/passwd&lt;/code>, &lt;code>/etc/shadow&lt;/code>에 사용자 계정이 있는지 검사&lt;/li>
&lt;li>&lt;code>/etc/ftpusers&lt;/code>에 사용자 id가 있으면 거부&lt;/li>
&lt;li>&lt;code>/etc/shell&lt;/code>에 등록되지 않는 쉘을 사용하는 유저는 거부&lt;/li>
&lt;/ul>
&lt;h4 id="설정-파일-옵션">설정 파일 옵션&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>옵션&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ServerType &lt;code>type&lt;/code>&lt;/td>
&lt;td>서버 타입 설정(xinetd / standalone)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RootLogin &lt;code>on/off&lt;/code>&lt;/td>
&lt;td>루트 계정 로그인 허용/거부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>user &lt;code>name&lt;/code>&lt;/td>
&lt;td>익명 접속할 경우 사용자를 &lt;code>name&lt;/code>으로 인식&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MaxClients &lt;code>num&lt;/code>&lt;/td>
&lt;td>최대 접속 허용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TimeoutLogin &lt;code>second&lt;/code>&lt;/td>
&lt;td>클라이언트가 인증을 유지할 수 있는 시간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TimeoutIdleftp &lt;code>second&lt;/code>&lt;/td>
&lt;td>접속 후 아무런 작업도 없는 상태 유지 시간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TimeoutSession &lt;code>second&lt;/code>&lt;/td>
&lt;td>&lt;code>second&lt;/code>초 후에 무조건 접속 종료&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="vsftpdvery-secure-ftp-daemon">vsftpd(Very Secure FTP Daemon)&lt;/h3>
&lt;ul>
&lt;li>가상 IP별 별도의 환경 설정 기능&lt;/li>
&lt;li>가상 사용자 설정&lt;/li>
&lt;li>전송 대역폭 지정&lt;/li>
&lt;li>PAM 지원&lt;/li>
&lt;li>상세 자체 로그 파일 형식을 지원&lt;/li>
&lt;li>&lt;code>xinetd / standalone&lt;/code> 형태로 작동 가능&lt;/li>
&lt;/ul></description></item><item><title>Til: Email</title><link>http://Jeonghun-Ban.github.io/til/security/application/email/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/email/</guid><description>
&lt;h2 id="구조">구조&lt;/h2>
&lt;ul>
&lt;li>사용자 대행자
&lt;ul>
&lt;li>MUA(Mail User Agent)
&lt;ul>
&lt;li>메시지 작성, 읽기, 답장 보내기 등을 수행하는 S/W&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>전송 대행자
&lt;ul>
&lt;li>MTA(Mail Transfer Agent)
&lt;ul>
&lt;li>전자우편을 &lt;code>SMTP&lt;/code>을 이용하여 다른 전자우편 서버로 전달하는 S/W&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MDA(Mail Delivery Agent)
&lt;ul>
&lt;li>전자우편을 수신자의 사서함으로 전달하는 S/W&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>접근 대행자
&lt;ul>
&lt;li>MAA (Mail Access Agent)
&lt;ul>
&lt;li>메시지를 검색하고자 할 때 사용&lt;/li>
&lt;li>&lt;code>IMAP&lt;/code>, &lt;code>POP3&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="프로토콜">프로토콜&lt;/h2>
&lt;p>&lt;img src="images/2020-06-03-20-38-14.png" alt="이메일 프로토콜">&lt;/p>
&lt;h3 id="smtpsimple-mail-transfer-protocol">SMTP(Simple Mail Transfer Protocol)&lt;/h3>
&lt;ul>
&lt;li>MTA 클라이언트와 서버를 규정하는 공식적인 프로토콜(TCP/25)&lt;/li>
&lt;li>송신자와 송신자의 메일서버 사이 그리고 두 메일 서버들 사이에서 총 &lt;code>두 번&lt;/code> 사용된다.&lt;/li>
&lt;/ul>
&lt;h3 id="pop3post-office-protocol-ver3">POP3(Post Office Protocol ver3)&lt;/h3>
&lt;ul>
&lt;li>메일을 &lt;code>PC에 다운&lt;/code>할수 있도록 해주는 프로토콜(TCP/110)&lt;/li>
&lt;li>다운시 서버에 있던 메일 내용은 삭제&lt;/li>
&lt;/ul>
&lt;h3 id="imap4internet-mail-access-protocol-ver4">IMAP4(Internet Mail Access Protocol ver4)&lt;/h3>
&lt;ul>
&lt;li>서버서 &lt;code>메일을 읽는&lt;/code> 프로토콜(TCP/143)&lt;/li>
&lt;li>제공 기능
&lt;ul>
&lt;li>전자우편 내려 받기 전에 헤더 검사&lt;/li>
&lt;li>내용 검색, 부분적 다운로드&lt;/li>
&lt;li>메일서버에서 편지함을 생성, 삭제, 이름 변경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="보안-기술">보안 기술&lt;/h2>
&lt;h3 id="pemprivacy-enhanced-mail">PEM(Privacy Enhanced Mail)&lt;/h3>
&lt;ul>
&lt;li>IETF서 인터넷 드래프트로 채택&lt;/li>
&lt;li>기밀성, 인증, 무결성, 부인방지를 지원하는 이메일 보안 기술&lt;/li>
&lt;li>SMTP에 암호화된 정보, 전자서명, 암호화를하여 전송&lt;/li>
&lt;li>이론 중심, 사양 방대, 구현의 복잡성 때문에 많이 사용되지 않음&lt;/li>
&lt;/ul>
&lt;h3 id="pgppretty-good-privacy">PGP(Pretty Good Privacy)&lt;/h3>
&lt;ul>
&lt;li>구현이 용이하여 널리 사용&lt;/li>
&lt;li>다양한 플랫폼 지원&lt;/li>
&lt;li>인증된 알고리즘 사용&lt;/li>
&lt;li>기밀성, 메시지 인증, 사용자 인증, 송신 부인방지 지원&lt;/li>
&lt;li>&lt;code>수신 부인방지&lt;/code>는 지원하지 않음&lt;/li>
&lt;/ul>
&lt;h3 id="smimesecure-multipurpose-internet-mail-extensions">S/MIME(Secure Multipurpose Internet Mail Extensions)&lt;/h3>
&lt;ul>
&lt;li>PEM의 구현 복잡성, PGP의 낮은 보안성을 보완하기 위해 &lt;code>RSADSI&lt;/code> 기술을 기반으로 개발된 기술&lt;/li>
&lt;li>메시지 기밀성, 무결성, 사용자 인증, 송신 부인 방지 기능 제공&lt;/li>
&lt;li>보안 메커니즘
&lt;ul>
&lt;li>전자서명: DSS(디지털 서명 표준), RSA 알고리즘&lt;/li>
&lt;li>세션키 암호화: Diffie-Hellman, RSA 알고리즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="동작">동작&lt;/h4>
&lt;ol>
&lt;li>사용자가 메시지를 보내기 이전, 보안 메커니즘(전자 서명, 암호화) 설정&lt;/li>
&lt;li>&lt;code>MIME&lt;/code> 형태로 작성된 메시지를 &lt;code>S/MIME&lt;/code> 메시지로 변환&lt;/li>
&lt;li>송신자는 메일 서버로 전송, 수신자는 S/MIME 클라이언트를 통해 메시지 수신&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>MIME: 전자우편을 통해 ASCII가 아닌 데이터가 송신될 수 있도록 허용하는 부가적인 프로토콜&lt;/p>
&lt;/blockquote>
&lt;h2 id="스팸메일-보안-대책">스팸메일 보안 대책&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;h3 id="메일서버-등록제-spf-sender-policy-framework">메일서버 등록제 (SPF, Sender Policy Framework)&lt;/h3>
&lt;ul>
&lt;li>메일 헤더에 표시된 IP가 실제로 메일을 발송한 서버 IP와 일치하는지 비교함으로써 발송자 정보의 위변조 여부를 판단&lt;/li>
&lt;li>발송자의 서버를 &lt;code>DNS&lt;/code>에 미리 등록하고 수신자의 서버에 메일이 도착하면 등록된 서버로부터 발신되었는지 확인하여 수신자에게 전달되기 전에 스팸메일을 차단하는 기술 (오픈 소스 기반)&lt;/li>
&lt;li>필터링 방식에 비해 서버 및 네트워크 자원 소모가 낮고 잘못 탐지할 가능성이 낮음&lt;/li>
&lt;/ul>
&lt;h3 id="스팸-필터-솔루션">스팸 필터 솔루션&lt;/h3>
&lt;ul>
&lt;li>메일서버 앞단에 위치하여 &lt;code>프록시 메일서버&lt;/code>로서 동작하며, SMTP 프로토콜을 이용한 DoS 공격이나 폭탄 메일, 스팸 메일을 차단&lt;/li>
&lt;li>주요 기능
&lt;ul>
&lt;li>메일 헤더 필터링&lt;/li>
&lt;li>제목 필터링&lt;/li>
&lt;li>본문 필터링&lt;/li>
&lt;li>첨부파일 필터링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>본문 검색 기능으로 내부 정보 유출 차단도 가능&lt;/li>
&lt;/ul></description></item><item><title>Til: HTTP(Hypertext Transfer Protocol)</title><link>http://Jeonghun-Ban.github.io/til/security/application/http/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/http/</guid><description>
&lt;h2 id="영속성">영속성&lt;/h2>
&lt;ul>
&lt;li>영속적 연결
&lt;ul>
&lt;li>서버는 연결 이후 클라이언트의 요청을 대기&lt;/li>
&lt;li>HTTP 1.1에서 Keep-Alive 옵션이 추가됨
&lt;ul>
&lt;li>연결 상태 지속시간 설정 기능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비영속적 연결
&lt;ul>
&lt;li>각 요구/응답에 대해 하나의 TCP 연결 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="트랜잭션">트랜잭션&lt;/h2>
&lt;p>&lt;img src="images/2020-06-04-15-20-24.png" alt="HTTP 트랜잭션">&lt;/p>
&lt;p>웹 브라우저가 웹 서버에 요청을 보내고 웹 서버가 이를 처리한 응답을 전송하는 한번의 과정&lt;/p>
&lt;h2 id="요청-메시지">요청 메시지&lt;/h2>
&lt;p>클라이언트가 서버에게 요청을 보낼 때 전송하는 메시지&lt;/p>
&lt;h3 id="요청-라인">요청 라인&lt;/h3>
&lt;p>요청 메시지의 첫 줄로 공백 문자로 구분된 세가지 필드를 가진다.&lt;/p>
&lt;ul>
&lt;li>Method&lt;/li>
&lt;li>URL&lt;/li>
&lt;li>Version&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>메소드&lt;/th>
&lt;th>역할&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET&lt;/td>
&lt;td>리소스 취득&lt;/td>
&lt;td>리소스 취득 인수를 URL에 포함시켜 전송, 최소한의 보안도 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HEAD&lt;/td>
&lt;td>문서 정보 취득&lt;/td>
&lt;td>GET과 비슷하나, 실제 문서를 요청하는 것이 아니라, &lt;code>문서 정보&lt;/code>를 요청&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST&lt;/td>
&lt;td>데이터 전송&lt;/td>
&lt;td>데이터를 HTTP 바디에 담아 웹서버로 전송, 최소한의 보안&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT&lt;/td>
&lt;td>데이터 전송(갱신 용도)&lt;/td>
&lt;td>POST와 유사하나 &lt;code>리소스 갱신&lt;/code>을 위해 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE&lt;/td>
&lt;td>파일 제거&lt;/td>
&lt;td>웹 리소스를 제거&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OPTIONS&lt;/td>
&lt;td>제공 메소드 옵션&lt;/td>
&lt;td>시스템에서 지원되는 &lt;code>메소드 종류&lt;/code>를 확인&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TRACE&lt;/td>
&lt;td>요청 리소스 수신 경로&lt;/td>
&lt;td>디버깅에 사용, 서버가 요청을 받고 있는지 여부 확인&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CONNECT&lt;/td>
&lt;td>프락시 기능 요청&lt;/td>
&lt;td>원하는 웹서버와의 중계 연결 요청&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>TRACE와 CONNECT는 현재는 거의 사용하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="요청-헤더">요청 헤더&lt;/h3>
&lt;p>바디 본문을 통해 전달하는 데이터(일반 문서) 이외의 정보를 교환하기 위해 사용&lt;/p>
&lt;ul>
&lt;li>&lt;code>host&lt;/code>, &lt;code>User-Agent&lt;/code>, &lt;code>Referer&lt;/code>, &lt;code>콘텐츠 길이&lt;/code>, &lt;code>쿠키 정보&lt;/code> 등&lt;/li>
&lt;li>헤더 이후에는 &lt;code>빈 라인&lt;/code>: 헤더의 끝을 의미&lt;/li>
&lt;/ul>
&lt;h3 id="바디">바디&lt;/h3>
&lt;ul>
&lt;li>PUT, POST일 때 송신될 주석, 웹사이트에 게시될 파일을 담고 있음&lt;/li>
&lt;li>GET 방식의 경우 요청 데이터가 없기 때문에 본체(Body)가 없음&lt;/li>
&lt;/ul>
&lt;h2 id="응답-메시지">응답 메시지&lt;/h2>
&lt;p>서버가 클라이언트에게 응답을 보낼 때 전송하는 메시지&lt;/p>
&lt;h3 id="상태-코드">상태 코드&lt;/h3>
&lt;p>세 자리 숫자로 요청의 상태를 정의&lt;/p>
&lt;ul>
&lt;li>1xx (조건부 응답): 요청을 받았으며 프로세스를 계속한다&lt;/li>
&lt;li>2xx (성공): 요청을 성공적으로 수신하여 처리하였다&lt;/li>
&lt;li>3xx (리다이렉션): 요청 완료를 위해 추가 동작을 취해야 한다&lt;/li>
&lt;li>4xx (클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다&lt;/li>
&lt;li>5xx (서버 오류): 서버가 명백히 유효한 요청에 대한 수행을 실패했다&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>상태 코드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>100(continue)&lt;/td>
&lt;td>요청의 첫 부분이 서버 도착했으며 나머지를 기다리고 있는 상태. 요청자는 요청을 계속해야한다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>101(Switching Protocols)&lt;/td>
&lt;td>요청자가 서버에 프로토콜 전환을 요청했으며 서버는 이를 승인하는 중이다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>200(Ok)&lt;/td>
&lt;td>서버가 요청을 제대로 처리했다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>201(Created)&lt;/td>
&lt;td>성공적으로 요청되었으며 서버가 새 리소스를 작성했다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>202(Accepted)&lt;/td>
&lt;td>서버가 요청을 접수했지만 아직 처리하지 않았다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>204(No Content)&lt;/td>
&lt;td>성공적으로 처리했지만 컨텐츠를 제공하지는 않는다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>301(Moved Permanently)&lt;/td>
&lt;td>요청한 페이지를 새 위치로 영구적으로 이동했다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>302(Found)&lt;/td>
&lt;td>현재 서버가 다른 위치의 페이지로 요청에 응답하고 있지만 요청자는 향후 요청 시 원래 위치를 계속 사용해야 한다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>304(Not Modified)&lt;/td>
&lt;td>마지막 요청 이후 요청한 페이지는 수정되지 않았다. 클라이언트 내 캐시 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>400(Bad Request)&lt;/td>
&lt;td>요청 자체가 잘못되었을때 사용하는 코드이다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>401(Unauthorized)&lt;/td>
&lt;td>인증이 필요한 리소스에 인증 없이 접근할 경우 발생한다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>403(Forbidden)&lt;/td>
&lt;td>서버가 요청을 거부할 때 발생한다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>404(Not Found)&lt;/td>
&lt;td>찾는 리소스가 없다는 뜻이다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>405(Method Not Allowed)&lt;/td>
&lt;td>서버에서 허용되지 않은 메소드로 요청시 사용하는 코드이다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>500(Internal Server Error)&lt;/td>
&lt;td>서버에 오류가 발생해 작업을 수행할 수 없을 때 사용된다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>501(Not Implemented)&lt;/td>
&lt;td>서버가 요청을 수행하는데 필요한 기능을 지원하지 않는 경우 사용된다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>502(Bad Gateway)&lt;/td>
&lt;td>게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용된다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>504(Gateway Timeout)&lt;/td>
&lt;td>게이트웨이가 연결된 서버로부터 응답을 받을 수 없었을 때 사용된다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!-- raw HTML omitted -->
&lt;h3 id="응답-헤더">응답 헤더&lt;/h3>
&lt;p>추가적인 정보를 서버에서 클라이언트로 보냄&lt;/p>
&lt;ul>
&lt;li>&lt;code>Contents-Type&lt;/code>, &lt;code>Contents-Length&lt;/code> 등&lt;/li>
&lt;/ul>
&lt;h3 id="바디-1">바디&lt;/h3>
&lt;ul>
&lt;li>서버에서 클라이언트로 전송되는 문서를 포함&lt;/li>
&lt;li>응답이 오류 메시지가 아니라면 본체가 존재&lt;/li>
&lt;/ul></description></item><item><title>Til: SSL/TLS</title><link>http://Jeonghun-Ban.github.io/til/security/application/ssl-and-tsl/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/ssl-and-tsl/</guid><description>
&lt;ul>
&lt;li>대칭키 암호, 일방향 해시함수, MAC, 의사난수 생성기, 전자서명을 조합해 안전한 통신 수행&lt;/li>
&lt;li>암호 스위트를 변경하여 강력한 알고리즘 사용 (특정 암호기술에 의존 X)&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>암호 스위트: SSL/TLS 암호화 통신에 사용할 암호 알고리즘&lt;/p>
&lt;/blockquote>
&lt;h2 id="보안-서비스">보안 서비스&lt;/h2>
&lt;ul>
&lt;li>기밀성
&lt;ul>
&lt;li>대칭키 암호화 알고리즘을 사용하여 제공&lt;/li>
&lt;li>비밀키는 &lt;code>Handshake Protocol&lt;/code>을 통해 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클라이언트와 서버 상호 인증
&lt;ul>
&lt;li>RSA 같은 비대칭키 암호 알고리즘&lt;/li>
&lt;li>DSS와 같은 전자서명 알고리즘&lt;/li>
&lt;li>X.509 공개키 인증서&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>무결성
&lt;ul>
&lt;li>해시 알고리즘을 사용해 MAC를 만들어 메시지에 포함시켜 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="절차">절차&lt;/h2>
&lt;ol>
&lt;li>지원 가능한 알고리즘 서로 교환&lt;/li>
&lt;li>키 교환, 인증&lt;/li>
&lt;li>대칭키 암호로 암호화하고 메시지 인증&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>메시지 인증 코드는 HMAC 해시 함수를 이용&lt;/p>
&lt;/blockquote>
&lt;h2 id="tls-프로토콜">TLS 프로토콜&lt;/h2>
&lt;p>&lt;code>SSL 3.0&lt;/code>을 기초로 인터넷 표준버전이 되도록 만든 IETF 표준&lt;/p>
&lt;ul>
&lt;li>TCP에 의존하는 프로토콜&lt;/li>
&lt;li>응용계층과 전송계층 사이에서 동작&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>SSL은 현재 취약점이 발견되어 사용이 권장되지 않음&lt;/p>
&lt;/blockquote>
&lt;h2 id="tls-구조">TLS 구조&lt;/h2>
&lt;p>&lt;img src="images/2020-06-04-18-39-22.png" alt="TLS 구조">&lt;/p>
&lt;h3 id="record-protocol">Record Protocol&lt;/h3>
&lt;p>데이터를 암호화하고 압축하여 안전하게 전송하는 프로토콜&lt;/p>
&lt;ul>
&lt;li>데이터를 SSL에서 처리할 수 있는 단위로 단편화, 압축, MAC 계산, 암호화하여 TCP 단편으로 전송&lt;/li>
&lt;/ul>
&lt;h3 id="handshake-protocol">Handshake Protocol&lt;/h3>
&lt;ul>
&lt;li>클라이언트-서버간 안전한 연결 수립을 위한 &lt;code>상호 인증&lt;/code>&lt;/li>
&lt;li>암호화 &lt;code>MAC 알고리즘&lt;/code> 및 TLS Recode 내 데이터 보호를 위한 &lt;code>암호키&lt;/code> 협상&lt;/li>
&lt;li>구성 필드
&lt;ul>
&lt;li>유형(1byte)
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>유형&lt;/th>
&lt;th>매개변수&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>hello-request&lt;/td>
&lt;td>null&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client- hello&lt;/td>
&lt;td>버전, 랜덤, 세션 id, 암호도구, 압축방법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server-hello&lt;/td>
&lt;td>버전, 랜덤, 세션 id, 암호도구, 압축방법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>certificate&lt;/td>
&lt;td>연속된 X.509v3 인증서&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server_key_exchange&lt;/td>
&lt;td>매개변수, 서명&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>certificat_request&lt;/td>
&lt;td>유형, 기관&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server_hello_done&lt;/td>
&lt;td>null&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>certificate_verify&lt;/td>
&lt;td>서명&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client_key_exchange&lt;/td>
&lt;td>매개변수, 서명&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>finished&lt;/td>
&lt;td>해시값&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>길이(3byte)&lt;/li>
&lt;li>내용(0byte 이상)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="초기협상-단계">초기협상 단계&lt;/h4>
&lt;p>클라이언트와 서버는 SSL 버전, 키교환/메시지인증/암호화를 위한 알고리즘, 압축 방법, 난수 등을 수집&lt;/p>
&lt;p>&lt;img src="images/2020-06-05-01-33-39.png" alt="초기협상 단계">&lt;/p>
&lt;ul>
&lt;li>Hello_Request: 서버가 클라이언트에게 협상의 시작을 요구&lt;/li>
&lt;li>Client_Hello: 클라이언트가 서버에 연결을 시작하거나 &lt;code>HelloRequest&lt;/code> 메시지에 대해 응답&lt;/li>
&lt;li>Server_Hello: Client_Hello 메시지에 대한 응답&lt;/li>
&lt;/ul>
&lt;h4 id="서버-인증-단계">서버 인증 단계&lt;/h4>
&lt;p>서버는 인증서와 키 교환 전송 후 인증서를 요청, hello 메시지 종료 시그널 전송&lt;/p>
&lt;p>&lt;img src="images/2020-06-05-01-39-28.png" alt="서버 인증 단계">&lt;/p>
&lt;ul>
&lt;li>Certificate: 선택된 &lt;code>cipher suite&lt;/code>의 키 교환 알고리즘에 맞는 &lt;code>서버의 인증서&lt;/code>를 보냄&lt;/li>
&lt;li>Server_Key_Exchange: 인증서를 보내지 않았거나, 보낸 인증서에 정보가 부족할 때 전송&lt;/li>
&lt;li>Certificate_Request: 클라이언트의 인증서를 요청, 상호 인증이 이루어짐(선택 사항)&lt;/li>
&lt;li>Server_Hello_Done: 서버가 메시지를 다 보냈다고 알리는 메시지&lt;/li>
&lt;/ul>
&lt;h4 id="클라이언트-인증-단계">클라이언트 인증 단계&lt;/h4>
&lt;p>클라이언트는 요청이 있을 시 인증서, 키 교환, 인증서 확인 전송&lt;/p>
&lt;p>&lt;img src="images/2020-06-05-02-25-39.png" alt="클라이언트 인증 단계">&lt;/p>
&lt;ul>
&lt;li>Certificate: 서버가 클라이언트의 인증을 요구할 경우 클라이언트가 보내는 메시지&lt;/li>
&lt;li>Client_Key_Exchange: 세션키를 생성하기 위해 48bytes의 비밀 정보를 생성, 공개키 알고리즘을 사용하여 &lt;code>pre_master_secret&lt;/code>를 서버와 공유&lt;/li>
&lt;li>Certificate_Verify: 클라이언트 인증서의 명백한 확인을 위해 &lt;code>handshake&lt;/code> 메시지를 &lt;code>전자서명&lt;/code>하여 전송&lt;/li>
&lt;/ul>
&lt;h4 id="종료-단계">종료 단계&lt;/h4>
&lt;p>암호 스위트 변경 후 handshake 프로토콜 종료&lt;/p>
&lt;p>&lt;img src="images/2020-06-05-02-25-51.png" alt="종료 단계">&lt;/p>
&lt;ul>
&lt;li>Change_Cipher_Spec: 이 메시지 이후에 전송되는 메시지는 새롭게 협상된 알고리즘과 키를 이용할 것임을 나타냄. (Handshake 프로토콜에 포함되지 않음)&lt;/li>
&lt;li>Finished: &lt;code>협상된 알고리즘과 키&lt;/code>가 처음으로 적용, 이후 &lt;code>데이터 전송&lt;/code>이 시작됨&lt;/li>
&lt;/ul>
&lt;h3 id="changecipherspec-protocol">ChangeCipherSpec Protocol&lt;/h3>
&lt;ul>
&lt;li>종단 간 협상된 보안 파라미터를 &lt;code>이후부터 적용/변경&lt;/code>함을 알리기 위해 사용&lt;/li>
&lt;li>1 바이트 메시지&lt;/li>
&lt;/ul>
&lt;h3 id="alert-protocol">Alert Protocol&lt;/h3>
&lt;ul>
&lt;li>통신 과정에서 발생하는 &lt;code>오류를 통보&lt;/code>하기 위해 경고 할 때 사용&lt;/li>
&lt;li>구성 필드(2바이트)
&lt;ul>
&lt;li>첫번째 바이트: warning(1), fatal(2)&lt;/li>
&lt;li>두번째 바이트: 세부 에러코드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="heartbeat-protocol">Heartbeat Protocol&lt;/h3>
&lt;ul>
&lt;li>정상적으로 동작한다는걸 나타내기 위한 S/W나 S/W가 생성하는 주기적 신호&lt;/li>
&lt;li>가용성을 모니터링 할 때 사용함&lt;/li>
&lt;/ul>
&lt;h2 id="공격-및-보안대책">공격 및 보안대책&lt;/h2>
&lt;h3 id="openssl의-heartbleed-취약점">OpenSSL의 HeartBleed 취약점&lt;/h3>
&lt;p>&lt;code>heartbeat 프로토콜의 확장&lt;/code>이라는 기능에 요구 데이터 길이에 대한 점검 결여로 인해 메모리상 관계없는 정보까지 상대방에게 넘어가 버리는 공격&lt;/p>
&lt;blockquote>
&lt;p>공격자는 heartbleed 공격으로 서버의 정보를 일정범위까지 훔칠 수 있음&lt;/p>
&lt;/blockquote>
&lt;h4 id="보안대책">보안대책&lt;/h4>
&lt;ul>
&lt;li>취약성 대책이 실행된 버전으로 &lt;code>OpenSSL&lt;/code> 갱신&lt;/li>
&lt;li>heartbeat 확장 사용을 하지 않는 옵션으로 재컴파일&lt;/li>
&lt;/ul>
&lt;h3 id="poodle-공격">POODLE 공격&lt;/h3>
&lt;p>공격자가 TLS를 &lt;code>SSL 3.0으로 다운그레이드&lt;/code>한 통신을 강요하여 &lt;code>MITM(중간자 공격)&lt;/code>을 통해 암호화되어 송ㆍ수신되는 쿠키정보, 데이터를 추출하는 공격&lt;/p>
&lt;h4 id="보안대책-1">보안대책&lt;/h4>
&lt;ul>
&lt;li>브라우저 상에서 &lt;code>SSL 3.0&lt;/code>의 비활성화&lt;/li>
&lt;/ul>
&lt;h3 id="freak-공격">FREAK 공격&lt;/h3>
&lt;p>SSL/TLS 서버가 &lt;code>RSA Export Suites&lt;/code>라고 불리는 약한 암호 스위트를 사용하게 만드는 공격&lt;/p>
&lt;h4 id="보안대책-2">보안대책&lt;/h4>
&lt;ul>
&lt;li>OpenSSL 최신버전 업그레이드&lt;/li>
&lt;li>OS 및 브라우저 업그레이드&lt;/li>
&lt;/ul></description></item><item><title>Til: DHCP/DNS</title><link>http://Jeonghun-Ban.github.io/til/security/application/dhcp-and-dns/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/dhcp-and-dns/</guid><description>
&lt;h2 id="dhcpdynamic-host-configuration-protocol">DHCP(Dynamic Host Configuration Protocol)&lt;/h2>
&lt;p>&lt;code>네임 서버 주소&lt;/code>, &lt;code>IP주소&lt;/code>, &lt;code>서브넷 마스크&lt;/code>, &lt;code>게이트웨이 주소&lt;/code> 등을 자동으로 할당해주는 프로토콜&lt;/p>
&lt;ul>
&lt;li>&lt;code>동적&lt;/code> 설정 프로토콜&lt;/li>
&lt;li>&lt;code>UDP&lt;/code> 기반 프로토콜&lt;/li>
&lt;/ul>
&lt;h3 id="이전-프로토콜">이전 프로토콜&lt;/h3>
&lt;h4 id="rarp">RARP&lt;/h4>
&lt;p>호스트의 &lt;code>MAC주소&lt;/code>를 통해 RARP 서버에서 &lt;code>IP 주소&lt;/code>를 매핑하여 호스트에게 전달&lt;/p>
&lt;ul>
&lt;li>단점
&lt;ul>
&lt;li>IP 주소만을 제공&lt;/li>
&lt;li>서브넷마다 브로드캐스트 방식 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="bootp">BOOTP&lt;/h4>
&lt;p>RARP의 약점 2가지를 극복하기 위해 만든 클라이언트-서버 프로그램&lt;/p>
&lt;ul>
&lt;li>DHCP와 &lt;code>상호호환&lt;/code>
&lt;ul>
&lt;li>패킷 구조가 거의 동일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>정적&lt;/code>인 프로토콜
&lt;ul>
&lt;li>고정된 IP 주소와의 바인딩만 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동작-원리">동작 원리&lt;/h3>
&lt;ul>
&lt;li>DHCP Discover: DHCP서버가 있는지 확인을 위한 메시지 생성
&lt;ul>
&lt;li>출발지 IP: &lt;code>0.0.0.0&lt;/code>, 목적지 IP: &lt;code>255.255.255.255&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DHCP Offer: DHCP에서 PC에게 줄 수 있는 &lt;code>IP주소 리스트&lt;/code>를 제공&lt;/li>
&lt;li>DHCP Request: 리스트중 IP 하나를 선택하여 제공을 요청&lt;/li>
&lt;li>DHCP Ack : IP 및 네트워크 정보를 할당해주고 임대 기간 전달&lt;/li>
&lt;/ul>
&lt;h3 id="장단점">장단점&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>N/W 설계 변경이 자유로움&lt;/td>
&lt;td>DHCP 클라이언트는 부팅시 브로드캐스트 방식으로 트래픽 전송 (N/S 성능저하)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DHCP 서버에서만 N/W 정보 변경하면 되기 때문에 N/W 구성변경 용이&lt;/td>
&lt;td>호스트 전원이 켜 있는 것 만으로 IP 할당됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실제로 호스트가 사용중일 때만 IP 할당하기 때문에 IP 절약 가능&lt;/td>
&lt;td>호스트 전원을 꺼도 임대기간까지 해당 IP는 다른 단말에 할당 X (IP주소 낭비)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용자가 TCP/IP를 따로 설정할 필요가 없음&lt;/td>
&lt;td>호스트 수가 많아지면 서버의 과부하 발생&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="starvation-공격">Starvation 공격&lt;/h3>
&lt;ul>
&lt;li>공격자가 DHCP 서버의 할당 가능한 &lt;code>IP를 모두 소진&lt;/code>하게 하여 IP할당이 불가능하게 하는 공격&lt;/li>
&lt;li>공격자는 DHCPDISCOVER msg를 서로다른 MAC주소로 DHCP에 보내고 서버로부터 OFFER가 오면 REQUEST까지만 하고 실제로 주소는 할당하지 않음&lt;/li>
&lt;/ul>
&lt;h2 id="dnsdomain-name-server">DNS(Domain Name Server)&lt;/h2>
&lt;p>도메인 네임을 IP 주소로 변환해주는 시스템&lt;/p>
&lt;ul>
&lt;li>zone 파일: 개별 도메인에 대한 DNS 정보가 설정되어 있는 파일&lt;/li>
&lt;/ul>
&lt;h3 id="구성-요소">구성 요소&lt;/h3>
&lt;ul>
&lt;li>루트 서버
&lt;ul>
&lt;li>전체 트리 영역을 가지는 서버&lt;/li>
&lt;li>도메인에 대한 정보를 갖지 않으며, &lt;code>다른 서버들에 대한 참조&lt;/code>만 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>1차 서버(Primary Server)
&lt;ul>
&lt;li>자신이 권한을 가지는 &lt;code>zone에 대한 파일&lt;/code>을 가짐&lt;/li>
&lt;li>파일에 대한 생성/관리/갱신의 책임을 가지며 로컬 디스크에 저장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2차 서버(Secondary Server)
&lt;ul>
&lt;li>영역파일을 생성하지 않으며 갱신하지도 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>존 전송(Zone Transfer)
&lt;ul>
&lt;li>마스터에 있는 원본 존 DATA를 슬레이브가 동기화하는 작업(TCP/53)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동작-방식">동작 방식&lt;/h3>
&lt;ul>
&lt;li>재귀적(Recursive) 해석
&lt;ul>
&lt;li>클라이언트가 네임 서버에게 재귀적 요청&lt;/li>
&lt;li>서버는 정보가 있는 경우 해당 정보로 응답&lt;/li>
&lt;li>없는 경우 &lt;code>다른 서버&lt;/code>(부모 서버)에게 새로운 &lt;code>재귀적 요청&lt;/code>을 보내어 응답&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반복적(Iterative) 해석
&lt;ul>
&lt;li>클라이언트가 네임 서버에게 반복적 요청&lt;/li>
&lt;li>서버는 정보가 있는 경우 해당 정보로 응답&lt;/li>
&lt;li>없는 경우 그 정보에 좀 더 가까운 &lt;code>다른 서버의 네임&lt;/code>으로 응답&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="질의-순서">질의 순서&lt;/h3>
&lt;ul>
&lt;li>캐시
&lt;ul>
&lt;li>주소 해석 속도를 높이기 위해 사용&lt;/li>
&lt;li>네거티브 캐싱: 너무 오래동안 캐싱정보를 가지고 있으면 정보가 잘못될 수 있음
&lt;ul>
&lt;li>이 경우 잘못된 매핑 정보를 보냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hosts 파일
&lt;ul>
&lt;li>&lt;code>/etc/hosts&lt;/code>&lt;/li>
&lt;li>도메인/호스트명과 IP주소 매핑정보를 담고있는 파일&lt;/li>
&lt;li>네임 서버에 질의되기 전 참조되는 파일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로컬 DNS 서버
&lt;ul>
&lt;li>Recursive DNS 서버
&lt;ul>
&lt;li>동일한 작업을 조건이 만족할 때 까지 반복적으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Authoritative DNS 서버
&lt;ul>
&lt;li>권한이 있는 네임서버&lt;/li>
&lt;li>특정 도메인에 대한 정보를 관리, 해당 도메인에 대한 질의만 응답&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="dns-스푸핑">DNS 스푸핑&lt;/h2>
&lt;h3 id="스니핑">스니핑&lt;/h3>
&lt;p>공격 대상이 DNS 질의를 수행하면 공격자가 스니핑을 하고 있다가 &lt;code>정상 응답보다 빠르게&lt;/code> 희생자에게 조작된 웹 사이트 정보를 담은 DNS 응답을 보내 조작된 주소로 접속하게 만드는 공격&lt;/p>
&lt;ul>
&lt;li>UDP의 특징 중 먼저 수신한 응답을 제외한 나머지 응답은 모두 버린다는 특징을 이용&lt;/li>
&lt;/ul>
&lt;h4 id="보안대책">보안대책&lt;/h4>
&lt;ul>
&lt;li>스니핑 탐지 및 차단&lt;/li>
&lt;li>중요한 사이트 IP주소는 hosts파일을 사용&lt;/li>
&lt;/ul>
&lt;h3 id="캐시-포이즈닝">캐시 포이즈닝&lt;/h3>
&lt;p>DNS 서버의 캐시정보를 조작하는 공격&lt;/p>
&lt;h4 id="공격-절차">공격 절차&lt;/h4>
&lt;ul>
&lt;li>공격 대상 DNS 서버(Recursive DNS Server)에 조작할 도메인 질의를 다수 전송
&lt;ul>
&lt;li>DNS 서버가 질의에 사용하는 &lt;code>Transaction ID&lt;/code>와 출발지 &lt;code>Port&lt;/code> 랜덤으로 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>조작된 응답 중 정상 응답보다 먼저 &lt;code>Transaction ID&lt;/code>와 출발지 &lt;code>Port&lt;/code>가 일치한 응답이 있으면 조작된 주소 정보가 공격 대상 DNS 서버의 캐시에 저장됨&lt;/li>
&lt;/ul>
&lt;h4 id="보안대책-1">보안대책&lt;/h4>
&lt;ul>
&lt;li>소프트웨어 최신 버전 상태 유지&lt;/li>
&lt;li>도메인 관리용 DNS 서버는 재귀적 질의를 허용하지 않음&lt;/li>
&lt;li>DNSSEC 기술을 활용&lt;/li>
&lt;/ul></description></item><item><title>Til: Database</title><link>http://Jeonghun-Ban.github.io/til/security/application/database/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/database/</guid><description>
&lt;h2 id="기본-개념">기본 개념&lt;/h2>
&lt;h3 id="용어">용어&lt;/h3>
&lt;ul>
&lt;li>릴레이션: 하나의 개체에 관한 데이터를 &lt;code>2차원 테이블&lt;/code>의 구조로 저장한 것&lt;/li>
&lt;li>속성과 튜플: 릴레이션의 열(속성)과 행(튜플)&lt;/li>
&lt;li>null: 아직 모르거나 해당되는 사항이 없음을 표현하는 특별한 값&lt;/li>
&lt;li>차수: 하나의 릴레이션에서 &lt;code>속성의 전체 개수&lt;/code>&lt;/li>
&lt;li>카디널리티: 하나의 릴레이션에서 &lt;code>튜플의 전체 개수&lt;/code>&lt;/li>
&lt;li>도메인: 한 릴레이션에서 특정 속성이 가질 수 있는 데이터 형식을 지닌 모든 &lt;code>가능한 값의 집합&lt;/code>&lt;/li>
&lt;li>extent: 테이블을 구성하는 물리적으로 연속적인 디스크 공간&lt;/li>
&lt;/ul>
&lt;h3 id="키-정의">키 정의&lt;/h3>
&lt;ul>
&lt;li>후보키(Candidate Key): 키의 특성인 &lt;code>유일성&lt;/code>과 &lt;code>최소성&lt;/code>을 만족하는 키&lt;/li>
&lt;li>슈퍼키(Super Key): &lt;code>유일성&lt;/code>을 만족하는 키&lt;/li>
&lt;li>기본키(Primary Key): 여러 개의 후보키 중에서 하나를 선정하여 사용하는 키&lt;/li>
&lt;li>대체키(Alternate Key): 여러 개의 후보키 중에서 &lt;code>기본키를 제외&lt;/code>한 나머지 키&lt;/li>
&lt;li>외래키(Foreign Key): 어느 한 릴레이션 속성의 집합이 다른 릴레이션에서 기본키로 이용되는 키&lt;/li>
&lt;/ul>
&lt;h3 id="무결성">무결성&lt;/h3>
&lt;ul>
&lt;li>키 무결성(key integrity): 한 릴레이션에 &lt;code>같은 키값&lt;/code>을 가진 튜플이 있어서는 안됨&lt;/li>
&lt;li>개체 무결성(entity integrity): 기본키에 속해 있는 전체 또는 일부 속성은 &lt;code>NULL 값&lt;/code>을 가질 수 없음&lt;/li>
&lt;li>참조 무결성(referential integrity): 릴레이션은 참조할 수 없는 외래키값을 가질 수 없음&lt;/li>
&lt;/ul>
&lt;h3 id="트랜잭션">트랜잭션&lt;/h3>
&lt;ul>
&lt;li>하나의 논리적 기능을 수행하기 위한 &lt;code>작업의 단위&lt;/code>&lt;/li>
&lt;li>한꺼번에 모두 수행해야 할 일련의 DB 연산&lt;/li>
&lt;li>병행 제어 및 회복 작업의 논리적 단위&lt;/li>
&lt;/ul>
&lt;h4 id="성질">성질&lt;/h4>
&lt;ul>
&lt;li>원자성(Atomictiy)
&lt;ul>
&lt;li>트랜잭션 내 모든 연산은 &lt;code>반드시 한번에 완료&lt;/code>&lt;/li>
&lt;li>그렇지 않을 경우 한꺼번에 취소 (all or nothing)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일관성(Consistently)
&lt;ul>
&lt;li>트랜잭션이 성공적으로 완료되면 일관성 있는 DB 상태로 변환&lt;/li>
&lt;li>단 프로그램 실행 중 일관성 위반은 상관없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>격리성(Isolation)
&lt;ul>
&lt;li>트랜잭션이 실행중에 있는 연산의 중간결과에 다른 연산이 접근하지 X&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>영속성(Durability)
&lt;ul>
&lt;li>트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 영속적&lt;/li>
&lt;li>따라서 시스템은 어떤 경우라도 완료된 결과의 영속성을 보장해야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="보안">보안&lt;/h2>
&lt;p>DB 상의 데이터에 대한 인가되지 않은 접근, 의도적/비의도적 변경, 파괴 등의 &lt;code>일관성 저해&lt;/code>하는 사고 등으로부터 DB를 보호하는 것&lt;/p>
&lt;blockquote>
&lt;p>보안 특성: 비밀성, 무결성, 가용성&lt;/p>
&lt;/blockquote>
&lt;h3 id="보안-위협">보안 위협&lt;/h3>
&lt;p>사용자가 데이터에 접근함으로써 발생될 수 있는 정보의 부적절한 유출, 부적절한 처리, 수정으로부터 무결성의 손상 발생 가능&lt;/p>
&lt;h4 id="집성aggregation">집성(Aggregation)&lt;/h4>
&lt;p>개별적인 여러 소스로부터 민감하지 않은 정보(낮은 보안 등급)를 &lt;code>수집/조합&lt;/code>하여 민감한 정보(높은 보안
등급)를 알아내는 행위&lt;/p>
&lt;h4 id="추론inference">추론(Inference)&lt;/h4>
&lt;p>일반적인 데이터로부터 비밀정보를 &lt;code>추측&lt;/code>해내는 행위&lt;/p>
&lt;h3 id="요구사항">요구사항&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>보안 요구사항&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>부적절한 접근 방지&lt;/td>
&lt;td>승인된 사용자에게만 접근 권한 부여 및 사용자, 응용 시스템의 접근 요청에 대한 정당성 여부 검사&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>추론방지&lt;/td>
&lt;td>사용자가 통계적인 데이터로 개별적인 데이터 항목에 대한 정보를 추적할 수 없도록 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>무결성 보장&lt;/td>
&lt;td>인가되지 않은 접근, 저장 데이터를 손상시킬수 있는 시스템 오류 등으로 DB를 보호&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>운영적 무결성 보장&lt;/td>
&lt;td>트랜잭션의 병행 처리 동안에 데이터에 대한 논리적 일관성을 보장&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>의미적 무결성 보장&lt;/td>
&lt;td>데이터에 대한 허용값을 통제함으로써 데이터의 논리적 일관성을 보장&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>감사기능&lt;/td>
&lt;td>DB에 대한 모든 접근이 감사기록을 생성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용자 인증&lt;/td>
&lt;td>OS서 수행하는 사용자 인증보다 엄격한 인증 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>기밀성 보장&lt;/td>
&lt;td>중요 데이터에 대한 기밀성 보호, 인가된 사용자에게만 접근을 허용해야 함&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="db-보안-통제">DB 보안 통제&lt;/h2>
&lt;h3 id="흐름제어">흐름제어&lt;/h3>
&lt;p>높은 수준의 보안이 낮은 수준의 객체로 이동하는 것을 검사하여 접근 가능한 객체 간 정보흐름을 조정&lt;/p>
&lt;h3 id="추론제어">추론제어&lt;/h3>
&lt;p>간접적인 데이터 노출로부터 데이터를 보호하기 위한 제어&lt;/p>
&lt;ul>
&lt;li>비밀정보 은폐&lt;/li>
&lt;li>DB 지식 추적
&lt;ul>
&lt;li>사용자가 가지고 있는 데이터를 고려하여 질의 허용여부를 결정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 위장
&lt;ul>
&lt;li>일관성 없는 질의결과 제공해 통계적 추론을 방지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="접근제어">접근제어&lt;/h3>
&lt;p>허가된 범위 내 시스템 정보에 대한 접근을 권한에 따라 &lt;code>인가된 사용자&lt;/code>에게만 제공&lt;/p>
&lt;h4 id="os-접근통제와-비교">OS 접근통제와 비교&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>OS&lt;/th>
&lt;th>DB&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>객체(파일)는 다른 객체와 관련성이 없음&lt;/td>
&lt;td>객체(레코드, 필드)는 상호 관련되어 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용자는 하나의 파일을 읽고 다른 파일의 내용을 결정할 수 없음&lt;/td>
&lt;td>하나의 데이터 요소를 읽고서 다른 데이터의 내용을 결정할 수 있음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="추론">추론&lt;/h3>
&lt;p>인가된 쿼리 수행과 합법적 응답을 통해 비인가된 정보를 추론&lt;/p>
&lt;h4 id="방지-방법">방지 방법&lt;/h4>
&lt;ul>
&lt;li>DB 설계시 추론 탐지
&lt;ul>
&lt;li>DB 구조변경, 접근 제어 방식 변경으로 &lt;code>추론 채널을 제거&lt;/code>해 추론을 방지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쿼리 타임 시 추론탐지
&lt;ul>
&lt;li>쿼리처리 중 추론 채널 위반을 제거하려는 시도&lt;/li>
&lt;li>추론 채널이 탐지되면 쿼리를 거부하거나 변경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="dbms-보안-통제">DBMS 보안 통제&lt;/h2>
&lt;h3 id="sql-기반">SQL 기반&lt;/h3>
&lt;p>통상 DB관리자(DBA)가 권한을 가지므로 DBA권한이라고 함&lt;/p>
&lt;ul>
&lt;li>SQL은 &lt;code>GRANT&lt;/code>와 &lt;code>REVOKE&lt;/code>라는 접근 권한 관리 명령어를 제공&lt;/li>
&lt;/ul>
&lt;h4 id="grant권한-부여">GRANT(권한 부여)&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-SQL" data-lang="SQL">&lt;span style="color:#66d9ef">GRANT&lt;/span> privilege_name &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">role&lt;/span> &lt;span style="color:#66d9ef">To&lt;/span> user_name [&lt;span style="color:#66d9ef">WITH&lt;/span> &lt;span style="color:#66d9ef">ADMIN&lt;/span> &lt;span style="color:#66d9ef">OPTION&lt;/span>];
&lt;/code>&lt;/pre>&lt;/div>&lt;p>만약 &lt;code>user_name&lt;/code> 대신 &lt;code>PUBLIC&lt;/code>을 기술하면 모든 사용자에게 해당 시스템 권한 부여&lt;/p>
&lt;h4 id="revoke권한-회수">REVOKE(권한 회수)&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-SQL" data-lang="SQL">&lt;span style="color:#66d9ef">REVOKE&lt;/span> privilege_name &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> user_name &lt;span style="color:#f92672">|&lt;/span> role_name &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">PUBLIC&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>PUBLIC&lt;/code>을 사용하면 모든 사용자의 권한 제거&lt;/p>
&lt;h3 id="뷰-기반">뷰 기반&lt;/h3>
&lt;ul>
&lt;li>뷰는 하나 이상의 기본 테이블로부터 유도되어 만들어지는 &lt;code>가상 테이블&lt;/code>&lt;/li>
&lt;li>데이터의 &lt;code>논리적 독립성&lt;/code>을 보장하며 &lt;code>접근제어&lt;/code>를 통해 보안을 제공&lt;/li>
&lt;li>DB의 제한적 접근을 제공하여 사용자가 특정 행과 열에 대한 접근이 가능&lt;/li>
&lt;/ul>
&lt;h3 id="보안-취약점-점검">보안 취약점 점검&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>디폴트 계정 패스워드 변경&lt;/td>
&lt;td>DBMS가 적용된 디폴트 계정은 해커의 손쉬운 공격수단으로 악용되기에 반드시 비밀번호를 변경하거나 삭제해야함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DB 패스워드 규칙 강화&lt;/td>
&lt;td>디폴트 계정이나 일반 계정을 생성할 때 패스워드 규칙을 강화해 손쉽게 크래킹 되지 않도록 해야한다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DBA 권한의 제한&lt;/td>
&lt;td>일반 계정이 DBA 권한을 부여받지 않도록 주의&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보안 패치 적용&lt;/td>
&lt;td>제품별로 발표된 패치 적용해 취약점 제거&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용하지 않는 계정 삭제&lt;/td>
&lt;td>생성한 계정 중 불필요한 계정은 삭제하여 관리의 허점이 없도록 해야함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>개발자 IP 접근 제한&lt;/td>
&lt;td>필요에 의해 서버로 접근하는 개발자는 접근 IP 제한해 접근제어 강화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>제품별 취약점 제거&lt;/td>
&lt;td>이미 알려진 보안 취약점에 대해 피치나 제 2의 해결책으로 취약점 제거&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 암호화&lt;/td>
&lt;td>사용자 패스워드가 일방향 암호화되어 있는지 확인, 기밀 구분에 따라 암호화 적용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="암호화-방식">암호화 방식&lt;/h2>
&lt;h3 id="plug-in-방식">Plug-in 방식&lt;/h3>
&lt;p>암ㆍ복호화 모듈을 &lt;code>DB 서버&lt;/code> 내에 설치하여 암ㆍ복호화를 수행&lt;/p>
&lt;ul>
&lt;li>적용성은 뛰어나지만 CPU에 부하&lt;/li>
&lt;li>성능에 대한 민감성이 낮은 시스템의 경우 저렴한 비용으로 구축 가능&lt;/li>
&lt;/ul>
&lt;h3 id="api-방식">API 방식&lt;/h3>
&lt;p>암ㆍ복호화 모듈을 &lt;code>애플리케이션 서버&lt;/code> 내에 설치하여 암ㆍ복호화를 수행&lt;/p>
&lt;h3 id="hybrid-방식">Hybrid 방식&lt;/h3>
&lt;p>&lt;code>Plug-in 방식&lt;/code> + &lt;code>API 방식&lt;/code>&lt;/p>
&lt;ul>
&lt;li>성능이 우선시 되는 환경에서는 API를 적용&lt;/li>
&lt;li>성능 영향이 덜 민감한 환경에는 플러그인 방식을 적용&lt;/li>
&lt;/ul>
&lt;h3 id="tde-방식">TDE 방식&lt;/h3>
&lt;p>DB 내부에서 데이터 파일 저장 시 암호화, 파일에 저장된 내용을 메모리 영역으로 가져올 때 &lt;code>DBMS&lt;/code>에 의해 &lt;code>자동&lt;/code>으로 복호화&lt;/p>
&lt;ul>
&lt;li>&lt;code>DBMS 커널&lt;/code> 레벨에서 처리되므로 애플리케이션 수정이 없음&lt;/li>
&lt;li>DBMS 자체 &lt;code>인덱스&lt;/code> 기능과 연동 가능&lt;/li>
&lt;/ul>
&lt;h3 id="파일-암호화-방식">파일 암호화 방식&lt;/h3>
&lt;p>OS상에서 확인 가능한 개체인 파일을 암호화하는 방식&lt;/p>
&lt;ul>
&lt;li>OS대한 의존도 높음&lt;/li>
&lt;li>비정형 데이터에 대한 암호화 적용 가능&lt;/li>
&lt;/ul></description></item><item><title>Til: E-Commerce</title><link>http://Jeonghun-Ban.github.io/til/security/application/e-commerce/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/e-commerce/</guid><description>
&lt;ul>
&lt;li>광의적 개념
&lt;ul>
&lt;li>정부, 기업, 개인 간의 전자정보를 통하여 이루어지는 모든 경제활동을 포함한 상거래 전반&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>협의적 개념
&lt;ul>
&lt;li>일반 소비자를 대상으로 인터넷이나 통신망을 이용한 상품관련 정보 제공, 협상, 주문 등을 통해 마케팅, 판매활동을 수행하는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>협의적 개념
&lt;ul>
&lt;li>일반 소비자를 대상으로 인터넷이나 통신망을 이용한 마케팅, 판매활동을 수행하는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="정보보호">정보보호&lt;/h2>
&lt;h3 id="보안-공격-유형">보안 공격 유형&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>공격 유형&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>인증에 대한 공격&lt;/td>
&lt;td>N/W를 통해 접근한 사용자가 적절하지 못한 인증을 통해 다른 사용자로 위장하는 것&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>송ㆍ수신 부인 공격&lt;/td>
&lt;td>N/W를 통해 수행한 인증 및 거래 내역 부인&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>기밀성에 대한 공격&lt;/td>
&lt;td>N/W로 전달되는 인증정보 및 주요 거래 정보 유출&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>무결성에 대한 공격&lt;/td>
&lt;td>N/W 도중에 거래 정보등이 변조되는 것&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="보안-요구사항">보안 요구사항&lt;/h3>
&lt;ul>
&lt;li>전자상거래는 원격의 거래 상대를 신뢰하기 어려우므로 네트워크상에서 상대방 및 자신의 신분 확인 수단이 필요&lt;/li>
&lt;li>전자상거래에서 거래 사실의 공증을 보장할 수 있는 &lt;code>신뢰할만한 제 3자&lt;/code>의 중재가 필요&lt;/li>
&lt;li>전자상거래에서는 전자지불 방식의 안정성을 보장하기 위한 방법이 확보되어야 함&lt;/li>
&lt;/ul>
&lt;h2 id="전자화폐">전자화폐&lt;/h2>
&lt;p>가상공간의 화폐 역할을 수행하는 디지털 데이터로 구성된 화폐&lt;/p>
&lt;h3 id="구성-요소">구성 요소&lt;/h3>
&lt;ul>
&lt;li>은행: 전자화폐를 발행하고 결제하는 기관&lt;/li>
&lt;li>고객: 전자화폐를 은행으로부터 발급받아 사용하는 주체&lt;/li>
&lt;li>상점: 상품을 공급하고 전자화폐를 구매대금으로 받는 자&lt;/li>
&lt;li>인증기관: 신분인증, 거래내용 부인방지 등을 위한 기관&lt;/li>
&lt;/ul>
&lt;h3 id="거래-단계">거래 단계&lt;/h3>
&lt;ul>
&lt;li>구매자와 은행 간에 이루어지는 발행&lt;/li>
&lt;li>물건을 사고 상점에 화폐를 지불&lt;/li>
&lt;li>전자화폐를 은행에 제출하여 상점의 계좌로 자금을 이체(결제)&lt;/li>
&lt;/ul>
&lt;h3 id="요구-조건">요구 조건&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>요구 조건&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>디지털 정보화&lt;/td>
&lt;td>물리적인 형태에 의존하면 안되며 &lt;code>디지털 데이터 자체&lt;/code>로서 완벽한 화폐가치를 가져야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>재사용 불가능성&lt;/td>
&lt;td>복사, 위조 등으로 부정사용 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>익명성(추적 불가능성)&lt;/td>
&lt;td>이용자의 구매에 관한 익명성이 보호&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>오프라인성&lt;/td>
&lt;td>지불 단계를 오프라인으로 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>양도성&lt;/td>
&lt;td>타인에게 양도가 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분할이용 가능성&lt;/td>
&lt;td>분할해서 사용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>부정 사용자의 익명성 취소&lt;/td>
&lt;td>익명성 조절 파라미터에 따라 익명성 취소 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이중사용 방지&lt;/td>
&lt;td>불법적으로 복사하여 &lt;code>반복적 사용&lt;/code>하는 부정한 행위는 검출 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="보안-요구사항-1">보안 요구사항&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>보안 요구사항&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>위조불가능&lt;/td>
&lt;td>전자화폐는 위조가 불가능해야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>부인방지&lt;/td>
&lt;td>어느 한쪽이 거래사실을 부인하고 있음을 판별할 수 있어야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>누명면제&lt;/td>
&lt;td>전자지불 시스템을 구성하는 구성요소 간에 연합하여 특정 구성요소에게 누명을 씌울 수 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>무결성&lt;/td>
&lt;td>주고받는 메시지가 전송 도중 변경되지 않았음을 확인할 수 있어야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>인증&lt;/td>
&lt;td>송ㆍ수신자가 전자지불 시스템의 합법적인 사용자임을 확인할 수 있어야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>비밀성/익명성&lt;/td>
&lt;td>개인 신상 정보를 보호할 수 있어야 함&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="setsecure-electronic-transaction">SET(Secure Electronic Transaction)&lt;/h2>
&lt;p>신용카드회사인 비자(VISA)와 마스터카드(MasterCard)가 합동으로 개발&lt;/p>
&lt;ul>
&lt;li>&lt;code>신용카드 거래&lt;/code>를 네트워크 상에서 안전하게 하기 위한 표준 프로토콜&lt;/li>
&lt;li>안전한 대금결제과정 처리를 위해 &lt;code>RSA 암호화&lt;/code>와 &lt;code>인증기술&lt;/code>을 이용&lt;/li>
&lt;li>&lt;code>전자봉투&lt;/code>와 &lt;code>이중서명&lt;/code>을 통해 민감한 개인금융정보를 안전하게 전송&lt;/li>
&lt;/ul>
&lt;h3 id="참여주체">참여주체&lt;/h3>
&lt;ul>
&lt;li>카드소지자: 발행자에 의해서 허가된 &lt;code>지불카드를 사용&lt;/code>하는 주체&lt;/li>
&lt;li>발행자: 카드소지자의 계정을 만들고 카드를 발급해주는 금융기관
&lt;ul>
&lt;li>신뢰할만한 거래에 대해 지불을 보장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가맹점: 대금결제를 받는 대가로 &lt;code>상품과 서비스&lt;/code>를 제공&lt;/li>
&lt;li>지불은행: 상인과 계정을 체결하고 카드결제에 대한 &lt;code>신뢰성&lt;/code>과 &lt;code>지불&lt;/code>을 담당&lt;/li>
&lt;li>지불 게이트웨이: 지불처리 은행 또는 제3자에 의해 운영되는 시스템
&lt;ul>
&lt;li>상점이 요청한 카드소지자의 지급정보를 이용&lt;/li>
&lt;li>해당 금융기관에 승인 및 결제를 요청하는 기존의 카드 지불 N/W 통로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>인증기관: SET 참여자에게 &lt;code>공개키 인증서&lt;/code>를 발행하는 기관&lt;/li>
&lt;/ul>
&lt;h3 id="장단점">장단점&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>전자거래 사기 방지&lt;/td>
&lt;td>암호 프로토콜이 너무 복잡함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>기존의 신용카드 기반 그대로 활용&lt;/td>
&lt;td>RSA는 프로토콜의 속도를 크게 저하&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SSL의 단점(상인에게 지불정보 노출) 해결&lt;/td>
&lt;td>거래를 위한 별도의 H/W, S/W 필요&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="이중서명-프로토콜">이중서명 프로토콜&lt;/h3>
&lt;ul>
&lt;li>카드 사용자가 구매정보와 지불정보를 각각 해시&lt;/li>
&lt;li>&lt;code>두 해시값&lt;/code>을 합한 뒤 다시 해시&lt;/li>
&lt;li>이 값을 카드 소유자의 &lt;code>개인키로 암호화&lt;/code>하여 이중서명값을 생성&lt;/li>
&lt;/ul>
&lt;h4 id="기밀성">기밀성&lt;/h4>
&lt;ul>
&lt;li>지불정보는 &lt;code>은행의 공개키&lt;/code>로 암호화하여 &lt;code>상점으로의 기밀성&lt;/code>을 보장&lt;/li>
&lt;li>주문정보는 &lt;code>상점의 공개키&lt;/code>로 암호화하여 &lt;code>은행으로의 기밀성&lt;/code>을 보장&lt;/li>
&lt;/ul>
&lt;h2 id="ebxml">ebXML&lt;/h2>
&lt;p>&lt;code>인터넷 표준 브라우저&lt;/code>만으로 장소에 구애 없이 어디서나 전자상거래를 할 수 있으며 구현 비용이 저렴하고, 개방된 네트워크로 전자거래 교환을 위한 국제 표준을 제공&lt;/p>
&lt;h3 id="구성-요소-1">구성 요소&lt;/h3>
&lt;ul>
&lt;li>비즈니스 프로세스: 다양한 비즈니스 거래절차에 대한 내용을 표준화 정의&lt;/li>
&lt;li>핵심 컴포넌트: 비즈니스에 교환되는 전자문서의 재사용이 가능하도록 표준화 정의&lt;/li>
&lt;li>등록저장소: 거래상대자들에 의해 제출된 정보를 저장하는 안전한 저장소&lt;/li>
&lt;li>거래당사자: 비즈니스 거래 당사자에 대한 각종 정보 및 혐업을 위한 프로파일을 통일된 규칙으로 표준화&lt;/li>
&lt;li>전송, 교환 및 패키징: ebXML 메시지 서비스를 제공하여 상호운영성과 보안 유지, 메시지를 어떻게 전달할 것인가에 대한 표준 정립&lt;/li>
&lt;/ul>
&lt;h3 id="사용-효과">사용 효과&lt;/h3>
&lt;ul>
&lt;li>재활용성&lt;/li>
&lt;li>비즈니스 프로세스 활용&lt;/li>
&lt;/ul></description></item><item><title>Til: Digital Forensic</title><link>http://Jeonghun-Ban.github.io/til/security/application/digital-forensic/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/digital-forensic/</guid><description>
&lt;p>다양한 &lt;code>디지털 장치&lt;/code>에서 범인과 연관된 자료를 발견하고 &lt;code>분석&lt;/code>하여 법적인 문제를 해결하는 방법&lt;/p>
&lt;blockquote>
&lt;p>포렌식을 통해 증거획득하고 이 증거가 법적인 효력을 가지려면 그 증거를 발견, 기록, 획득, 보관하는 절차가 필요&lt;/p>
&lt;/blockquote>
&lt;h2 id="기본-원리">기본 원리&lt;/h2>
&lt;ul>
&lt;li>정당성의 원칙
&lt;ul>
&lt;li>모든 증거는 &lt;code>적법한 절차&lt;/code>를 거쳐서 획득한 것이어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>재현의 원칙
&lt;ul>
&lt;li>똑같은 환경에서 같은 결과가 나오도록 &lt;code>재현&lt;/code>할 수 있어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>신속성의 원칙
&lt;ul>
&lt;li>휘발성 정보를 취득하기 위해 신속하게 처리해야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>연계 보관성의 원칙
&lt;ul>
&lt;li>증거는 획득된 뒤 &lt;code>이송/분석/보관/법정 제출&lt;/code>이라는 일련의 과정이 &lt;code>명확&lt;/code>해야 함&lt;/li>
&lt;li>이러한 과정에 대한 &lt;code>추적&lt;/code>이 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>무결성의 원칙
&lt;ul>
&lt;li>수집된 정보는 &lt;code>연계 보관성 원칙&lt;/code>을 만족시켜야 하고, 위조/변조가 되면 안됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="수행-절차">수행 절차&lt;/h2>
&lt;h3 id="수사-준비">수사 준비&lt;/h3>
&lt;p>사이버 포렌식 전문가를 소집하고 각종 장비, S/W, H/W를 &lt;code>준비하고 점검&lt;/code>하는 단계&lt;/p>
&lt;h3 id="증거-수집">증거 수집&lt;/h3>
&lt;p>각종 &lt;code>저장매체&lt;/code>로부터 &lt;code>디지털 증거&lt;/code>를 획득하는 단계&lt;/p>
&lt;ul>
&lt;li>증거의 무결성이 중요&lt;/li>
&lt;li>디스크 이미징 = 저장매체에 저장된 데이터를 추출하는 과정
&lt;ul>
&lt;li>저장된 데이터와 동일한 사본을 만듦&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="보관-및-이송">보관 및 이송&lt;/h3>
&lt;p>획득된 증거는 &lt;code>연계 보관성&lt;/code>을 만족시키며 &lt;code>보관 및 이송&lt;/code>해야 함&lt;/p>
&lt;ul>
&lt;li>&lt;code>Evidence sage&lt;/code> = 증거의 연계 보안성을 위한 안전한 장소&lt;/li>
&lt;li>이송되거나 담당자/책임자가 바뀔 때는 문서에 그 증적을 남김&lt;/li>
&lt;/ul>
&lt;h3 id="조사-및-분석">조사 및 분석&lt;/h3>
&lt;p>증거를 관리할 때는 &lt;code>최량 증거 원칙(The Best Evidence Rule)&lt;/code>을 따름&lt;/p>
&lt;blockquote>
&lt;p>최량 증거 원칙: 복사본이나 2차 증거물이 아닌 &lt;code>원본&lt;/code>을 제출하도록 요구하는 영미 증거법상의 원칙&lt;/p>
&lt;/blockquote>
&lt;h4 id="디스크-브라우징">디스크 브라우징&lt;/h4>
&lt;p>수집한 저장매체 또는 디스크 이미지에 존재하는 파일을 &lt;code>GUI 환경&lt;/code>에서 쉽고 편리하게 다룰 수 있도록 가독성 있는 형태로 변환하여 출력하는 기술&lt;/p>
&lt;h4 id="데이터-뷰">데이터 뷰&lt;/h4>
&lt;p>저장 매체나 디스크 이미지에 저장된 방대한 파일을 열어서 확인할 수 없기 때문에 브라우징 과정에서 파일을 인식하여 텍스트, 그림 형식으로 볼 수 있도록 하는 &lt;code>자동 뷰&lt;/code> 기능을 제공하는 기술&lt;/p>
&lt;h4 id="파일-복구">파일 복구&lt;/h4>
&lt;p>복구 S/W를 이용하여 파일 &lt;code>원본을 복구&lt;/code>시키는 기술, 파일이 손상되어도 디스크 내에는 관련 정보가 보존되어 있기에 파일 복구가 가능하다.&lt;/p>
&lt;h3 id="보고서-작성">보고서 작성&lt;/h3>
&lt;p>포렌식의 모든 단계의 내용을 문서화하는 단계로 일련의 과정을 정확히 작성하여 &lt;code>증거자료로서 타당성&lt;/code>을 제공해야 한다.&lt;/p>
&lt;blockquote>
&lt;p>따라서 증거자료 획득, 보관 및 이송, 분석 등 모든 과정을 명확하고 객관성 있게 설명하고 불법행위를 입증할 수 있도록 논리적으로 작성해야 한다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="기술">기술&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>기술&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>디스크 포렌식&lt;/td>
&lt;td>물리적 저장장치인 보조 기억장치에서 증거를 수집하고 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>시스템 포렌식&lt;/td>
&lt;td>OS, 응용프로그램 및 프로세스를 분석하여 증거 확보&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>N/W 포렌식&lt;/td>
&lt;td>네트워크 전송되는 데이터, 암호를 가로채어 단서를 찾아내는 기술&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>인터넷 포렌식&lt;/td>
&lt;td>인터넷 응용 프로토콜을 사용하는 분야에서 증거를 수집하는 기술&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>모바일 포렌식&lt;/td>
&lt;td>휴대용 전자기기에서 필요한 정보를 입수하여 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DB 포렌식&lt;/td>
&lt;td>DB의 데이터를 추출 분석하여 증거를 수집하는 기술&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>암호 포렌식&lt;/td>
&lt;td>문서 또는 시스템에서 암호를 찾아 암호화 문서를 복호화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="포렌식-도구">포렌식 도구&lt;/h2>
&lt;ul>
&lt;li>EnCase: 전 세계에서 가장 대표적인 포렌식 도구
&lt;ul>
&lt;li>디지털 증거 수집, 검증, 검색, 보고, 완전삭제 등 다양한 기술 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FTK: 다용도 포렌식도구로 EnCase처럼 다양한 기능 제공&lt;/li>
&lt;/ul>
&lt;h2 id="증거">증거&lt;/h2>
&lt;h3 id="디지털-증거물-분석">디지털 증거물 분석&lt;/h3>
&lt;ul>
&lt;li>TimeLine 분석
&lt;ul>
&lt;li>파일 생성, 변경, 접근, 삭제 시간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시그니처 분석
&lt;ul>
&lt;li>의도적으로 파일 확장자를 변경한 파일을 간단히 파악&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Hash 분석
&lt;ul>
&lt;li>시스템 내 파일이 변경되었는지 확인&lt;/li>
&lt;li>파일의 해시값을 구한 후 기존 파일 해시값과 비교하여 기존 파일과 같은 파일이 존재하는지 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>로그 분석
&lt;ul>
&lt;li>웹 브라우저 로그, 메일로그, FTP 로그 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>프로세스 분석
&lt;ul>
&lt;li>현재 수행되고 있는 프로세스 메모리 내용 조시, 의심되는 실행파일 조사&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="휘발성-데이터">휘발성 데이터&lt;/h3>
&lt;ul>
&lt;li>시스템의 &lt;code>메모리&lt;/code>(RAM, 캐시 메모리, 비디오 카드 메모리 등)에 임시로 저장된 데이터&lt;/li>
&lt;li>휘발성이 큰 증거가 사라질 가능성이 크기 때문에, 휘발성이 큰 증거를 먼저 수집해야 한다.&lt;/li>
&lt;li>&lt;code>live response&lt;/code>: 실행 중인 시스템을 대상으로 행해지는 일련의 포렌식 조사 과정
&lt;ul>
&lt;li>전통적인 방법과 달리 컴퓨터 시스템의 플러그를 제거하지 않음&lt;/li>
&lt;li>휘발성 데이터의 유실을 막기 위함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="디지털-증거-보존">디지털 증거 보존&lt;/h3>
&lt;p>디지털 증거는 근본적으로 손상되기 쉽기에 &lt;code>완전한 비트스트림&lt;/code> 이미지를 즉시 만들어야 한다.&lt;/p>
&lt;blockquote>
&lt;p>비트스트림 이미지: 원본 저장 장치에 기록되었던 모든 데이터의 사본, CRC계산으로 원본과 비교&lt;/p>
&lt;/blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>디스크 복사&lt;/th>
&lt;th>디스크 이미징&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>저장방식&lt;/td>
&lt;td>Source read &amp;amp; Destination write&lt;/td>
&lt;td>Bit Stream Clone(Sector by Sector)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>저장대상&lt;/td>
&lt;td>파일과 디렉터리 단위 일부&lt;/td>
&lt;td>디스크의 모든 물리적 섹터&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정보 손실&lt;/td>
&lt;td>Source read 과정에서 읽지 못한 정보는 손실이 발생&lt;/td>
&lt;td>디스크 이미지는 디스크의 모든 정보를 포함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>파일 복구&lt;/td>
&lt;td>삭제된 파일은 복사과정에서 제외&lt;/td>
&lt;td>디스크 섹터에 삭제파일 정보가 남아있는 경우 복구 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Til: OWASP TOP10</title><link>http://Jeonghun-Ban.github.io/til/security/application/owasp-top10/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/application/owasp-top10/</guid><description>
&lt;p>&lt;code>OWASP(Open Web Application Security Project)&lt;/code>에서는 3~4년 주기로 10가지 보안이슈를 발표한다.&lt;/p>
&lt;h2 id="인젝션">인젝션&lt;/h2>
&lt;p>SQL, OS, XXE, LDAP 인젝션은 &lt;code>신뢰할 수 없는 데이터&lt;/code>가 명령어나 쿼리문의 일부분으로써, 인터프리터로 보내질 때 발생한다.&lt;/p>
&lt;ul>
&lt;li>공격자의 악의적인 데이터는 예기치 않은 명령을 실행&lt;/li>
&lt;li>올바른 권한 없이 데이터에 접근하도록 인터프리터를 속임&lt;/li>
&lt;/ul>
&lt;h3 id="sql-인젝션">SQL 인젝션&lt;/h3>
&lt;p>DB와 연동되어 있는 애플리케이션 &lt;code>입력값을 조작&lt;/code>하여 DBMS가 의도하지 않은 결과를 반환하도록 하는 기법&lt;/p>
&lt;blockquote>
&lt;p>필터링 기능이 없는 애플리케이션의 경우 사용자의 입력값의 적정성의 검사를 하지 않는다.&lt;/p>
&lt;/blockquote>
&lt;h4 id="공격-피해">공격 피해&lt;/h4>
&lt;ul>
&lt;li>DB 정보 조회/변조/삭제&lt;/li>
&lt;li>인증절차 우회&lt;/li>
&lt;li>시스템 명령어 실행&lt;/li>
&lt;li>주요시스템 파일정보 노출&lt;/li>
&lt;/ul>
&lt;h4 id="취약점-판단">취약점 판단&lt;/h4>
&lt;p>입력 폼에 &lt;code>큰따옴표&lt;/code>, &lt;code>작은따옴표&lt;/code>, &lt;code>세미콜론&lt;/code> 등을 입력하여 DB 에러를 출력하는지 확인&lt;/p>
&lt;h4 id="대응-방법">대응 방법&lt;/h4>
&lt;ul>
&lt;li>개발단계부터 모든 입력값에 대해 &lt;code>적절한 검증절차&lt;/code>를 설계 구현&lt;/li>
&lt;li>SQL 서버의 &lt;code>에러 메시지&lt;/code>를 표시 X&lt;/li>
&lt;li>일반 사용자 권한으로 &lt;code>시스템 저장 프로시저&lt;/code> 접근을 불허&lt;/li>
&lt;li>동적 SQL 완성방식 사용을 지양하고 &lt;code>저장 프로시저&lt;/code>를 사용&lt;/li>
&lt;li>&lt;code>선처리 질의문&lt;/code>을 이용&lt;/li>
&lt;/ul>
&lt;h2 id="인증-취약점">인증 취약점&lt;/h2>
&lt;p>인증 및 세션 관리와 관련된 애플리케이션 기능의 잘못된 구현으로 발생한다.&lt;/p>
&lt;ul>
&lt;li>공격자에게 &lt;code>암호&lt;/code>, &lt;code>키&lt;/code>, &lt;code>세션 토큰&lt;/code>을 위험에 노출시킴&lt;/li>
&lt;li>일시적/영구적으로 다른 사용자의 권한을 획득하여 결함을 악용하는 것을 허용&lt;/li>
&lt;/ul>
&lt;h3 id="웹-방화벽waf-web-application-firewall">웹 방화벽(WAF, Web Application Firewall)&lt;/h3>
&lt;p>웹 애플리케이션을 대상으로 시도되는 해킹을 차단하는 솔루션&lt;/p>
&lt;h4 id="기능">기능&lt;/h4>
&lt;ul>
&lt;li>사용자 요청 검사
&lt;ul>
&lt;li>접근제어, Web DoS, 업로드 파일 및 요청 형식 검사, SQL 인젝션 및 XSS 등의 차단&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>콘텐츠 보호
&lt;ul>
&lt;li>정보 유출 차단, 웹 변조 방지, 코드 노출 진단&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위장
&lt;ul>
&lt;li>URL 정보 위장, 서버 정보 위장&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="기존-방화벽과-차이">기존 방화벽과 차이&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>웹 방화벽&lt;/th>
&lt;th>기존 방화벽&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>목적&lt;/td>
&lt;td>유해 HTTP 차단&lt;/td>
&lt;td>유해 포트 차단&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동작레벨&lt;/td>
&lt;td>7계층&lt;/td>
&lt;td>3/4계층&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동작방식&lt;/td>
&lt;td>규칙 + 애플리케이션 로직&lt;/td>
&lt;td>일련의 규칙에 의해 동작&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="민감-데이터-노출">민감 데이터 노출&lt;/h2>
&lt;p>다수의 웹 애플리케이션과 API는 금융 정보, 건강 정보, 개인 식별 정보와 같은 중요한 정보를 제대로 보호하지 않는다.&lt;/p>
&lt;ul>
&lt;li>공격자는 신용카드 사기, 신분 도용 또는 다른 범죄를 수행하기 위해 보호가 취약한 데이터를 훔치거나 수정&lt;/li>
&lt;li>중요한 데이터는 저장 또는 전송할 때 암호화 같은 추가 보호 조치가 없으면 탈취 가능&lt;/li>
&lt;li>브라우저에서 주고 받을 때 각별한 주의가 필요&lt;/li>
&lt;/ul>
&lt;h2 id="xml-외부-객체xxe">XML 외부 객체(XXE)&lt;/h2>
&lt;p>&lt;code>XXE&lt;/code>는 악의적인 자바스크립트를 막기 위한 필터장치를 우회하는 취약점&lt;/p>
&lt;ul>
&lt;li>&lt;code>XML 문서&lt;/code>에서 동적으로 외부 URI의 리소스를 포함시킬 수 있는 &lt;code>외부 엔티티(Entity)&lt;/code>를 사용할 때 발생&lt;/li>
&lt;li>오래된 XML 프로세서들은 XML 문서 내에서 외부 개체 참조를 평가&lt;/li>
&lt;li>외부 개체는 파일 URI 처리기, 내부 파일 공유, 내부 포트 스캔, 원격 코드 실행과 DoS 공격을 사용하여 내부 파일을 공개하는데 사용 가능&lt;/li>
&lt;/ul>
&lt;h2 id="접근제어-취약점">접근제어 취약점&lt;/h2>
&lt;p>인증된 사용자가 수행할 수 있는 작업에 대한 제한이 제대로 적용되어 있지 않은 경우 발생하는 취약점&lt;/p>
&lt;ul>
&lt;li>공격자는 다른 사용자의 계정 접근, 중요 데이터에 접근/수정, 접근 권한 수정 등을 할 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="직접-객체-참조">직접 객체 참조&lt;/h3>
&lt;p>파일, 디렉터리, DB 키와 같이 내부적으로 구현된 객체에 대한 참조가 노출될 때 발생&lt;/p>
&lt;blockquote>
&lt;p>2013년도 이전에는 OWASP TOP10의 별도 항목이었다가 2017년도부터 접근통제 취약점으로 편입되었음.&lt;/p>
&lt;/blockquote>
&lt;h4 id="디렉터리-탐색-공격파일-다운로드-취약점">디렉터리 탐색 공격(파일 다운로드 취약점)&lt;/h4>
&lt;p>브라우저에서 확인 가능한 경로의 상위로 탐색하여 시스템 파일을 다운로드 하는 방법&lt;/p>
&lt;ul>
&lt;li>자료실에 올라간 파일을 다운로드할 때 전용 다운로드 프로그램이 파일을 가져옴&lt;/li>
&lt;li>이때 파일 이름을 필터링하지 않아서 발생하는 취약점&lt;/li>
&lt;li>&lt;code>..&lt;/code>과 &lt;code>/&lt;/code> 문자를 필터링 하도록 해야함&lt;/li>
&lt;/ul>
&lt;h4 id="파일-업로드-제한-부재">파일 업로드 제한 부재&lt;/h4>
&lt;p>클라이언트에서 서버 측으로 임의의 파일을 보낼 수 있는 취약점은 웹 서버가 가지는 가장 치명적인 취약점&lt;/p>
&lt;ul>
&lt;li>공격자는 웹 서버에 악의적인 파일을 전송&lt;/li>
&lt;li>원격지에서 해당 파일을 실행하여 웹 서버를 장악&lt;/li>
&lt;li>추가적인 내부 침투 공격을 수행 가능
– &lt;code>리버스 텔넷&lt;/code>과 같은 웹 서버의 통제권을 얻기 위해 반드시 성공해야 하는 공격&lt;/li>
&lt;/ul>
&lt;h4 id="리버스-텔넷">리버스 텔넷&lt;/h4>
&lt;p>웹 해킹을 통해 시스템 권한을 얻은 후 텔넷과 같이 명령 가능한 쉘을 띄우기 위한 공격&lt;/p>
&lt;ul>
&lt;li>방화벽이 존재하는 시스템을 공격시 주로 사용&lt;/li>
&lt;li>일반적인 웹 서버는 방화벽 내부에 존재하며 &lt;code>TCP/80&lt;/code>만을 허용
&lt;ul>
&lt;li>텔넷이 열려있어도 방화벽으로 인해 공격자가 외부에서 접근 불가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>아웃바운드 정책&lt;/code>을 설정하지 않은 경우 취약점을 노림
&lt;ul>
&lt;li>공격자는 서버가 자신에게 텔넷 연결을 요청하도록 유도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>아웃바운드 정책: 내부에서 방화벽 외부로 나가는 패킷에 대한 정책 (인바운드는 이와 반대)&lt;/p>
&lt;/blockquote>
&lt;h2 id="보안-설정-오류">보안 설정 오류&lt;/h2>
&lt;p>취약한 기본 설정 사용, 임시 설정, 개방된 클라우드 스토리지, 잘못 구성된 HTTP 헤더 메시지 등의 결과&lt;/p>
&lt;ul>
&lt;li>운영체제, 프레임워크, 라이브러리와 애플리케이션을 안전하게 설정&lt;/li>
&lt;li>S/W는 시기 적절하게 패치/ 업그레이드를 진행&lt;/li>
&lt;/ul>
&lt;h2 id="크로스사이트-스크립팅xss">크로스사이트 스크립팅(XSS)&lt;/h2>
&lt;p>애플리케이션이 신뢰할 수 없는 데이터를 적절한 검증 없이 웹 브라우저로 전송하는 경우 발생&lt;/p>
&lt;ul>
&lt;li>클라이언트의 브라우저에서 &lt;code>공격자의 스크립트&lt;/code> 실행&lt;/li>
&lt;li>사용자 세션을 탈취, 웹 사이트를 변조, 악성 사이트로 리다이렉션 등의 공격&lt;/li>
&lt;/ul>
&lt;h3 id="공격-과정">공격 과정&lt;/h3>
&lt;ol>
&lt;li>공격자는 게시판 등에다가 XSS를 심어 둠&lt;/li>
&lt;li>클라이언트는 공격자가 작성해 놓은 XSS에 접근&lt;/li>
&lt;li>게시판의 글을 통해 XSS코드가 클라이언트에게 전달됨&lt;/li>
&lt;li>클라이언트 브라우저에서 XSS 실행&lt;/li>
&lt;/ol>
&lt;h3 id="공격-유형">공격 유형&lt;/h3>
&lt;h4 id="stored-xss">Stored XSS&lt;/h4>
&lt;p>가장 일반적인 XSS 공격으로 게시판과 같은 곳에 공격자가 정상적인 평문이 아닌 &lt;code>스크립트 코드&lt;/code>를 입력하는 기법&lt;/p>
&lt;ul>
&lt;li>사용자가 게시판을 열람하는 순간 악성 스크립트가 실행됨&lt;/li>
&lt;li>사용자의 쿠키정보가 유출되거나 악성 스크립트가 기획한 공격에 당하게 됨&lt;/li>
&lt;/ul>
&lt;h4 id="reflected-xss">Reflected XSS&lt;/h4>
&lt;p>악성 스크립트 코드가 &lt;code>인자&lt;/code> 형태로 포함된 URL을 클릭 시 악성 스크립트 코드가 서버 사이트에 의해 HTML 문서로 반사되어 웹 브라우저에서 실행됨&lt;/p>
&lt;ul>
&lt;li>공격 스크립트 부분을 주로 인코딩하여 전달해 사용자가 눈치채지 못하게 함&lt;/li>
&lt;li>URL의 변수 부분처럼 스크립트 코드를 입력하는 동시에 결과가 바로 전해지는 기법&lt;/li>
&lt;li>서버 상에 악성 스크립트 코드를 남지 않는 장점(흔적X)&lt;/li>
&lt;/ul>
&lt;h4 id="dom-based-xss">DOM based XSS&lt;/h4>
&lt;p>피해자의 브라우저가 HTML 페이지 구분 분석할 때 마다 공격 스크립트가 &lt;code>DOM 생성&lt;/code>의 일부로 실행되며 공격&lt;/p>
&lt;ul>
&lt;li>페이지 자체는 변경되지 않음&lt;/li>
&lt;li>페이지에 포함되어 있는 브라우저측 코드가 DOM 환경에서 악성코드로 변경&lt;/li>
&lt;li>DOM 기반 XSS는 서버와 관계없이 브라우저에서 발생하는 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="보안-대책">보안 대책&lt;/h3>
&lt;ul>
&lt;li>&lt;code>&amp;lt;&lt;/code>, &lt;code>&amp;gt;&lt;/code>, &lt;code>&amp;amp;&lt;/code>, &lt;code>&amp;quot;&lt;/code>등 문자열은 &lt;code>&amp;amp;lt&lt;/code>, &lt;code>&amp;amp;gt&lt;/code>, &lt;code>&amp;amp;amp&lt;/code>, &lt;code>&amp;amp;quot&lt;/code>로 치환한다.&lt;/li>
&lt;li>사용자 입력값에 대한 검증은 서버단에서 반드시 해야함&lt;/li>
&lt;li>게시판에서 HTML 태그의 리스트를 선정, 해당 태그만 허용하는 방식 이용&lt;/li>
&lt;/ul>
&lt;h3 id="csrf와-비교">CSRF와 비교&lt;/h3>
&lt;p>사이트 간 요청 위조(CSRF)는 사용자의 의도와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 요청하게 하는 공격기법&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>비교&lt;/th>
&lt;th>XSS&lt;/th>
&lt;th>CSRF&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>공격 대상&lt;/td>
&lt;td>클라이언트&lt;/td>
&lt;td>서버&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>공격 시점&lt;/td>
&lt;td>악성 스크립트가 심어진 게시물 등을 열었을 때&lt;/td>
&lt;td>이메일 등을 통해 전달된 주소를 열었을 때&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>공격 방법&lt;/td>
&lt;td>클라이언트의 브라우저에서 실행&lt;/td>
&lt;td>정상적인 사용자가 서버에 요청(서버에서 실행)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이용 허점&lt;/td>
&lt;td>클라이언트가 웹사이트를 신뢰하는 상태&lt;/td>
&lt;td>특정 웹사이트가 사용자를 신뢰하는 상태&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="csrf-보안대책">CSRF 보안대책&lt;/h4>
&lt;ul>
&lt;li>폼 전송방식으로 &lt;code>GET&lt;/code> 대신 &lt;code>POST&lt;/code> 사용&lt;/li>
&lt;li>&lt;code>Referrer&lt;/code> 검증
&lt;ul>
&lt;li>요청된 도메인이 어디인지 확인&lt;/li>
&lt;li>이메일 등을 통해서 악의적인 스크립트가 담긴 주소를 열면 차단&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSRF 토큰
&lt;ul>
&lt;li>임의의 난수를 &lt;code>세션&lt;/code>에 저장하여 정상적인 사용자의 요청인지 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="안전하지-않은-역직렬화">안전하지 않은 역직렬화&lt;/h2>
&lt;p>원격 코드 실행으로 이어질 수 있으며, 권한 상승 공격, 인젝션 공격과 재생 공격을 포함한 다양한 공격 수행에 사용&lt;/p>
&lt;h2 id="알려진-취약점이-있는-컴포넌트-사용">알려진 취약점이 있는 컴포넌트 사용&lt;/h2>
&lt;ul>
&lt;li>라이브러리, 프레임워크 및 다른 소프트웨어 모듈 같은 구성요소는 애플리케이션과 같은 권한으로 실행됨&lt;/li>
&lt;li>만약에 취약한 구성요소가 악용된 경우 심각한 데이터 손실을 일으키거나 서버가 장악될 수 있음&lt;/li>
&lt;/ul>
&lt;h2 id="불충분한-로깅과-모니터링">불충분한 로깅과 모니터링&lt;/h2>
&lt;p>사고 대응의 비효율적인 통합 또는 누락이 공격자들로부터 시스템을 지속적으로 공격하거나 더 많은 시스템을 공격할 수 있게 하고, 데이터 변조/유출/삭제를 할 수 있게 한다&lt;/p></description></item></channel></rss>