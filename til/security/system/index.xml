<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jeonghun-Ban – System</title><link>http://Jeonghun-Ban.github.io/til/security/system/</link><description>Recent content in System on Jeonghun-Ban</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 16 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://Jeonghun-Ban.github.io/til/security/system/index.xml" rel="self" type="application/rss+xml"/><item><title>Til: Secure OS</title><link>http://Jeonghun-Ban.github.io/til/security/system/secure-os/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/system/secure-os/</guid><description>
&lt;p>기존 운영체제 내에 보안기능을 통합시킨 &lt;code>보안 커널&lt;/code>을 추가로 이식한 운영체제&lt;/p>
&lt;h2 id="주요-제공-기능">주요 제공 기능&lt;/h2>
&lt;p>메모리, 보조기억장치 데이터, 프로세스, 디렉터리, 하드웨어 장치 등을 보호한다.&lt;/p>
&lt;ul>
&lt;li>물리적 분리: 사용자 별로 별도의 장비 사용&lt;/li>
&lt;li>시간적 분리: 프로세스는 동일 시간에 하나만 실행&lt;/li>
&lt;li>논리적 분리: 각 프로세스에 논리적 구역 지정&lt;/li>
&lt;li>암호적 분리: 내부에서 사용되는 정보를 외부에서 알 수 없게 암호화&lt;/li>
&lt;/ul>
&lt;h2 id="보안-기능">보안 기능&lt;/h2>
&lt;ul>
&lt;li>파일 시스템 보호
&lt;ul>
&lt;li>파일 소유자가 보호장치를 만들어 둔 것&lt;/li>
&lt;li>파일의 공용문제와 병행하여 고려되어야 함&lt;/li>
&lt;li>보호방법
&lt;ul>
&lt;li>이름 명명&lt;/li>
&lt;li>패스워드&lt;/li>
&lt;li>암호화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 식별 및 인증
&lt;ul>
&lt;li>개별 사용자들의 &lt;code>안전한 식별&lt;/code>을 요구하며, 각각의 사용자들은 고유하게 식별될 수 있어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>임의적/강제적 통제(DAC, MAC)&lt;/li>
&lt;li>객체 재사용 보호
&lt;ul>
&lt;li>파일 삭제 시 OS에 남아있지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>완전한 조정
&lt;ul>
&lt;li>임의적/강제적 통제가 효과적이기 위해서는 &lt;code>모든 접근을 통제&lt;/code>해야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>신뢰 경로
&lt;ul>
&lt;li>패스워드 설정, 정책 설정 시 신뢰 경로를 통한 통신&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>감사 및 감사 기록 축소
&lt;ul>
&lt;li>모든 보안 관련 사건은 감사기록부에 기록되어야 하며 명백하게 보호되어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="보안-커널secure-kernel">보안 커널(Secure Kernel)&lt;/h2>
&lt;p>주체와 객체 사이 &lt;code>모든 접근과 기능 중재&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>참조 모니터&lt;/code> 개념을 구현한 것&lt;/li>
&lt;li>TCB 내에 있는 컴퓨터 시스템으로 구성됨&lt;/li>
&lt;/ul>
&lt;h3 id="참조모니터reference-monitor">참조모니터(Reference Monitor)&lt;/h3>
&lt;p>보안 커널의 가장 중요한 부분으로 자원에 대한 모든 액세스를 제어하는 &lt;code>추상 머신&lt;/code>&lt;/p>
&lt;ul>
&lt;li>격리성: 부정조작 방지&lt;/li>
&lt;li>완전성: 항상 무시되고 호출&lt;/li>
&lt;li>검증가능성: 모든 동작 분석/테스트로 확인 가능&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰-컴퓨팅-기반tcb-trusted-computing-base">신뢰 컴퓨팅 기반(TCB, Trusted Computing Base)&lt;/h3>
&lt;p>&lt;code>컴퓨터 시스템&lt;/code>(OS, H/W, F/W, S/W 등) 내의 &lt;code>모든 보호 메커니즘&lt;/code>의 총체&lt;/p>
&lt;h2 id="신뢰-플랫폼-모듈tpm-trusted-platform-module">신뢰 플랫폼 모듈(TPM, Trusted Platform Module)&lt;/h2>
&lt;p>신뢰 컴퓨팅을 위한 H/W, S/W 방법에서 핵심이 되는 하드웨어 모듈&lt;/p>
&lt;ul>
&lt;li>암호화된 키, 패스워드, 디지털 인증서 등의 &lt;code>안전한 저장 공간&lt;/code>을 제공하는 보안 모듈&lt;/li>
&lt;li>&lt;code>신뢰 컴퓨팅(TC, Trusted Computing)&lt;/code>의 가장 하위에 위치&lt;/li>
&lt;li>훼손 방지가 필수적이므로 &lt;code>하드웨어칩&lt;/code>으로 구현(SW적으로도 가능)&lt;/li>
&lt;li>물리적인 공격(도난)에도 정보 노출이 어려움&lt;/li>
&lt;/ul>
&lt;h3 id="신뢰-관련-연산">신뢰 관련 연산&lt;/h3>
&lt;ul>
&lt;li>암호화 키의 생성과 저장&lt;/li>
&lt;li>패스워드 저장&lt;/li>
&lt;li>무결성 검증&lt;/li>
&lt;li>디지털 인증서 관련 신뢰 연산&lt;/li>
&lt;/ul>
&lt;h3 id="기본-서비스">기본 서비스&lt;/h3>
&lt;ul>
&lt;li>인증된 부트 서비스: 운영체제가 적재될 때 각 부분이 사용을 위해 승인된 버전임을 인증&lt;/li>
&lt;li>인증 서비스: 다양한 인증에 사용(개인키를 이용한 디지털 인증 등)&lt;/li>
&lt;li>암호화 서비스: 특정 설정 상태에서만 복호화가 가능하게 하는 암호화 지원&lt;/li>
&lt;/ul></description></item><item><title>Til: Client</title><link>http://Jeonghun-Ban.github.io/til/security/system/client/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/system/client/</guid><description>
&lt;h2 id="악성-소프트웨어">악성 소프트웨어&lt;/h2>
&lt;p>의도적으로 컴퓨터 보안 속성을 침해할 목적으로 작성된 프로그램&lt;/p>
&lt;h3 id="분류">분류&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;h3 id="바이러스virus">바이러스(Virus)&lt;/h3>
&lt;p>자기 자신 또는 자신의 변형을 복사하여 컴퓨터 작동에 피해를 주는 명령어의 집합&lt;/p>
&lt;h4 id="세대별-분류">세대별 분류&lt;/h4>
&lt;ul>
&lt;li>원시형
&lt;ul>
&lt;li>코드의 변형이나 변화 없이 고정된 크기&lt;/li>
&lt;li>기억장소에 상주하며 부트 영역이나 파일 감염&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>암호화
&lt;ul>
&lt;li>백신 프로그램이 진단할 수 없도록 일부 암호화&lt;/li>
&lt;li>실행 시작점 부분에 위치하는 암호해독 데이터는 항상 일정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>은폐형
&lt;ul>
&lt;li>기억소에 위치하면서 감염된 파일의 길이 변동 유무를 숨김&lt;/li>
&lt;li>바이러스 검출하려 할 때, 감염 이전의 모습을 보여 속임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>갑옷형
&lt;ul>
&lt;li>&lt;code>여러 단계의 암호화&lt;/code>와 다양한 기법 동원&lt;/li>
&lt;li>바이러스 분석을 어렵게 하고 백신 개발 지연&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>매크로
&lt;ul>
&lt;li>&lt;code>데이터 파일&lt;/code>(워드, 엑셀 등)이 열릴 때 바이러스 실행&lt;/li>
&lt;li>플랫폼과 무관하고 쉽게 전염&lt;/li>
&lt;li>문서를 감염시키고 코드의 실행부분은 감염시키지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="대응-방안">대응 방안&lt;/h4>
&lt;ul>
&lt;li>안티 바이러스 필터링
&lt;ul>
&lt;li>signature scanning
&lt;ul>
&lt;li>특정 바이러스만이 가진 유일한 형태의 &lt;code>signature&lt;/code>를 탐색&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>behavioral virus scanning
&lt;ul>
&lt;li>바이러스가 수행 중에 어떤 &lt;code>행동&lt;/code>을 보이는지 추적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>바이러스 예방책
&lt;ul>
&lt;li>신뢰있는 업체에서 구입한 상업용 S/W를 사용&lt;/li>
&lt;li>Windows Script Host, Active X, VBScript, JavaScript는 비활성화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="웜worm">웜(Worm)&lt;/h3>
&lt;p>자기 자신을 복제하여 &lt;code>네트워크&lt;/code>를 통해 스스로 확산&lt;/p>
&lt;ul>
&lt;li>숙주 파일 X (독립성)&lt;/li>
&lt;li>다른 시스템에 직접적인 영향 X()&lt;/li>
&lt;li>메일, 파일 공유, 원격실행, 로그인, 파일전송, 모바일코드로 확산&lt;/li>
&lt;/ul>
&lt;h4 id="종류">종류&lt;/h4>
&lt;ul>
&lt;li>MASS Mailer형 웜
&lt;ul>
&lt;li>&lt;code>대량 메일 발송&lt;/code>을 통해 확산되는 웜&lt;/li>
&lt;li>감염된 시스템이 많으면 SMTP 서버의 네트워크 트래픽 증가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>시스템 공격형 웜
&lt;ul>
&lt;li>&lt;code>OS 고유 취약점&lt;/code>을 이용해 내부 정보를 파괴&lt;/li>
&lt;li>컴퓨터를 사용할 수 없는 상태로 만듬&lt;/li>
&lt;li>백도어 설치&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>네트워크 공격형 웜
&lt;ul>
&lt;li>특정 네트워크나 시스템에 대해 &lt;code>서비스 거부(DoS) 공격&lt;/code>을 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="대응-방안-1">대응 방안&lt;/h4>
&lt;p>안티 바이러스를 통해서 제거하거나 네트워크 활동과 사용을 모니터링&lt;/p>
&lt;ul>
&lt;li>웜 모니터링 소프트웨어를 통한 방어&lt;/li>
&lt;li>엔터프라이즈 네트워크와 인터넷 사이 경계에 위치&lt;/li>
&lt;/ul>
&lt;h3 id="트로이목마trojan-horse">트로이목마(Trojan horse)&lt;/h3>
&lt;p>자신의 실체를 드러내지 않으면서 마치 &lt;code>다른 프로그램의 한 유형&lt;/code>인 것처럼 가장하여 활동하는 프로그램&lt;/p>
&lt;ul>
&lt;li>자기복제 X, 다른 파일 감염 X&lt;/li>
&lt;li>원격 조정, 키로거(Keylogger), 사용자 정보 유출, 시스템 파괴, DoS 공격에 이용&lt;/li>
&lt;/ul>
&lt;h3 id="스파이웨어spyware">스파이웨어(Spyware)&lt;/h3>
&lt;p>설치된 &lt;code>시스템의 정보&lt;/code>를 주기적으로 원격지의 특정한 &lt;code>서버에 보냄&lt;/code>&lt;/p>
&lt;ul>
&lt;li>광고나 마케팅을 목적으로 배포하면 &lt;code>애드웨어(Adware)&lt;/code>&lt;/li>
&lt;li>수집한 데이터는 신원 도용, 스팸, 사기 등에 이용될 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="그-외">그 외&lt;/h3>
&lt;ul>
&lt;li>백도어: 정상적인 인증을 수행하지 않고 시스템에 접근&lt;/li>
&lt;li>Exploit: 정상적인 파일 혹은 웹사이트의 극히 일부 소스코드만을 변경&lt;/li>
&lt;li>Kit: 바이러스를 자동으로 생성하는 도구 모음&lt;/li>
&lt;li>루트킷(Rootkit): 컴퓨터 시스템에 침입 후 root 권한을 얻기 위해 사용하는 해킹 도구 모음&lt;/li>
&lt;li>Attack Kit: 다양한 번식 방법과 payload 기술을 사용하는 새로운 악성코드를 자동으로 만들어주는 툴&lt;/li>
&lt;li>프리더: 서비스 거부 공격(DOS)에 사용하는 코드&lt;/li>
&lt;/ul>
&lt;h2 id="웹브라우저-보안">웹브라우저 보안&lt;/h2>
&lt;h3 id="쿠키-보안-취약점">쿠키 보안 취약점&lt;/h3>
&lt;ul>
&lt;li>XSS(Cross-Site Scripting): 자바스크립트가 사용자의 컴퓨터에서 실행된다는 점을 이용한 공격&lt;/li>
&lt;li>스니핑(Sniffing): 네트워크를 통해 전송되는 암호화되지 않은 쿠키를 탈취&lt;/li>
&lt;/ul>
&lt;h3 id="세션-하이재킹">세션 하이재킹&lt;/h3>
&lt;p>클라이언트-서버 간의 연결이 유지되는 상태를 가로채는 것을 말한다.&lt;/p>
&lt;blockquote>
&lt;p>세션: 클라이언트 정보를 서버에 저장하는 기술로, 클라이언트 별로 세션ID를 부여되며 클라이언트는 세션쿠키를 통해 서버에 인증하고 세션(연결상태)을 유지한다.&lt;/p>
&lt;/blockquote></description></item><item><title>Til: Server</title><link>http://Jeonghun-Ban.github.io/til/security/system/server/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/system/server/</guid><description/></item><item><title>Til: System Threats</title><link>http://Jeonghun-Ban.github.io/til/security/system/system-threats/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/security/system/system-threats/</guid><description>
&lt;h2 id="버퍼-오버플로우-공격">버퍼 오버플로우 공격&lt;/h2>
&lt;p>버퍼 또는 데이터 저장 공간보다 더 많은 입력이 위치하면 다른 위치의 정보를 변경할 수 있음을 이용한 공격&lt;/p>
&lt;h3 id="스택-버퍼-오버플로우">스택 버퍼 오버플로우&lt;/h3>
&lt;p>스택에 정해진 버퍼보다 큰 공격 코드를 삽입해 반환주소를 변경함&lt;/p>
&lt;ul>
&lt;li>공격 대상
&lt;ul>
&lt;li>SetUID가 설정된 루트 권한의 프로그램&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>공격 절차
&lt;ul>
&lt;li>공격 쉘 코드를 버퍼에 저장&lt;/li>
&lt;li>특정 함수의 스택 반환주소를 공격 쉘 코드가 위치한 버퍼 주소로 변경&lt;/li>
&lt;li>해당 함수가 호출되면 쉘 코드가 실행되고 루트 권한을 획득할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="힙-버퍼-오버플로우">힙 버퍼 오버플로우&lt;/h3>
&lt;p>힙에 할당된 공간이 함수에 대한 포인터를 포함하고 있는 경우, 공격자가 이 주소를 변경하여 겹쳐 쓴 버퍼에 있는 셸 코드를 가리키도록 할 수 있다.&lt;/p>
&lt;h3 id="대응-방법">대응 방법&lt;/h3>
&lt;h4 id="컴파일-시간-방어">컴파일 시간 방어&lt;/h4>
&lt;p>컴파일할 때 검사하여 오버 플로우를 방지하거나 발견하는 방어 방법&lt;/p>
&lt;ul>
&lt;li>고급 수준의 프로그래밍 언어 사용
&lt;ul>
&lt;li>Java, ADA, Python 같은 버퍼 오버플로우가 발생하지 않는 언어&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안전한 함수 사용
&lt;ul>
&lt;li>입력 값을 검사하는 함수를 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안전한 라이브러리의 사용&lt;/li>
&lt;li>스택 보호 메커니즘(Stack Guard)
&lt;ul>
&lt;li>함수의 진입과 종료 코드를 조사하여 함수의 스택 프레임에 대해 손상이 있는지 검사&lt;/li>
&lt;li>프로그램 호출 시 복귀 주소(RET) 앞에 &lt;code>canary&lt;/code>값 주입 후 종료 시 변경되었는지 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>스택 쉴드(Stack Shield)
&lt;ul>
&lt;li>함수 시작 시 복귀 주소(RET)를 &lt;code>Global RET&lt;/code>라는 특수 스택에 저장&lt;/li>
&lt;li>함수 종료 시 저장된 값과 스택의 RET 값을 비교해 탐지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="실행-시간-방어">실행 시간 방어&lt;/h4>
&lt;p>재컴파일 없이 기존 프로그램에 대해 방어할 수 있는 방법&lt;/p>
&lt;ul>
&lt;li>주소 공간의 임의 추출(ASLR, Address Space Layout Randomization)
&lt;ul>
&lt;li>스택을 임의적으로 배치하여 공격자가 실행 코드의 주소를 예측할 수 없게 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실행가능 주소 공간의 보호(Non-Executable Stack)
&lt;ul>
&lt;li>스택과 힙 영역을 실행 불능으로 만드는 방법&lt;/li>
&lt;li>&lt;code>/etc/system&lt;/code>파일 설정
&lt;ul>
&lt;li>&lt;code>set noexec_user_stack=1&lt;/code>&lt;/li>
&lt;li>&lt;code>set noexec_user_stack_log=1&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="포맷-스트링-공격">포맷 스트링 공격&lt;/h2>
&lt;p>포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격&lt;/p>
&lt;h3 id="위협-요소">위협 요소&lt;/h3>
&lt;ul>
&lt;li>프로그램의 파괴
&lt;ul>
&lt;li>프로세스를 죽게 만들어 다른 공격을 수월하게 만듬&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>프로세스 메모리 보기
&lt;ul>
&lt;li>시스템 내의 유용한 정보를 수집&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>임의의 메모리 덮어쓰기
&lt;ul>
&lt;li>어떤 프로세스의 명령 통제권을 장악할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="대응-방법-1">대응 방법&lt;/h3>
&lt;ul>
&lt;li>데이터 형식에 대한 명확한 정의&lt;/li>
&lt;li>취약점 점검 도구 사용
&lt;ul>
&lt;li>gdb, ltrace, objdump&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="레이스-컨디션-공격">레이스 컨디션 공격&lt;/h2>
&lt;p>둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때 접근하는 순서에 따라 비정상적인 결과가 발생하는 조건/상황&lt;/p>
&lt;blockquote>
&lt;p>실행되는 프로세스가 임시파일을 만드는 경우, 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 목적파일로 연결(심볼릭 링크)하여 악의적인 행위를 할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>레이스 컨디션 공격의 대상
&lt;ul>
&lt;li>소유자가 root, SetUID 비트 설정, 임시파일을 생성하는 파일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>생성되는 임시 파일의 이름을 알고 있어야 함
&lt;ul>
&lt;li>lsof 명령어로 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="대응-방법-2">대응 방법&lt;/h3>
&lt;ul>
&lt;li>임시파일에 접근하기 전에 임시파일에 대한 심볼릭 링크 설정 여부와 권한에 대한 검사 과정 추가&lt;/li>
&lt;li>가능하면 임시파일을 생성하지 않는다.&lt;/li>
&lt;li>&lt;code>umask&lt;/code>를 최소 &lt;code>022&lt;/code> 정도로 유지(755퍼미션)&lt;/li>
&lt;/ul>
&lt;h2 id="백도어">백도어&lt;/h2>
&lt;p>OS나 프로그램 등에 접근할 때 정상적인 인증 과정을 거치지 않도록 하는 통로&lt;/p>
&lt;ul>
&lt;li>서비스 기술자나 유지보수 프로그래머의 접근 편의를 위해서 시스템 설계자가 고의적으로 만듬&lt;/li>
&lt;li>백 오리피스(back orifice) = 악의적인 백도어
&lt;ul>
&lt;li>사용자 몰래 사용자 정보를 저장, 유출하기 위한 백도어 프로그램&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="대응-방법-3">대응 방법&lt;/h3>
&lt;ul>
&lt;li>프로세스 목록 확인&lt;/li>
&lt;li>&lt;code>H-IDS&lt;/code> 사용하여 탐지&lt;/li>
&lt;/ul>
&lt;h2 id="시스템-자원-고갈-공격">시스템 자원 고갈 공격&lt;/h2>
&lt;p>시스템이 보유하고 있는 자원을 모두 선점하거나 모두 고갈하는 방식으로 수행된다.&lt;/p>
&lt;blockquote>
&lt;p>서비스 거부 공격(DOS)라고도 부름&lt;/p>
&lt;/blockquote>
&lt;h3 id="가용-디스크-자원-고갈-공격">가용 디스크 자원 고갈 공격&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;sys/file.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;span style="color:#66d9ef">int&lt;/span> fd;
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">1000&lt;/span>];
fd &lt;span style="color:#f92672">=&lt;/span> creat(&lt;span style="color:#e6db74">&amp;#34;/root/termifile&amp;#34;&lt;/span> ,&lt;span style="color:#ae81ff">0777&lt;/span>);
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>){
write(fd,buf,&lt;span style="color:#66d9ef">sizeof&lt;/span>(buf); &lt;span style="color:#75715e">// tempfile 계속 써서 → 디스크 용량 고갈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="가용-메모리-자원-고갈-공격">가용 메모리 자원 고갈 공격&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>m; &lt;span style="color:#75715e">// 포인터 변수
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>){
m &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">1000&lt;/span>); &lt;span style="color:#75715e">// 동적 할당 → 힙 메모리 고갈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="가용-프로세스-자원-고갈-공격">가용 프로세스 자원 고갈 공격&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>){
fork(); &lt;span style="color:#75715e">// 프로세스 반복 복제 → 가용 프로세스 고갈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="프로세스-죽이기-공격">프로세스 죽이기 공격&lt;/h3>
&lt;p>root 권한을 획득한 상태에서 스크립트를 통해 프로세스를 죽이는 기법&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#75715e">#!/bin/sh
&lt;/span>&lt;span style="color:#75715e">&lt;/span>sync
kill &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="리버스-엔지니어링-공격">리버스 엔지니어링 공격&lt;/h2>
&lt;p>리버스 엔지니어링 과정에서 발견한 취약점으로 공격 코드를 생성&lt;/p>
&lt;blockquote>
&lt;p>리버스 엔지니어링(역공학): 장치나 시스템의 구조를 분석하여 원리를 발견하는 과정&lt;/p>
&lt;/blockquote>
&lt;h3 id="대응-방법-4">대응 방법&lt;/h3>
&lt;ul>
&lt;li>소스코드 난독화&lt;/li>
&lt;li>바이너리 난독화&lt;/li>
&lt;/ul>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;h3 id="루트킷rootkit">루트킷(Rootkit)&lt;/h3>
&lt;p>공격자가 언제든지 시스템 root 권한으로 접근할 수 있도록 비밀통로를 지속적으로 유지시켜주는 프로그램&lt;/p>
&lt;ul>
&lt;li>시스템 변형을 통해서 자신을 숨기므로 탐지하기 어려움&lt;/li>
&lt;/ul>
&lt;h3 id="gnu-bash-취약점shellshock">GNU Bash 취약점(ShellShock)&lt;/h3>
&lt;p>취약한 버전의 bash는 환경변수의 함수 선언문 뒤에 임의의 명령어를 삽입할 경우, 환경변수에 설정된 함수 선언의 끝을 인지하지 못하고 삽입한 명령어까지 실행하는 취약점&lt;/p>
&lt;h3 id="논리폭탄logic-bomb">논리폭탄(logic bomb)&lt;/h3>
&lt;p>특정한 사건이 발생할 때 프로그램이나 일련의 코드를 실행하는 것&lt;/p></description></item></channel></rss>