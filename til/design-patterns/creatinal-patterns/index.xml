<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jeonghun-Ban – 생성 패턴</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/</link><description>Recent content in 생성 패턴 on Jeonghun-Ban</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 16 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Til: 추상 팩토리</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/abstract-factory/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/abstract-factory/</guid><description>
&lt;p>상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공&lt;/p>
&lt;blockquote>
&lt;p>키트(Kit)라는 이름으로도 불린다.&lt;/p>
&lt;/blockquote>
&lt;h2 id="동기">동기&lt;/h2>
&lt;p>윈도우와 맥 OS의 사용자 인터페이스는 서로 &lt;code>다른 룩앤 필&lt;/code>을 가지고 있다. 이로 인해 동일한 위젯(스크롤바, 버튼)라 할지라도 모양이 다르고 동작방식도 다르다. 개발한 응용프로그램이 서로 &lt;code>다른 운영체제&lt;/code>에서의 이식성을 지니기 위해서는, 운영체제에서 제공하는 위젯을 직접 사용해서는 안된다.&lt;/p>
&lt;p>해당 문제는 추상 클래스인 &lt;code>AbstractFactory&lt;/code>를 정의하는 것으로 해결한다. AbstractFactory에 &lt;code>기본 유저 인터페이스 요소&lt;/code>(윈도우,스크롤바,버튼 등)를 생성할 수 있는 인터페이스를 정의한다. 그리고 실제적으로 생성되는 객체에 대해서는 &lt;code>AbstractProduct&lt;/code> 인터페이스를 정의하고 이를 상속하는 서브클래스를 정의하여 서로 다른 운영체제에 이식성을 제공한다.&lt;/p>
&lt;h2 id="구조">구조&lt;/h2>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/abfac108.gif" alt="abstract_factory">&lt;/p>
&lt;h2 id="참여자">참여자&lt;/h2>
&lt;ul>
&lt;li>&lt;code>AbstractFactory&lt;/code>: 개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의&lt;/li>
&lt;li>&lt;code>ConcreteFactory&lt;/code>: 구체적인 제품에 대한 객체를 생성하는 연산을 구현&lt;/li>
&lt;li>&lt;code>AbstractProduct&lt;/code>: 개념적 제품 객체에 대한 인터페이스를 정의&lt;/li>
&lt;li>&lt;code>ConcreteProduct&lt;/code>: 구체적으로 팩토리가 생성할 객체를 정의하고 &lt;code>AbstractProduct&lt;/code>에서 정의한 인터페이스를 구현&lt;/li>
&lt;li>&lt;code>Client&lt;/code>: &lt;code>AbstractFactory&lt;/code>와 &lt;code>AbstractProduct&lt;/code> 클래스에 선언된 인터페이스를 사용&lt;/li>
&lt;/ul>
&lt;h2 id="협력방법">협력방법&lt;/h2>
&lt;ul>
&lt;li>일반적으로 &lt;code>ConcreteFactory&lt;/code> 클래스의 인스턴스 한 개가 런타임에 생성된다.&lt;/li>
&lt;li>이것은 특정 구현을 갖는 제품 객체를 생성한다.&lt;/li>
&lt;li>&lt;code>AbstractFactory&lt;/code>는 필요한 제품 객체를 생성하는 책임을 ConcreteFactory 서브클래스에게 &lt;code>위임&lt;/code>합니다&lt;/li>
&lt;/ul>
&lt;h2 id="결과">결과&lt;/h2>
&lt;ul>
&lt;li>구체적인 클래스 분리&lt;/li>
&lt;li>제품군을 쉽게 대체할 수 있게 함&lt;/li>
&lt;li>제품 사이에 일관성 증진&lt;/li>
&lt;li>새로운 종류의 제품을 제공하기 어려움&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>해당 패턴을 사용했을 시 장단점&lt;/p>
&lt;/blockquote>
&lt;h2 id="적용된-사례">적용된 사례&lt;/h2>
&lt;p>자바 GUI 라이브러리인 &lt;code>Swing(AWT)&lt;/code>의 &lt;code>룩 앤드 필&lt;/code> 변경 기능이 대표적인 예시이다. 해당 기능으로 인해 Swing GUI로 짜인 자바 프로그램은 OS에 따라 적합한 인터페이스를 별도로 제공한다. 동일한 위젯이더라도 윈도우와 맥 OS에서 실행했을 시에 보이는 모양이 다르다.&lt;/p>
&lt;h2 id="관련-패턴">관련 패턴&lt;/h2>
&lt;p>&lt;code>AbstractFactory&lt;/code> 클래스는 &lt;code>팩토리 메서드&lt;/code> 패턴을 이용해서 구현되는데, Prototype 패턴을 이용할 때도 있다. 구체 팩토리는 &lt;code>Singleton&lt;/code> 패턴을 이용해 구현하는 경우가 많다.&lt;/p>
&lt;h2 id="참고문헌">참고문헌&lt;/h2>
&lt;ul>
&lt;li>Gof의 디자인 패턴 번역본&lt;/li>
&lt;li>&lt;a href="https://www.cs.unc.edu/~stotts/GOF/hires/pat3afso.htm">Department of Computer Science University of North Carolina&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4">위키피디아 추상 팩토리 패턴&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Til: 빌더</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/builder/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/builder/</guid><description>
&lt;p>복합 객체의 생성 과정과 표현방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴&lt;/p>
&lt;h2 id="활용성">활용성&lt;/h2>
&lt;ul>
&lt;li>복합 객체의 생성 알고리즘이 객체를 합성하는 요소들과 이들의 조립 방법에 독립적일 때&lt;/li>
&lt;li>합성할 객체들의 표현이 서로 다르더라도 생성 객체에서 이를 지원해야 할때&lt;/li>
&lt;/ul>
&lt;h2 id="구조">구조&lt;/h2>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/builder.gif" alt="builder">&lt;/p>
&lt;h2 id="참여자">참여자&lt;/h2>
&lt;ul>
&lt;li>&lt;code>Builder&lt;/code>: &lt;code>Product&lt;/code> 객체의 일부 요소들을 생성하기 위한 추상 인터페이스&lt;/li>
&lt;li>&lt;code>ConcreteBuilder&lt;/code>: &lt;code>Builder&lt;/code> 클래스에서 정의한 인터페이스를 구현하고, 제품의 부품들을 모아 빌더를 복합함&lt;/li>
&lt;li>&lt;code>Director&lt;/code>: Builder 인터페이스를 사용하는 객체를 합성&lt;/li>
&lt;li>&lt;code>Product&lt;/code>: 생성할 복합 객체&lt;/li>
&lt;/ul>
&lt;h2 id="협력-방법">협력 방법&lt;/h2>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/build095.gif" alt="build">&lt;/p>
&lt;ul>
&lt;li>사용자는 &lt;code>Director&lt;/code> 객체를 생성하고, 이렇게 생성된 객체를 자신이 원하는 &lt;code>Builder&lt;/code> 객체로 합성&lt;/li>
&lt;li>제품의 일부가 구축될 때마다 Director는 Builder에게 통보&lt;/li>
&lt;li>Builder는 Director의 요청을 처리하여 제품에 부품을 추가&lt;/li>
&lt;li>사용자는 Builder에서 제품을 검색&lt;/li>
&lt;/ul>
&lt;h2 id="결과">결과&lt;/h2>
&lt;ul>
&lt;li>제품에 대한 내부 표현을 다양하게 변화&lt;/li>
&lt;li>생성과 표현에 필요한 코드를 분리&lt;/li>
&lt;li>복합 객체를 생성하는 절차를 보다 세밀화&lt;/li>
&lt;/ul>
&lt;h2 id="관련-패턴">관련 패턴&lt;/h2>
&lt;p>복잡한 객체를 생성해야 할 때 추상 팩토리 패턴은 빌더 패턴과 비슷하다. &lt;code>빌더 패턴&lt;/code>은 복잡한 객체의 &lt;code>단계별 생성&lt;/code>에 중점을 둔다면, &lt;code>추상 팩토리 패턴&lt;/code>은 &lt;code>유사군&lt;/code>들에 대한 유연한 설계가 중점이다. 빌더 패턴은 생성의 마지막 단계에서 생성한 제품을 반환하는 반면, 추상 팩토리 패턴에서는 만드는 즉시 제품을 반환한다는 차이도 있다.&lt;/p>
&lt;h2 id="참고-문헌">참고 문헌&lt;/h2>
&lt;ul>
&lt;li>Gof의 디자인 패턴 번역본&lt;/li>
&lt;li>&lt;a href="https://www.cs.unc.edu/~stotts/GOF/hires/pat3bfso.htm">Department of Computer Science University of North Carolina&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>