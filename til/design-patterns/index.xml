<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jeonghun-Ban – Design Patterns</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/</link><description>Recent content in Design Patterns on Jeonghun-Ban</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 16 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://Jeonghun-Ban.github.io/til/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Til: 서론</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/introduction/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/design-patterns/introduction/</guid><description>
&lt;h2 id="디자인-패턴이란">디자인 패턴이란?&lt;/h2>
&lt;p>&lt;code>객체지향프로그래밍(OOP)&lt;/code>을 하는 데 있어서 &lt;code>재사용성&lt;/code>을 높이는 것은 중요하지만 어려운 과제이다. 이를 위해서는 적절한 객체와 클래스, 인터페이스를 정의하고 관계를 설정해야만 하는데, 여기서 디자인 패턴의 필요성이 드러난다.&lt;/p>
&lt;p>전문가들은 다양한 문제들을 접하며 찾은 해결책들이 집약된 것이 바로 현재 객체지향설계에 사용되는 &lt;code>디자인 패턴&lt;/code>이다. 따라서 이러한 패턴을 익히는 것은 이미 여러 차례에 걸쳐 검증된 방식을 효율적으로 사용하기 위해 꼭 필요한 과정이다.&lt;/p>
&lt;h2 id="디자인-패턴-요소">디자인 패턴 요소&lt;/h2>
&lt;p>일반적으로 하나의 패턴에는 아래와 같은 요소를 포함한다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>패턴 이름&lt;/code>: 디자인패턴을 설명하는 단어&lt;/li>
&lt;li>&lt;code>문제&lt;/code>: 해결할 문제와 그 배경을 설명&lt;/li>
&lt;li>&lt;code>해법&lt;/code>: 설계 구성요소 간의 관계, 책임, 협력 관계&lt;/li>
&lt;li>&lt;code>결과&lt;/code>: 디자인 패턴을 적용해서 얻는 결과와 장단점&lt;/li>
&lt;/ul>
&lt;h2 id="디자인-패턴-카탈로그">디자인 패턴 카탈로그&lt;/h2>
&lt;p>&lt;code>GoF의 디자인 패턴&lt;/code>에서는 총 23가지 종류의 패턴이 있다고 소개한다. 여기서는 간단히 이러한 종류가 있구나 하고 넘어가도록 하고, 이후 TIL에서 자세히 정리하도록 하겠다.&lt;/p>
&lt;h3 id="분류-기준--목적">분류 기준 == &amp;lsquo;목적&amp;rsquo;&lt;/h3>
&lt;p>GoF가 말하는 디자인 패턴을 나누는 두 가지 기준 중 첫번째는 &lt;code>목적&lt;/code>이다.&lt;/p>
&lt;h4 id="생성-패턴">생성 패턴&lt;/h4>
&lt;p>인스턴스를 만드는 과정을 추상화&lt;/p>
&lt;ul>
&lt;li>&lt;code>추상 팩토리&lt;/code>: 구체적인 클래스를 지정하지 않고 객체들의 집합을 생성하는 인터페이스를 제공.&lt;/li>
&lt;li>&lt;code>빌더&lt;/code>: 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 다른 결과를 만들 수 있게 함.&lt;/li>
&lt;li>&lt;code>팩토리 메서드&lt;/code>: 객체를 생성하는 인터페이스는 미리 정의하되 인스턴스를 만들 클래스는 서브클래스에서 결정.&lt;/li>
&lt;li>&lt;code>원형&lt;/code>: 생성할 객체의 종류를 명세하는 데 원형을 정의하고, 이를 복사함으로써 새로운 객체를 생성.&lt;/li>
&lt;li>&lt;code>단일체&lt;/code>: 클래스의 인스턴스가 하나임을 보장하고, 이 객체에 접근할 수 있는 전역적인 접촉점을 제공.&lt;/li>
&lt;/ul>
&lt;h4 id="구조-패턴">구조 패턴&lt;/h4>
&lt;p>클래스나 객체의 합성&lt;/p>
&lt;ul>
&lt;li>&lt;code>적응자&lt;/code>: 클래스의 인터페이스를 사용자가 기대하는 것으로 변환하여 호환성을 해결.&lt;/li>
&lt;li>&lt;code>가교&lt;/code>: 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 함.&lt;/li>
&lt;li>&lt;code>복합체&lt;/code>: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현.&lt;/li>
&lt;li>&lt;code>장식자&lt;/code>: 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴.&lt;/li>
&lt;li>&lt;code>퍼사드&lt;/code>: 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공.&lt;/li>
&lt;li>&lt;code>플라이급&lt;/code>: 크기가 작은 객체가 여럿 있을 때, 공유를 통해 이들을 효율적으로 지원.&lt;/li>
&lt;li>&lt;code>프록시&lt;/code>: 객체로 접근하는 것을 통제하기 위해서 대리자 또는 자리채움자를 제공.&lt;/li>
&lt;/ul>
&lt;h4 id="행동-패턴">행동 패턴&lt;/h4>
&lt;p>클래스나 객체의 상호작용&lt;/p>
&lt;ul>
&lt;li>&lt;code>책임 연쇄&lt;/code>: 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 주고받는 객체 사이의 결합을 피함.&lt;/li>
&lt;li>&lt;code>명령&lt;/code>: 요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장, 로깅, 연산 취소 지원.&lt;/li>
&lt;li>&lt;code>해석자&lt;/code>: 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의. 해당 문서를 해석하는 해석기 정의.&lt;/li>
&lt;li>&lt;code>반복자&lt;/code>: 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차 접근.&lt;/li>
&lt;li>&lt;code>중재자&lt;/code>: 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체 정의.&lt;/li>
&lt;li>&lt;code>메멘토&lt;/code>: 캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 되돌아올 수 있도록 함.&lt;/li>
&lt;li>&lt;code>감시자&lt;/code>: 객체들 사이에 일대다 의존 관계를 정의하여, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신할 수 있게 함.&lt;/li>
&lt;li>&lt;code>상태&lt;/code>: 객체 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가.&lt;/li>
&lt;li>&lt;code>전략&lt;/code>: 동일 계열 알고리즘군을 정의하고 각각의 알고리즘을 캡슐화하여 이들을 상호 교환이 가능하도록 만드는 패턴.&lt;/li>
&lt;li>&lt;code>템플릿 메서드&lt;/code>: 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리를 서브클래스 쪽으로 미룸.&lt;/li>
&lt;li>&lt;code>방문자&lt;/code>: 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴.&lt;/li>
&lt;/ul>
&lt;h3 id="분류-기준--범위">분류 기준 == &amp;lsquo;범위&amp;rsquo;&lt;/h3>
&lt;p>두 번째 분류 기준인 &lt;code>범위&lt;/code>는 패턴을 &lt;code>클래스&lt;/code>에 적용하는지 아니면 &lt;code>객체&lt;/code>에 적용하는지를 구분하는 것이다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">구분&lt;/th>
&lt;th style="text-align:center">생성&lt;/th>
&lt;th style="text-align:center">구조&lt;/th>
&lt;th style="text-align:center">행동&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">클래스&lt;/td>
&lt;td style="text-align:center">팩토리 메서드&lt;/td>
&lt;td style="text-align:center">적응자(class)&lt;/td>
&lt;td style="text-align:center">해석자&lt;!-- raw HTML omitted -->템플릿 메서드&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">객체&lt;/td>
&lt;td style="text-align:center">추상 팩토리&lt;!-- raw HTML omitted -->빌더&lt;!-- raw HTML omitted -->원형&lt;!-- raw HTML omitted -->단일체&lt;/td>
&lt;td style="text-align:center">적응자(object)&lt;!-- raw HTML omitted -->가교&lt;!-- raw HTML omitted -->복합체&lt;!-- raw HTML omitted -->장식자&lt;!-- raw HTML omitted -->퍼사드&lt;!-- raw HTML omitted -->플라이급&lt;!-- raw HTML omitted -->프록시&lt;/td>
&lt;td style="text-align:center">책임 연쇄&lt;!-- raw HTML omitted -->명령&lt;!-- raw HTML omitted -->해석자&lt;!-- raw HTML omitted -->중재자&lt;!-- raw HTML omitted -->메멘토&lt;!-- raw HTML omitted -->감시자&lt;!-- raw HTML omitted -->상태&lt;!-- raw HTML omitted -->전략&lt;!-- raw HTML omitted -->방문자&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>클래스 패턴
&lt;ul>
&lt;li>클래스와 서브클래스 간의 &lt;code>관련성&lt;/code>을 다루는 패턴&lt;/li>
&lt;li>관련성은 주로 &lt;code>상속&lt;/code>을 말함&lt;/li>
&lt;li>컴파일 타임에 &lt;code>정적&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체 패턴
&lt;ul>
&lt;li>객체 관련성을 다룸&lt;/li>
&lt;li>런타임에 &lt;code>동적&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="디자인-패턴-관계도">디자인 패턴 관계도&lt;/h2>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/bigmap.gif" alt="관계도">&lt;/p>
&lt;p>위 관계도는 디자인 패턴 간에 존재하는 참조 관계를 나타낸 것이다. 각 패턴을 따로 익히는 것도 중요하지만 각각의 패턴이 어떤 관계를 맺고 있는 지 확인하면서 공부하는 것이 도움이 될 것이다.&lt;/p>
&lt;h2 id="참조문헌">참조문헌&lt;/h2>
&lt;ul>
&lt;li>Gof의 디자인 패턴 번역본&lt;/li>
&lt;li>&lt;a href="https://www.cs.unc.edu/~stotts/GOF/hires/contfso.htm">https://www.cs.unc.edu/~stotts/GOF/hires/contfso.htm&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Til: 객체지향설계</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/object-oriented-design/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/design-patterns/object-oriented-design/</guid><description>
&lt;h2 id="개발-과정">개발 과정&lt;/h2>
&lt;pre>&lt;code>계획 → 분석 → 설계 → 구현 → 테스트
&lt;/code>&lt;/pre>&lt;p>설계 단계의 객체가 분석 모델에서부터 만들어진 경우도 있지만, 객체지향 설계 모델이 항상 실세계와 대응 관계를 갖는 것은 아니다. &lt;code>분석 모델&lt;/code>의 객체는 &lt;code>실세계&lt;/code> 객체이며, &lt;code>설계 모델&lt;/code>의 객체는 &lt;code>구현 수준&lt;/code>에 가까운 객체(리스트, 배열 등)이기 때문이다.&lt;/p>
&lt;p>디자인 패턴은 이러한 추상적인 개념과 이것을 구체화한 객체를 잡아낼 수 있게 도와주며, 유연한 설계를 돕는다.&lt;/p>
&lt;h2 id="객체-설정">객체 설정&lt;/h2>
&lt;p>&lt;code>객체지향 프로그래밍(OOP)&lt;/code>에서 객체는 &lt;code>데이터&lt;/code>와 &lt;code>프로시저&lt;/code>로 이루어진 것이며, 이것들이 모여 객체지향 프로그램을 구성한다.&lt;/p>
&lt;blockquote>
&lt;p>프로시저는 메소드(Method) 또는 연산(Operation)이라고도 한다.&lt;/p>
&lt;/blockquote>
&lt;p>객체는 &lt;code>요청(Request)&lt;/code> 또는 &lt;code>메시지(Message)&lt;/code>를 사용자에게서 받아 &lt;code>연산&lt;/code>을 수행한다.&lt;/p>
&lt;ul>
&lt;li>요청: 객체가 &lt;code>연산을 실행&lt;/code>하게 하는 유일한 방법&lt;/li>
&lt;li>연산: 객체의 내부 &lt;code>데이터 상태를 변경&lt;/code>하는 유일한 방법&lt;/li>
&lt;/ul>
&lt;p>이러한 접근의 제약 사항으로 객체의 내부 데이터는 &lt;code>캡슐화&lt;/code>된다. 이것의 의미는 객체 외부에서 객체 내부 데이터에 직접 접근이 불가하며, 객체의 내부 데이터 타입을 알 수 없다는 것이다.&lt;/p>
&lt;p>시스템을 구성할 &lt;code>객체의 분할&lt;/code>을 결정하는 것은 여러 요인들을 고려해야 하므로 매우 어려운 작업이다. 고려해야 할 요인에는 &lt;code>캡슐화&lt;/code>, &lt;code>크기 결정&lt;/code>, &lt;code>종속성&lt;/code>, &lt;code>유연성&lt;/code>, &lt;code>성능&lt;/code>, &lt;code>진화&lt;/code>, &lt;code>재사용성&lt;/code> 등이 있다.&lt;/p>
&lt;h2 id="객체-구현-명세">객체 구현 명세&lt;/h2>
&lt;p>&lt;code>OMT(Object-Modeling Technique)&lt;/code>란 소프트웨어 구성 요소를 그래픽 표기로 모델링하는 기법을 말한다.&lt;/p>
&lt;pre>&lt;code>Object 모델링 → Dynamic 모델링 → Functioanl 모델링
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Object 모델링: &lt;code>객체 다이어그램&lt;/code>으로 표시하며 객체 사이의 관계를 정하는 모델링&lt;/li>
&lt;li>Dynamic 모델링: &lt;code>상태 다이어그램(상태도)&lt;/code>를 이용하여 &lt;code>제어 흐름&lt;/code>을 모델링&lt;/li>
&lt;li>Functional 모델링: &lt;code>자료 흐름도(DFD)&lt;/code>를 이용하여 다수의 &lt;code>프로세스 사이의 자료 흐름&lt;/code>을 중심으로 처리 과정을 표현한 모델링&lt;/li>
&lt;/ul>
&lt;h3 id="클래스">클래스&lt;/h3>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/class.gif" alt="class">&lt;/p>
&lt;p>객체의 구현은 &lt;code>클래스(Class)&lt;/code>를 이용하여 객체의 내부 데이터와 연산을 정의한다.&lt;/p>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/insta045.gif" alt="insta045">&lt;/p>
&lt;p>객체는 클래스가 인스턴스화 됨으로 생성된다. 따라서 해당 관계는 위와 같이 표현할 수 있다.&lt;/p>
&lt;h3 id="서브-클래스">서브 클래스&lt;/h3>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/subcl009.gif" alt="subcl009">&lt;/p>
&lt;p>하나의 클래스는 다른 클래스로 &lt;code>상속&lt;/code>되기도 하는데 이러한 경우 상속하는 클래스는 &lt;code>부모 클래스(Parent Class or Super Class)&lt;/code>, 상속되는 클래스는 &lt;code>서브 클래스(Sub Class or Child Class)&lt;/code>라고 한다.&lt;/p>
&lt;blockquote>
&lt;p>상속은 부모 클래스의 구성을 모두 갖는 새로운 클래스를 만드는 것이다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="추상-클래스">추상 클래스&lt;/h3>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/absclass.gif" alt="absclass">&lt;/p>
&lt;p>&lt;code>추상(Abstract Class)&lt;/code>는 모든 서브클래스 사이의 공통되는 인터페이스를 정의하는 것이다. 이러한 클래스는 상속을 통해 만들어진 &lt;code>구체클래스(Concrete Class)&lt;/code>인 서브클래스에서 구체적인 명세가 이루어진다. 일반적인 클래스와는 다르게 추상 클래스는 단지 정의만 하고 구현은 하지 않는다.&lt;/p>
&lt;blockquote>
&lt;p>보통 추상 클래스는 이텔릭체로 표기한다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="믹스인-클래스">믹스인 클래스&lt;/h3>
&lt;p>&lt;img src="https://www.cs.unc.edu/~stotts/GOF/hires/Pictures/mixin.gif" alt="mixin">&lt;/p>
&lt;p>&lt;code>믹스인 클래스(Mixin Class)&lt;/code>는 서브클래스에게 &lt;code>인터페이스&lt;/code>를 제공하려는 목적을 가지는 클래스이다. 인스턴스로 만들 의도가 없다는 점에서 추상클래스와 비슷하나, &lt;code>다수의 클래스&lt;/code>가 서브클래스에게 인터페이스를 상속하기 위한 것이라는 점에서 큰 차이가 있다.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;code>다중상속&lt;/code>은 &lt;code>여러 인터페이스&lt;/code>의 기능을 상속한 하나의 클래스를 만드는 것이다. 반면 &lt;code>믹스인&lt;/code>은 위에서 설명했듯이 &lt;code>여러 클래스&lt;/code>의 기능을 상속하여 하나의 클래스를 만든다.&lt;/p>
&lt;p>&lt;code>인터페이스&lt;/code>는 선언만을 할 뿐 구현이 전혀 이루어져 있지 않다면, &lt;code>클래스&lt;/code>는 구현까지 모두 이루어져 있다. 따라서 클래스는 다중 상속할 경우 동일한 이름의 메소드의 구현이 다른 부분에서 충돌이 일어날 수 있다. 믹스인은 이러한 충돌을 해결해서 클래스를 다중상속할 수 있도록 하는 것이다.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="인터페이스-명세">인터페이스 명세&lt;/h2>
&lt;p>객체는 &lt;code>인터페이스&lt;/code>로 자신을 드러내므로 외부에서 객체를 알 수 있는 방법은 인터페이스 밖에 없다. 따라서 인터페이스를 통해서만 &lt;code>처리 요청&lt;/code>이 가능하며 &lt;code>구현&lt;/code>에 대해서는 전혀 알 수 없다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>시그니처(Signature)&lt;/code>: 객체가 선언하는 &lt;code>연산&lt;/code>으로 연산명, 매개변수, 리턴 값을 명세&lt;/li>
&lt;li>&lt;code>인터페이스(Interface)&lt;/code>: 객체가 정의하는 &lt;code>모든 시그니처&lt;/code>로 객체가 처리할 수 있는 연산의 집합&lt;/li>
&lt;li>&lt;code>타입(Type)&lt;/code>: 특정 인터페이스&lt;/li>
&lt;li>&lt;code>서브 타입(Sub-Type)&lt;/code>: 다른 인터페이스를 포함하는 인터페이스&lt;/li>
&lt;li>&lt;code>슈퍼 타입(Super-Type)&lt;/code>: 다른 인터페이스가 포함하는 인터페이스&lt;/li>
&lt;/ul>
&lt;p>서로 다른 객체라 할 지라도 &lt;code>동일한 타입&lt;/code>이라 한다면 해당 &lt;code>인터페이스&lt;/code>에서 지원하는 연산을 동일한 방식으로 요청이 가능하지만, 그 내부 구현에 따라 다른 결과를 전달 받을 수 있다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>동적 바인딩&lt;/code>: 위 원리를 활용하여 &lt;code>런타임&lt;/code>에 사용자 요청을 처리하는 &lt;code>객체를 결정&lt;/code>하는 것&lt;/li>
&lt;li>&lt;code>다형성&lt;/code>: 동일한 인터페이스를 갖는 &lt;code>다른 객체로 대체&lt;/code>할 수 있는 성질로, 객체지향 시스템의 핵심 개념&lt;/li>
&lt;/ul>
&lt;p>디자인 패턴을 이용하면 인터페이스에 정의해야 하는 요소가 무엇이고 어떤 데이터를 주고 받아야 하는지 식별할 수 있게 도와준다. &lt;code>메멘토 패턴&lt;/code>은 객체 내부 상태를 어떻게 저장하고 캡슐화해야 하는지를 정의함으로 나중에 그 상태를 복구할 수 있는 방법을 알려준다.&lt;/p>
&lt;p>디자인 패턴은 또한 인터페이스 간의 관련성도 정의한다. 유사한 인터페이스를 정의하거나 인터페이스에 여러 제약을 정의한다. &lt;code>데코레이터 패턴&lt;/code>과 &lt;code>프록시 패턴&lt;/code>은 대상 객체와 장식되고 중재하는 객체가 동일한 인터페이스를 갖도록 한다. 또한 &lt;code>방문자 패턴&lt;/code>에서 방문자 인터페이스는 방문자 객체가 방문하는 개체의 인터페이스를 반영한다.&lt;/p>
&lt;h3 id="클래스-상속-vs-인터페이스-상속">클래스 상속 vs 인터페이스 상속&lt;/h3>
&lt;ul>
&lt;li>&lt;code>클래스&lt;/code>: 객체가 어떻게 구현되는지르 정의, 객체의 내부 상태와 연산에 대한 &lt;code>구현 방법&lt;/code>을 정의&lt;/li>
&lt;li>&lt;code>인터페이스&lt;/code>(타입): 객체가 응답할 수 있는 &lt;code>요청의 집합&lt;/code>을 정의&lt;/li>
&lt;/ul>
&lt;p>하나의 객체는 여러 타입을 가질 수 있으며, 서로 다른 클래스의 객체들이 동일한 타입을 가질 수도 있다. 즉, 객체의 구현은 다르더라도 인터페이스는 같을 수 있다는 의미다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>클래스 상속&lt;/code>: 개체의 구현을 정의할 때 이미 정의된 객체를 기반으로 하는 것.&lt;/li>
&lt;li>&lt;code>인터페이스 상속&lt;/code>(서브타이핑): 어떤 객체가 다른 객체 대신에 사용(&lt;code>동적 바인딩&lt;/code>)될 수 있는 경우 사용.&lt;/li>
&lt;/ul>
&lt;p>C++에서 순수한 인터페이스 상속은 순수 가상 함수를 정의한 추상 클래스를 &lt;code>public&lt;/code>으로 상속한다. 반면 클래스 상속은 &lt;code>private&lt;/code>으로 상속하게 되는데 이는 부모 클래스의 구현을 캡슐화하기 위함이다. 이로 인해 서브클래스의 사용자에게는 부모클래스에 정의된 연산이 공개되지 않게 된다.&lt;/p>
&lt;p>&lt;code>책임 연쇄 패턴&lt;/code>에 나오는 객체들은 반드시 동일한 타입을 가져야 하지만, 이들이 구현을 공유하지는 않는다. &lt;code>복합체 패턴&lt;/code>에서 Component 클래스는 공통의 인터페이스를 정의하고 Composite 클래스는 공통의 구현을 정의한다. &lt;code>커맨드&lt;/code>, &lt;code>옵저버&lt;/code>, &lt;code>상태&lt;/code>, &lt;code>전략&lt;/code> 패턴은 순수 인터페이스인 추상 클래스를 써서 구현하는 경우가 많다.&lt;/p>
&lt;h3 id="인터페이스-프로그래밍">인터페이스 프로그래밍&lt;/h3>
&lt;p>&lt;code>클래스 상속&lt;/code>은 부모 클래스에 정의된 &lt;code>구현을 재사용&lt;/code>해서 빠르게 새로운 기능을 구현하는 것이 가장 큰 목적이다. 즉, 상속을 이용하면 &lt;code>중복되는 코드&lt;/code>를 줄여준다는 장점이 있다. 다만 상속은 이런 단순한 작업뿐 아니라 더 복잡한 일도 이루어낼 수 있다.&lt;/p>
&lt;p>&lt;code>동일한 인터페이스&lt;/code>를 갖는 객체들을 &lt;code>공통된 추상 클래스&lt;/code>를 상속하도록 하여 인터페이스를 공유할 수 있다. 이렇게 만들어진 인터페이스를 공유하는 객체군들은 모두 부모 클래스에 정의된 요청을 처리할 수 있게 된다. 앞에서도 언급했지만 이러한 원리를 이용하면 프로그램이 동작중인 런타임 중에 사용자 요청을 처리할 객체를 동적으로 결정할 수 있다. 이는 객체 지향에서 중요한 개념인 &lt;code>다형성&lt;/code>이라는 성질이다.&lt;/p>
&lt;p>&lt;code>추상 팩토리&lt;/code>, &lt;code>빌더&lt;/code>, &lt;code>팩토리 메서드&lt;/code>, &lt;code>프로토타입&lt;/code>, &lt;code>복합체&lt;/code> 패턴에서는 구체 클래스에서 인스턴스를 생성하도록 한다. 객체 생성 과정을 추상화 함으로써 인스턴스화할 때 인터페이스와 구현을 연결하는 방법을 제공한다.&lt;/p>
&lt;h2 id="재사용-가능한-소프트웨어-개발">재사용 가능한 소프트웨어 개발&lt;/h2>
&lt;h3 id="객체-합성">객체 합성&lt;/h3>
&lt;p>&lt;code>객체 합성&lt;/code>은 클래스 상속에 대한 대안으로 다른 객체들을 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것이다. 객체를 합성하기 위해서는 합성하는 객체의 &lt;code>인터페이스&lt;/code>를 명확하게 정의해야만 한다. 이런 방법의 재사용을 &lt;code>블랙박스 재사용(black-box reuse)&lt;/code>라고 한다. 객체의 내부가 공개되지 않고 인터페이스를 통해서 재사용되기 때문이다.&lt;/p>
&lt;blockquote>
&lt;p>클래스 상속은 부모 클래스의 내부가 서브클래스에 공개되므로 &lt;code>화이트박스 재사용(white-box reuse)&lt;/code>라 한다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-JAVA" data-lang="JAVA">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Computer&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> CPU cpu&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> Memory memory&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> MainBoard mainBoard&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> PowerSupply powerSupply&lt;span style="color:#f92672">:&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Computer&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
cpu &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CPU&lt;span style="color:#f92672">();&lt;/span>
memory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Memory&lt;span style="color:#f92672">();&lt;/span>
mainBoard &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MainBoard&lt;span style="color:#f92672">();&lt;/span>
powerSupply &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> PowerSupply&lt;span style="color:#f92672">():&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
powerSupply&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
mainboard&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
cpu&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
memory&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 컴퓨터를 구성하는 부품 객체들을 합성하여 컴퓨터 클래스를 정의한 것이다. 객체 합성을 사용하면 각 클래스를 한 가지 작업에 특화시켜 응집도가 높고 결합도가 낮은 소프트웨어를 만들 수 있다는 점에서 클래스 상속보다 좋은 방법이다.&lt;/p>
&lt;h3 id="객체-위임">객체 위임&lt;/h3>
&lt;p>&lt;code>위임(delegation)&lt;/code>은 객체 합성 원리를 이용하여 특정 객체의 필요한 기능만을 가져오는 것이다. 상속은 필요없는 부분도 다 물려받아야 된다는 점과 대조된다.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-JAVA" data-lang="JAVA">&lt;span style="color:#f92672">import&lt;/span> java.util.ArrayList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyStack&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getSize&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">peek&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>getSize&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String text &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>getSize&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">remove&lt;/span>&lt;span style="color:#f92672">(&lt;/span>getSize&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> text&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String text&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>text&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 기존에 존재하는 ArrayList를 활용하여 MyStack 클래스를 생성하는 것이다. 해당 예제를 보면 알 수 있듯이 객체 위임은 부모 클래스가 제공하는 기능을 가져오기만 하는 것이 아니라 재정의해서 사용할 수 있다는 특징을 가진다.&lt;/p>
&lt;h3 id="매개변수-타입">매개변수 타입&lt;/h3>
&lt;p>JAVA에서 &lt;code>제네릭(generic)&lt;/code>이라 하며 c++에서는 &lt;code>템플릿(template)&lt;/code>이라 하는 &lt;code>매개변수 타입&lt;/code>을 활용하면 프로그램을 보다 동적으로 짤 수 있게 된다. 타입을 컴파일 전에 정의하지 않고 런타임 중에 정의하는 방법이다.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-JAVA" data-lang="JAVA">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> stringList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integerList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>제네릭 형식의 ArrayList가 정의한 것을 활용하여 문자열 리스트와 정수형 리스트를 생성하는 예제이다. 제네릭을 활용하지 않았다면 각각의 리스트를 만들기 위한 클래스가 필요했을 것이다.&lt;/p>
&lt;h2 id="변화에-대비한-설계">변화에 대비한 설계&lt;/h2>
&lt;p>재사용을 최대화하기 위해서는 새로운 요구사항과 기존 요구사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야한다.&lt;/p>
&lt;ul>
&lt;li>특정 클래스에서 객체 생성
&lt;ul>
&lt;li>문제점: 특정 인터페이스가 아닌 특정 구현에 종속&lt;/li>
&lt;li>해결방법: 추상 팩토리, 팩토리 메서드, 프로토타입&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>특정 연산에 대한 의존성
&lt;ul>
&lt;li>문제점: 요청을 만족하는 한 가지 방법에만 종속&lt;/li>
&lt;li>해결방법: 책임 연쇄, 커맨드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하드웨어와 소프트웨어 플랫폼에 대한 의존성
&lt;ul>
&lt;li>문제점: 플랫폼 이식에 어려움&lt;/li>
&lt;li>해결방법: 추상 팩토리, 브릿지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>객체의 표현이나 구현에 대한 의존성
&lt;ul>
&lt;li>문제점: A가 B의 구현을 알고 있다면 B를 변경할 때, A도 변경해야 함&lt;/li>
&lt;li>해결방법: 추상 팩토리, 브릿지, 메멘토, 프록시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알고리즘 의존성
&lt;ul>
&lt;li>문제점: 알고리즘을 변경하기 어려움&lt;/li>
&lt;li>해결방법: 빌더, 이터레이터, 전략, 템플릿 메서드, 방문자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>높은 결합도
&lt;ul>
&lt;li>문제점: 클래스를 독립적으로 사용할 수 없음&lt;/li>
&lt;li>해결방법: 추상 팩토리, 브릿지, 책임 연쇄, 커맨드, 중재자, 옵저버&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>서브클래싱을 통한 기능 확장
&lt;ul>
&lt;li>문제점: 새로운 클래스마다 객체를 재정의해야 함&lt;/li>
&lt;li>해결방법: 브릿지, 책임 연쇄, 테커레이터, 옵저버, 전략&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>클래스 변경이 편하지 못한 점
&lt;ul>
&lt;li>문제점: 변경사항에 서브클래스 다수를 수정해야 하는 불편함&lt;/li>
&lt;li>해결방법: 어댑터, 테커레이터, 방문자&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="디자인-패턴-고르기">디자인 패턴 고르기&lt;/h2>
&lt;ul>
&lt;li>패턴의 문제 해결방법 파악&lt;/li>
&lt;li>패턴의 의도 파악&lt;/li>
&lt;li>패턴들 간의 관련성을 파악&lt;/li>
&lt;li>비슷한 목적의 패턴들을 모아서 공부&lt;/li>
&lt;li>재설계의 원인을 파악&lt;/li>
&lt;li>설계에서 가변성을 가져야 하는 부분이 무엇인지 파악&lt;/li>
&lt;/ul>
&lt;h2 id="참고문헌">참고문헌&lt;/h2>
&lt;ul>
&lt;li>Gof의 디자인 패턴 번역본&lt;/li>
&lt;li>&lt;a href="https://www.cs.unc.edu/~stotts/GOF/hires/chap1fso.htm#sec1-6">Department of Computer Science University of North Carolina&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stonzeteam.github.io/%EC%BD%94%EB%93%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%9C%84%ED%95%9C-Mixin/">코드 재사용을 위한 Mixin&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Til: 생성 패턴</title><link>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>http://Jeonghun-Ban.github.io/til/design-patterns/creatinal-patterns/</guid><description/></item></channel></rss>