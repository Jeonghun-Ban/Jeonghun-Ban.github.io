[{"content":"이번년도는 돌이켜보면 참으로 다사다난한 해였다. 1년동안 활동한 멋쟁이 사자처럼 7기를 무사히 마치고, 8기 운영진을 선발했다. 그리고 운영진 교육을 진행하면서 취업 준비를 동시에 준비하였다. 실제로 산업체 복무에 성공하기도 했지만, 결국에는 퇴사하고 군대에 오기까지 별에 별 일이 다 있었다. 2020년은 내게 여러모로 아쉬움이 남는 해이다. 이번 회고를 통해 부족한 점을 돌아보고 개선하고자 한다.\n멋쟁이 사자처럼 목표는 중요하다. 중학생 때부터 나는 줄곧 컴퓨터를 좋아했고, 네이버 블로그를 통해 IT 관련 지식을 공유하기도 하였다. 그러다보니 자연스래 코딩에 대한 관심을 가지게 되었다. 하지만 그렇다고 코딩에 본격적으로 빠져든 것은 아니었다. 첫째로 처음 접한 C언어가 너무 어려웠고 둘째로 뭔가를 하고 싶다는 목표가 뚜렷하게 없었기 때문이다.\n운영진 활동을 하며 꿈을 찾다. 그런 나에게 있어서 멋쟁이 사자처럼은 내게 있어서 단비같은 존재였다. 멋사는 대학교 1학년 때 사귄 친구의 권유로 알게 되었고, 덕분에 7기 운영진까지 지원하였다. 처음에는 사람들 앞에 나서서 수업을 진행해야 한다는 점 때문에 운영진을 하고 싶지 않았었다. 하지만 지금 돌이켜보면 운영진 활동을 하게 된 것은 내게 큰 도움이 되었다. 운영진이라는 역할을 해내이기 위해서는 수많은 공부를 필요로 했는데, 이것이 나를 끊임없이 발전시키는 원동력이 되었다.\n멋사 7기 운영진으로의 활동은 2020년 초 수료하는 것으로 무사히 마무리를 지었다. 7기 운영을 하면서 해커톤에서 특별한 성적을 얻지는 못했지만, 수업을 진행하는 과정 자체가 내겐 큰 의미였다. 수업 교안을 준비하면서 나는 백엔드 개발자라는 목표를 가지게 되었으며, 코딩이 어렵지 않고 재미있다고 생각하게 되었기 때문이다. 이때부터 나는 본격적으로 프로그래머의 꿈을 꾸기 시작하였다.\n아쉬운 점 나는 경험 상 프로그래밍은 이론이나 개념도 중요하지만 직접 만들어보면서 느끼고 배우는 것이 컸다. 그래서 수업 진행을 PPT위주가 아닌 실습 위주로 진행하였고, 필요한 개념은 Notion에 정리한 내용과 판서를 통해서 설명하였다. 당시 이러한 방식이 학습하는 데 효율적이다라고 생각하고 진행했는데, 수업을 잘 이해하지 못하는 사람들도 있었을 것이다. 수업을 준비하면서 학업까지 동시에 진행하다보니 수업 진행에 있어서 준비가 부족한 점이 많았다고 생각하고 이 부분에 대해서는 여전히 동아리원들에게 미안하다.\n군대 대신 취업을 결심하다. 계기 나는 군대를 가기 싫었다. 이제 막 백엔드 개발자라는 꿈을 설계하기 시작했는데, 이것을 잠시 내려두고 어디론가 가야 한다는 것 자체가 내겐 어려운 일이었다. 계속해서 나는 앞으로 나아가고 싶었고, 그것을 위한 방법이 바로 산업체에 취직하는 것이었다. 산업체에 들어가면 경력 단절이 없음은 물론 3년의 복무 기간동안 군복무와는 비교도 안되는 월급을 받을 수 있다는 장점도 있었다. 무조건 회사에 들어가야 한다는 생각으로 3학년 1학기를 휴학하였다. 멋쟁이 사자처럼 8기 운영진 교육을 진행하면서 동시에 취업 준비를 하고 있었다.\n취준생이 되다. 몇 개월에 걸친 취업 준비 끝에 성공할 수 있었다. 취업에 필요한 정보들은 보통 Awesome Alternative Military Service와 미필자 정보공유 카페에서 얻을 수 있었고, 입사 지원은 대개 로켓펀치와 산업지원 병역일터에서 이루어졌다. 이곳들에 올라오는 공고를 보고 여러 회사에 지원한 결과 한 회사에서 연락이 돌아왔고, 취업의 기회를 얻을 수 있었다.\n취업에 성공하다. 일주일 동안 해야하는 과제는 플라스크를 기반으로 하는 API 서버를 구축하고, postgresql와 sqlalchemy, redis를 이용해서 데이터와 사용자 세션을 관리하는 간단한 서비스를 만들어보는 것이었다. 해당 기간동안 나는 과제를 하는 데에만 집중한 채 다른 것은 미루어 두었다. 요구사항에 기재된 기술 스택들이 내게는 생소한 것들이었기 때문이다. Docker 컨테이너 상에 웹서버, WAS서버, DB서버마저 올려야 하는 상황에서 나는 모르는 것이 너무나 많았다.\n당장 구축해야하는 도커를 사용하지 못하는 상황에 나머지 기술들도 사용해본 적도 없었다. 그래서 일주일을 오로지 투자하여 잠 자는 시간을 빼고는 개발에 전념했다. 그 결과 모든 요구사항을 만족하는 API서버를 구축할 수 있었다. 짧은 입사 테스트 기간동안 배운 것들이 너무나 값지다 생각했기에 떨어지더라도 후회가 없었다. 게다가 이후 면접에서 많은 질문에 대답을 잘 못했기 때문에 분명 떨어질거라 생각하고 반쯤 포기하고 있었다. 내 예상과는 달리 나는 입사 테스트에 합격해 있었다.\n 합격 이메일이 스팸함이 있었다는 사실을 몰라 하마터면 자동으로 탈락될 뻔 했다.\n 회사 생활에서 얻은 것들 회사는 강남에 위치한 공유 오피스에 있었다. 학교가 아닌 회사로 출퇴근하는 풍경은 새로웠고 설레는 일이었다. 회사에서는 맥북 15인치과 델 모니터 하나를 제공해주는 점도 마음에 들었다. 회사에 들어가자마자 일을 하지는 않았고 약 10일 동안 부여된 적응기간이 내게 주어졌다. 이 기간 동안 깃랩에 있는 서버 소스코드를 개발 서버에서 구동해보는 과제를 수행하며 서비스에 대한 이해를 높여 갔다.\n이후에는 테스트코드를 작성하는 작업을 하였고, 이슈에 등록되어 있는 버그를 조치하였다. 가장 기억에 남는 작업은 회사에서 마지막으로 한 작업인 슬랙봇 기능개선이다. 서비스 기능 중에 채팅이 있었는데 해당 기능은 사용자들이 서비스를 이용하다가 궁금한 점을 물어보기 위한 것이다. 사용자는 채팅을 시작(open)한 이후 더 이상 질문을 이어나갈 필요가 없어지는 경우 채팅을 닫고(close) 그만두게 되는데, 이러한 방식은 깃헙에 이슈를 생성하고 그 아래에서 댓글을 이어나가는 것과 유사하다.\n회사에서는 이러한 사용자들의 채팅(문의사항)들을 효과적으로 관리하기 위해서 슬랙봇으로 슬랙 채팅방에 동일한 메시지를 전송하게 하였다. 하지만 해당 기능은 사용자가 보내는 메시지를 하나씩 슬랙에 출력하는 바람에 내용을 한 눈에 파악하기 힘들었다. 다시 말해 하나의 문의에 해당하는 채팅이 여러 개로 분리된 모습은 그리 가독성이 좋지는 않았다.\n그래서 동일한 문의에 대한 메시지들은 하나로 합쳐서 보여주는 기능을 만들자는 깃허브 이슈가 올라와 있었고, 나는 이것을 해결하는 역할을 맡았다. Slack API를 찾아보니 메시지를 merge하는 기능은 없었다. 대신에 chat.update와 search.messages를 이용해서 새로운 메시지가 이미 존재하는 문의에 해당하는 것이라면 합쳐서 보여주고, 그렇지 않다면 새로운 메시지를 만들 수 있도록 하는 방법으로 해결하였다.\n결국 퇴사하다. 회사를 다닌지 한달이 될 무렵, 사수분이 나와 직장 동료를 조용히 불렀다. 우리들처럼 회사에는 산업요원으로 복무를 희망하는 사람들이 많고, 그들 중 한두명을 선발하는데 그것이 우리가 아니라는 이야기였다. 회사를 더 다니고 싶다면 다녀도 좋지만 그렇지 않다면 회사를 나가도 좋다고 하였다.\n내가 회사에 입사하게 된 목적은 돈을 벌기 위한 것도 있었겠지만, 군복무를 대체하기 위한 목적이 가장 컸기에 이러한 제안은 내게 결과적으로 회사를 나가달라는 말과 다름없었다. 나는 결국 짤린.. 아니 퇴사를 결심하게 된 것이었다.\n그때 당시 내가 회사를 나와야 했던 이유는 다음과 같다.\n 부족한 기여도 시간 약속 지키기 열정(?)  기억이 정확하게 다 나지는 않지만 사수가 말하길 스타트업에서는 신입이더라도 충분히 성장하기를 기다려줄 여유는 없고 바로 성과를 낼 수 있는 인재를 원한다고 했다. 나는 어떠한 업무를 실행할 때 기간을 설정하고 지키는 과정이 잘 이루어지지 않는다는 부분으로 자주 지적받았다. 또한 성과를 못내면 늦게까지 회사에 남아서 일하는 열정이라도 보여주어야 했다는 말도 들었다.\n이러한 사수분의 말들은 결국 내게 따끔한 일침으로 돌아왔고, 진심으로 내가 부족한 부분을 돌아 볼 수 있는 계기가 되었다. 다음에 회사에 입사할 때는 늦은 시간까지 남아서 일하지 않아도 회사에서 한 몫을 다할 수 있는 능력있는 사람이 되어야겠다고 다짐한다.\n 당시 회사에서 나오면서 인생의 쓴 맛을 맛보았지만, 아이러니하게도 그 당일에 입금된 첫 월급은 무척 달았다.\n 이번년도의 끝은 군복무 다시 회사에 지원했으나 결국에 회사를 그만두고 할 수 있는 것은 다음 회사를 찾거나 군대를 가는 것이었다. 이후에도 몇 차례 회사에 지원했지만 가고 싶은 회사에 붙지는 못했다. 한 회사에서는 내가 맘에 들었는지 다음년도(2021년)에 나오는 TO를 줄테니 회사에 다니면서 기다려보라고 이야기했다. 심지어는 취준을 병행해도 된다는 파격 조건을 내걸었으나 내가 싫다고 하고 기회를 걷어찼다. (지금 생각해보면 왜그랬는지 모르겠다..) 그리고 다른 회사는 면접을 가면 붙을 거 같기는 했는데 내 커리어에 도움될 것 같지는 않은 회사라서 가지 않겠다고 정중히 거절했다.\n정보보호병 지원 나는 앞서 말했다싶이 군대를 가기 싫어하던 이유가 경력단절에 있다. 이제 꿈을 찾아서 앞으로 나가가려는 나에게 있어서 군대는 장애물에 불과했다. 부모님이 아무리 남자는 군대를 가야한다는 말을 해도 들리지 않았다. 하지만 확실하게 산업체에서 일할 수 있는게 아닌 만큼 끝없이 휴학하고 집에만 있을 수는 없는 일이었다. 그래서 결국에는 군대를 선택하게 되었고, 정보보호병이라는 그래도 전공과 연관이 있는 보직에 지원하게 되었다. 게다가 사단보다는 군단 이상 급으로 자대가 나온다는 이야기를 듣고 많은 기대를 가지고 있었다.\n자대배치, 절망 정보보호병 중에서도 다섯 손가락에 드는 성적이었음에도 불구하고, 나는 28사단에 배정받게 되었다. 후반기 때 친구들이 다 지작사나 군단을 간 것을 생각하면 아직도 배가 아프다. 후반기 마지막 주차 때는 거의 정신 나간 채로 살았던 거 같다. 왜 내가 무엇때문에 사단으로 배정이 난 것일까 계속 생각했다. 그 결과 결국 깨달았다. 도박은 하지 말자. 그게 내가 내린 결론이다. 내 인생은 내가 개척하는 것이지 군대처럼 내가 어디갈지 모르는 것에 몸을 맡기니 이렇게 되는 것이라고, 후회해도 어쩔 수 없다. 군대에 지원한 결정 자체는 내가 내린 것이기에\u0026hellip;\n앞으로의 목표 군대에 온 이상 일정 시간이 지나가기 이전에는 절대로 나갈 수 없다. 그것이 군대의 룰이다. 그렇다면 그 시간 안에 얼마나 많은 것을 해낼 수 있느냐가 중요한 관건이다. 계획을 세우고 이것을 실행하는 것으로 후회없는 군생활을 보내고 싶다. 아래는 그것을 위한 개략적인 목표이다.\n 꾸준한 블로그 활동 코딩 테스트 준비  백준 문제 등 활용   소프트웨어 아키텍처 공부하기  GoF 디자인 패턴 Java 객체지향 디자인 패턴 클린 아키텍처   애자일 공부하기  리팩토링 클린 코드   부족한 자바 공부  이펙티브 자바   이외에 60권 독서 100일 동안 다이어트 및 운동  군대라는 공간 특성상 코딩을 제대로 하기란 쉽지 않고, 나는 전역 이후의 내가 지금보다 더 나은 개발자가 되어있기를 원한다. 그렇기에 개발자로서 갖추어야 할 지식들을 군대 내에서 최대한 많이 공부하기로 결정했다. 그리고 여기에는 사람은 끊임없이 공부하는 삶을 영위해야 행복함을 느낀다라고 생각하는 나의 가치관이 드러난다.\n나는 군대에 온 것을 진심으로 후회했다. 특히 자대배치 이후에 말이다. 하지만 또 생각해보면 언제 또 이렇게 많은 공부를 할 수 있는 기회가 있을까? 학교나 회사를 다니는 동안에는 바쁘다는 핑계로 하지 못했을 공부를 지금하는 거라 생각하면 좋은 기회이다. 나는 절대로 1년 남은 시간을 가벼이 버릴 생각은 눈꼽만큼도 없다. 내가 결정한 선택의 책임에 있어서 후회는 남기고 싶지 않다.\n","description":"2020년을 되돌아보며, 그리고 그 이후\n","id":0,"section":"posts","tags":["retrospective"],"title":"2020년 백엔드 개발자 회고","uri":"https://jeonghun-ban.github.io/posts/development/2020-backend-developer-retrospective/"},{"content":" 이 블로그는 제가 배운 내용을 정리하여 공유하기 위해 만들어진 공간입니다.\n단순히 공부한 것을 정리하는 것을 넘어 개인적인 견해도 담는 것을 목표로 하고 있습니다.\n 저는 작년부터 TIL을 통해서 공부한 내용을 정리하고 있었습니다.\n하지만, 이 레파지토리는 개인적인 생각을 드러내기 위한 목적이 아닌 객관적인 사실을 정리하기 위한 것이었습니다.\n이는 결국 단지 제가 공부한 것을 까먹지 않기 위한 수단밖에 되지 않는다는 생각이 들었습니다.\n하지만 저는 배운 것을 정리하는 것도 물론 중요하지만,\n다른 사람과 공유하는 것이 더 큰 의미를 지닌다고 믿습니다.\n객관적인 사실 전달뿐 아니라 제 개인적인 생각을 담은 포스팅을 쓰고 싶었습니다.\n이것이 바로 제가 블로그를 만들게 된 계기입니다.\n정보를 나누는 것이 목적인 블로그인 만큼,\n다른 의견이 있거나 잘못된 부분이 있다면 아낌없이 말씀해주시기 바랍니다.\n언제든지 댓글을 통해서 이슈를 남겨주시면 확인해서 반영하도록 하겠습니다!\n","description":"","id":1,"section":"","tags":null,"title":"About","uri":"https://jeonghun-ban.github.io/about/"},{"content":"서론 나는 백엔드 개발자라는 꿈을 가지고 열심히 달려왔다고 생각한다. 그 결과 엘리스라는 산업체에서 짧게나마 복무를 해보기도 했었다. 하지만 지금 생각해보면 백엔드만을 공부하다보니 전반적인 웹에 대한 지식이나 프론트엔드의 트랜드를 많이 놓치고 있지 않았나 하는 생각이 들었다. 군대에 와서는 블로그도 만들어보는 과정에서 프론트엔드 단의 개발에 관심이 생겼다. 그렇다고 지금 프론트 개발자로 전향하겠다 선언하는 것은 아니다. 단지 백엔드 개발자라는 이유로 프론트를 외면해서는 안되겠다는 생각을 하게 된 것이다. 그래서 이번 글을 통해서 최근 웹 프론트엔드에서 트랜드인 용어들(SSR, CSR, SPA, MPA)를 공부해보기로 했다.\nStatic Page 정적 페이지란 웹 서버 상에 저장된 파일(HTML, JS)이 사용자에게 그대로 전달되는 웹 페이지를 말한다. 데이터가 직접 변경되지 않는 한 페이지는 동일하게 보여지며 빠른 렌더링 속도를 가진다. 개인 블로그와 같이 정해진 내용을 렌더링하는 사이트를 만드는 경우에는 정적 페이지가 많이 사용된다. 보통은 정적 사이트를 처음부터 만드지 않고 Static Site Generator를 이용하는데 대표적인 툴로는 jekyll, hexo, gatsby, hugo 등이 있다.\nDynamic Page 말 그대로 동적인 웹페이지를 말한다. 정적 페이지와 달리 애플리케이션에서 전달하는 데이터에 따라 동일한 페이지여도 다른 정보를 표현할 수 있다. 예를 들어 페이스북에 접속했을 때 사용자별로 보이는 정보는 각자 다르다. 하지만 분명히 동일한 페이지(www.facebook.com)에 접속하고 있다는 사실은 모두가 잘 알고 있을 것이다. 현대의 대다수의 웹페이지는 이러한 방식을 통해 만들어지고 있다.\nCSR(Clent-Side Rendering)  클라이언트 단에서 렌더링을 하는 방식을 말한다. 브라우저 상에서 HTML, JS 등 렌더링을 위해 필요한 것들을 모두 다운로드하고 렌더링한다. 이후에 필요한 데이터만 서버에 요청해서 JS로 동적으로 처리한다.\nSSR(Server-Side Rendering)  전통적인 웹 애플리케이션의 동작방식이다. 서버 상에서 렌더링을 마치고 클라이언트는 이것을 받아서 실행한다. CSR과 달리 페이지를 처음 접속할 때만이 아니라 다른 페이지로 이동할 때마다 새로고침이 일어난다.\nSPA(Single Page Application) 한 개의 페이지로 이루어진 애플리케이션이다. 이 방식으로 만들어진 사이트는 접속하는 처음에만 페이지를 로딩하고 이후는 필요한 데이터만 서버에 요청해서 업데이트한다. 그래서 페이지를 새로고침하지 않는다는 특징을 가진다. 최근 프론트엔드 개발에서 엄청난 인기를 받고 있는 라이브러리인 리액트가 대표적인 예시인데, 페이스북은 이것을 통해 만들어진 대표적인 사이트이다. 실제로 페이스북을 웹에서 사용해보면 접속하는 처음만 페이지 로딩이 일어나고 이후에는 새로고침 과정이 전혀 일어나지 않는다.\nMPA(Single Page Application) 여러 페이지로 이루어진 애플리케이션을 말하며 SPA와 상반되는 개념이다. 서버로부터 완전한 페이지를 받아오며 다른 데이터를 보기 위해서는 브라우저의 새로고침이 필요하다.\nSPA != CSR 위 내용을 읽어보면 SPA와 CSR이 유사한 개념이라는 사실을 알 수 있을 것이다. 그렇다고 같은 개념이라고 오해해서는 안된다. SPA(Single Page Application)을 구현하기 위해서 CSR(Client-Side Rendering) 방식이 사용되는 것이지 등식이 성립하는 관계는 아니다. 굳이 따지자면 SPA를 이루는 요소 중 하나가 CSR(SPA⊃CSR)이라고는 할 수 있겠다.\n MPA/SSR의 관계도 SPA/CSR의 것과 동일하다. MPA를 구현하기 위해 SSR이 사용된다.\n SPA vs MPA    구분 SPA MPA     장점 컴포넌트 재사용유연한 UI SEO에 유리   단점 초기 페이지 로딩 시간SEO에 불리 다른 페이지 이동 시 새로고침    검색 엔진 최적화 문제 SEO(Search Engine Optimization)는 검색엔진 상에서 검색 결과의 상위에 나올 수 있도록 하는 작업을 말한다. 보통 검색엔진은 웹 사이트들을 크롤링한 결과를 보여주는데 구글을 제외한 대다수의 검색엔진 크롤러는 JS를 해석하지 못한다. MPA는 서버에서 이미 렌더링된 페이지를 그대로 보여주므로 SEO 문제가 발생하지 않는 반면, 빈 페이지를 로딩한 이후 데이터를 JS를 통해 렌더링하는 SPA는 검색엔진이 적절히 크롤링하지 못한다.\n결론 오늘날 우리가 사용하는 웹 페이지는 다양한 구조를 가지고 있다. 전통적인 방식으로는 웹서버 상에 위치한 자원을 그대로 보여주기만 하는 정적 페이지 그리고 서버에서 렌더링한 페이지를 JSP/Servlet 등을 통해 제공하는 방식이 있었다. 하지만 최근엔 다양한 요구사항에 따라 앱처럼 동작하는 웹 애플리케이션의 필요로 인해 SPA가 탄생했다. 이러한 패러다임의 변화로 렌더링이 이루어지는 위치에 따라 SSR과 CSR로 구분짓기 시작했다.\n 사실 따지고 보면 CSR이라는 개념은 전혀 새로운 것은 아니다. 전통적인 MPA이더라도 일부 페이지 내용을 Ajax를 통한 비동기 통신으로 변경하는 경우가 있었기 때문\n 최근에는 SEO 문제를 해결하기 위해서 SPA에 SSR을 도입하는 경우가 있다. 대표적인 예로는 리액트 기반의 프레임워크인 next.js이다. 이것을 이용하면 CSR은 물론이고 SSR까지 지원할 수 있게 된다. 이렇게 사용하는 방식을 hybrid라고 부른다. SPA를 유지하면서 검색엔진 최적화를 하고 싶다면 react-helmet이나 react-snap 등을 이용하면 된다.\n결과적으로 말하고 싶은 것은 웹 애플리케이션을 구현하는 방식은 다양하다. 어느 게 정답이라 할 수 없고 여러 방식을 혼합해서 사용해도 좋다. 결국에는 주어진 과제에 맞게 풀어나가는 것이 중요하다고 생각한다. 검색 엔진 최적화가 우선시 되어야 하는 경우 SSR를 도입해야 할 것이며, 웹 상에서 유연한 UI와 새로고침 없는 앱과 같은 사용자 경험을 제공하고 싶다면 CSR기반의 SPA를 도입해야 할 것이다.\n","description":"최근 웹 프론트엔드에서 트랜드인 용어를 정리해보았다.\n","id":3,"section":"posts","tags":["Software Architecture","SSR","CSR","SPA","MPA"],"title":"웹 애플리케이션 구조(SSR, CSR, SPA, MPA)","uri":"https://jeonghun-ban.github.io/posts/development/web-application-structure/"},{"content":"다층구조 아키텍쳐는 일반적으로 클라이언트-서버 애플리케이션에서 사용된다. 웹 애플리케이션을 비롯한 대다수 애플리케이션에서 활용되는 기본적인 구조인 만큼 익혀두어야 하는 개념이라 생각한다.\nlayer n-tier architecture를 구성하는 계층(layer)은 아래 3가지이다.\n 프레젠테이션: 유저 인터페이스(UI) 애플리케이션(또는 로직): 비즈니스 로직을 처리함 데이터: 데이터베이스를 의미  여기서 주의해야 할 점이 층(tier)와 계층(layer)은 구분되는 개념이다. 층은 물리적으로 분리된 것을 의미하며 계층은 논리적으로 분리되는 개념이다.\n2-tier vs 3-tier  2-tier  자바 등을 통해서 구현된 클라이언트 프로그램 직접 DB에 접속하여 가져온 데이터를 표현한다.  3-tier  웹 애플리케이션이 대표적인 예시 DB에 직접 접속하지 않고 미들웨어에 접속  참고로 2-tier 구조는 꼭 클라이언트 프로그램이 아닌 웹 애플리케이션으로 구현될 수도 있다. 또한 반대로 클라이언트 프로그램도 3-tier로 구현하는 것도 가능하다.\n구현 사례 내가 대학교 2학년 때 전공 프로젝트로 진행한 대학 수강신청 시스템은 다층구조를 설명하기 좋은 사례이다. 2학기에 걸쳐 구현한 이 프로그램은 1-tier 구조에서 시작해서 3-tier로 진화시켰다. 아래는 프로그램 버전별 특성을 간략하게 정리한 것이다.\n v1.0  1-tier Program 로컬에서 실행되는 간단한 클라이언트 프로그램 수강신청 관련 데이터 파일을 담아서 불러오게 함. UI, 비즈니스 로직, 데이터 모두 한 곳에 있음   v2.0  2-tier Program 클라이언트 프로그램은 단순히 프레젠테이션 기능만 갖춤 서버 프로그램을 만들어서 클라이언트 요청 처리 클라이언트는 UI만을 표현, 서버에서 로직 및 데이터 처리   v2.1+  3-tier Program 데이터 파일을 MySQL DB로 마이그레이션 해당 DB는 aws-rds에 deploy 모든 기능이 물리적으로 분리된 구조    지금와서 되집어보니 작년에 프로젝트를 진행할 당시에는 해당 프로젝트가 가진 진가를 몰라봤었다고 생각한다. 교수님이 진행하는 수업에 따라 열심히 만들기는 했지만 그 안에 담긴 내용을 모두 이해하지는 못하고 있었다고나 할까? 1년 동안 진행한 프로젝트에 다층 구조의 진화과정이 있었다는 사실을 왜 진작에는 몰라봤을까..\n마치며 이번 포스팅을 통해서 배움이라는 것이 꼭 새로운 것을 아는 것만이 아니라는 것을 알게되었다. 이전에 진행한 프로젝트를 되집어보는 리뷰 과정도 충분히 의미있는 시간이 될 수 있다. 물론 처음 배울 때 모든 것을 깨달을 수만 있다면 그게 최선이겠지만 아쉽게도 나는 아직 그러지는 못하는 것 같다. 군대에 있는 시간동안 블로그에 글을 쓰며 이전에 배운 개념을 정리하고, 앞으로 새로 배울 내용도 정리하고자 한다.\n","description":"전공 수업 프로젝트에서 찾은 다층구조 아키텍처\n","id":4,"section":"posts","tags":["Software Architecture","n-tier-architecture"],"title":"N Tier Architecture","uri":"https://jeonghun-ban.github.io/posts/development/n-tier-architecture/"},{"content":"서론 최근 웹으로 접속하는 개발환경인 Web IDE가 활발하게 활용되고 있다. 대표적으로 Cloud9, Codeanywhere, 구름IDE 등이 있는데, 깃헙에서도 Codespace라는 이름으로 비슷한 서비스를 준비중에 있다. 나는 VSCode를 웹에서 바로 사용 가능하다는 점이 마음에 들어 미리보기를 신청했으나 아쉽게도 당첨되지 않았다..\n그래서 방법을 찾던 중 code-server이라는 오픈소스를 찾게 되었다. 해당 서비스는 VS Code를 웹 서버에서 동작할 수 있게 하는 프로젝트이다. MIT 라이선스로 제공되는 오픈 소스인 만큼 조건 없이 사용 가능하다는 것도 장점이다. 군대에서 제약없이 코딩하고자 하는 나에게 있어서 최고의 선택지였다.\n개발 환경 구축 서론이 길었던 것 만큼 설치과정이 길거라고 생각한다면 그것은 큰 착각이다. 설치는 매우 간단하다. 다른 블로그 글을 참고해서 설치해보기도 했지만, 여타 방법보다는 github repo에 나와있는 설치법이 더 쉽고 빠르게 할 수 있다.\n설치 및 실행 1 2  curl -fsSL https://code-server.dev/install.sh | sh sudo systemctl enable --now code-server@$USER # 시스템 부팅 시 자동실행 등록   위 코드를 실행하면 code-server를 설치하고 시스템 부팅 시 자동실행이 가능하도록 등록하는 과정까지 마치게 된다. 동시에 code-server는 이미 동작 중에 있겠지만 바로 사용할 수는 없는데, 이는 기본적으로 localhost(127.0.0.1)의 접속만 허용하기 때문이다. 따라서 외부에서 접속 가능하게 하는 설정이 필요하다.\n외부 접속 허용 및 비밀번호 설정 1  vi ~/.config/code-server/config.yaml   기본적으로 code-server의 설정 파일은 위 경로에 위치한 config.yaml 파일이다.\n1 2 3 4  bind-addr:0.0.0.0:8080auth:passwordpassword:#설정할 비밀번호 입력cert:false   bind-addr: 해당 서비스 주소 auth: 패스워드 설정 여부 password: 패스워드 지정 cert: 인증서 설정   bind-addr값을 127.0.0.1에서 0.0.0.0으로 변경하는 것은 외부에서 접속하는 것도 허용함을 의미한다.\n 1  sudo systemctl restart code-server@$USER   모든 설정이 완료되었다면 code-server를 재실행해준다. 이제 브라우저에서 ip-address:8080으로 접속할 수 있게 되었다. 포트 번호를 넣지 않고 주소만으로 접속하고 싶다면 아래도 이어서 따라와주길 바란다.\nNginx 구축 Nginx는 Apache와 같은 웹 서버 소프트웨어이다. 아파치가 이전에 많이 사용되었다면 최근 만들어지는 프로젝트의 다수는 Nginx로 구성하는 추세이다. 가벼우면서도 아차피보다 더 많은 프로세스를 감당할 수 있다는 장점도 있다.\n이 Nginx는 포워드 프록시라는 기능을 제공하는데 이를 활용하면 서버 ip주소만으로 서비스 포트가 8080인 code-server를 접속할 수 있다.\nbind-addr 초기화 1 2  vi ~/.config/code-server/config.yaml # bind-addr: 127.0.0.1:8080 sudo systemctl restart code-server@$USER   해당 과정을 위해서는 code-server의 bind-addr를 localhost로 다시 설정해주어야 한다.\nNginx 설치 1  sudo apt install -y nginx   /etc/nginx/sites-available/code-server 파일에 아래 설정 추가(sudo 권한) 1 2 3 4 5 6 7 8 9 10 11 12 13  server { listen 80; listen [::]:80; server_name mydomain.com; # 도메인이 있다면 변경  location / { proxy_pass http://localhost:8080/; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } }    80번 포트로 listen하고 해당 프록시를 localhost의 8080 포트로 pass하는 설정이다.\n 설정 적용 1 2 3  sudo rm /etc/nginx/sites-enabled/default sudo ln -s ../sites-available/code-server /etc/nginx/sites-enabled/code-server sudo systemctl reload nginx.service   설정이 제대로 적용되었다면 이후부터는 ip주소만으로 브라우저에서 code-server을 이용할 수 있게 된다.\n버전 업데이트 이 포스팅을 쓰는 도중에도 코드 서버는 v3.7.3에서 v3.7.4로 버전 업데이트가 이루어졌다. 몇 가지 버그 픽스와 기능 추가가 있는 작은 업데이트이었지만 code-server는 접속할 때마다 새로운 버전이 나왔음을 알려주었다. 버전을 업데이트하는 방법은 매우 간단하다.\n1  curl -fsSL https://code-server.dev/install.sh | sh   설치할 때 사용한 코드를 동일하게 실행해주면 바로 적용된다. 이렇게 지속적으로 빠르게 업데이트가 되는 것은 이 프로젝트가 오픈 소스이기 때문에 얻을 수 있는 큰 장점이다. 이렇게 좋은 개발환경을 무료로 자유로이 사용할 수 있다는 것에 감사하고 있다.\n추가적인 설정 이렇게 해서 개인 서버에 code-server를 설치해서 웹 브라우저를 통해 접속할 수 있는 환경을 만들어 보았다. 공식 문서에서는 추가적으로 Nginx 등을 활용하여 https 통신으로 암호화하는 것을 권장하는데, 자세한 내용은 여기를 통해 볼 수 있다. 해당 방법은 도메인네임이 있어야만 하므로 해당 비용을 감수하기 싫다면 굳이 진행하지 않아도 무관하다.\n","description":"나만의 웹 IDE 만들기\n","id":5,"section":"posts","tags":["code-server"],"title":"code-server를 이용해서 웹 IDE 구축하기","uri":"https://jeonghun-ban.github.io/posts/development/build-web-ide-using-code-server/"},{"content":"서론 최근 아니 이미 몇 년간 이어져온 트렌드는 Cloud이다. 어디서나 접속 가능한 컴퓨팅 자원 및 서비스를 제공하는 것인데, 이것이 가져오는 편의성은 어마어마하다. 우리는 더 이상 내가 가진 자원에 종속되지 않아도 됨을 의미하고, 어디에 있든 언제든지 간에 클라우드 자원에 접속하여 이전 작업을 이어갈 수 있다.\n실제로 클라우드의 수혜를 보는 것은 서비스를 사용하는 사용자보다도 개발자이다. 사용자 입장에서는 클라우드 서비스니 뭐니 해도 레거시한 서버와 차이를 느끼기 힘든 반면, 개발자 입장에서는 클라우드를 도입해서 서버 관리에 이점이 확실하기 때문이다.\n개발자에게 클라우드가 이로운 점이 이뿐만이 아니다. 개발서버를 구축하는 것은 개발환경에 있어서의 종속성을 벗어날 수 있게 해준다. 로컬에서 작업한 작업물은 다른 PC에서 이어서 작업하기 위해서 준비해야 할 것들이 사라진다. 물론 git으로 프로젝트를 관리한다고 하는 방법으로 해결할 수 있지 않느냐라는 질문이 있을 수 도 있겠다. 하지만 종속적인 환경들을 다른 PC에서 매번 준비한다는 것은 불편하다.\n 특히나 나와 같이 군대에서 코딩하려는 사람에게는 클라우드 환경 만큼이나 유용한 것은 없을 것이다.\n 대표적인 클라우드 제공업체로는 AWS(Amazon Web Service), MS Azure, GCP(Google Cloud Platform)이 있다. AWS는 1년간 매달 750시간 사용 가능한 리눅스 인스턴스를 제공하며, 애저 또한 무료 크레딧을 제공한다. 하지만 오늘 소개할 것은 평생 무료 인스턴스를 제공하는 GCP이다.\nGCP가 신규 회원에게 제공하는 혜택은 아래와 같다.\n1 2  - 평생 무료 이용 가능한 인스턴스 - 3달 동안 이용 가능한 $300 크레딧   인스턴스 생성 인스턴스 생성에 앞서 구글 클라우드 플랫폼(GCP)에 가입하자. 가입하는 과정은 그리 어렵지 않으니 따로 설명하진 않겠다. 회원가입이 되었다면 우선 아무런 이름이든 상관없으니 프로젝트를 생성한다. 이를 위해서 콘솔로 접속해서 진행한다.\n 앞에서의 과정이 모두 끝났다면 인스턴스를 생성해준다. 생성한 프로젝트에서 햄버거 메뉴를 눌러 Compute Engine-VM 인스턴스를 클릭해서 들어가주고, 위 사진에 보이는 플러스 버튼을 눌러 인스턴스 생성을 시작하자.\n 여기서 이름은 원하는 대로 지어주면 되고, 중요한 부분은 리전과 머신 구성 부분이다. 평생 무료 인스턴스를 만들기 위해서는 조건이 있는데, 우선 region을 us-east1-b를 사용해야 하고 머신 유형은 f1-micro를 사용해야 한다.\n 만약 제공되는 $300 크레딧 사용이 목적이라면 다른 리전과 머신 유형으로 구성하는 것을 추천한다. 평생 무료 인스턴스의 성능이 매우 낮기 때문이다.\n  이제 설정할 것은 부팅 디스크와 방화벽 설정뿐이다. 웹 서버로 이용할 서버를 구성하고 싶다면 HTTP, HTTPS를 허용을 해주어야만 한다.\n 부팅 디스크 설정의 변경 버튼을 눌러서 다른 OS를 선택할 수 있는데 나는 우분투를 선호해서 Ububtu 20.04 LTS를 선택했다. 참고로 디스크는 30GB까지가 무료로 제공되는 용량이다.\n이렇게까지 설정해서 만들기를 누르면 인스턴스가 생성되며, GCP에서 지원하는 web SSH 연결을 이용해서 쉽게 접속해서 이용할 수가 있다.\n","description":"나만의 평생 무료 인스턴스 만들기\n","id":6,"section":"posts","tags":["GCP","Cloud"],"title":"GCP 인스턴스 만들기","uri":"https://jeonghun-ban.github.io/posts/development/create-gcp-instance/"},{"content":"대한민국 국적의 신체 건강한 남성이라면 누구나 군대라는 곳을 원치 않더라도 와야만 한다. 사회에서 떨어진 곳에서 자신이 하던 일을 지속하지 못한다는 점은 개개인들에게 경력단절이라는 큰 손해로 이어진다. 특히 개발자라는 직업은 특성상 빠르게 변화하는 트랜드에 민감하게 반응하고 공부해야 하는 만큼, 이로 인한 좌절은 더더욱 클 수밖에 없다.\n군대에 오고 얼마 지나지 않았을 무렵에는 사지방 PC에 직접 개발환경을 설치하고 개발해보려고 했으나 아래와 같은 제약조건에 인해 이 방법은 몇 번 사용하다가 포기했다.\n1 2 3  - 육군 지침에서 `자료 통신 프로토콜(ftp, telnet)`을 금하고 있다. - 이는 오픈소스 개발에 필수적인 `git`도 엄연히 사용해선 안된다는 것을 의미한다. - 사지방 PC는 자동 로그오프 기능과 초기화로 인해 개발환경 유지가 안된다.   위 제약사항을 다시보자. http나 https 프로토콜으로 웹 사이트 접속하는 것에는 전혀 문제가 없다는 것을 알 수 있다. 그렇기 때문에 웹 브라우저를 통해 통신하는 것은 지침에 위반되지 않는다. 나는 여기에 해답이 있다고 생각했고, 군대에서 코딩을 하는 방법을 찾아냈다.\n웹 기반 개발환경을 구축하면 초기화되지 않는 개인 특화된 개발환경을 사용 가능하다!\n구글링을 통해 알아본 바로 군복무를 하는 동안 cloud9이나 구름ide 등을 이용한 개발자 분들이 몇몇 계셨다. 하지만 나는 Google Cloud Platform을 활용하여 개발 환경을 구축하였다. GCP는 기본 인스턴스에 한해서는 평생 무료로 제공하며, 3달 동안 사용 가능한 $300 크레딧을 제공한다. 최소 3개월 동안은 intel의 쿼드코어 CPU, 15GB의 램 메모리로 구성된 인스턴스를 계속 운용할 수 있는 크레딧이다. 웹/앱 개발에 있어서는 충분한 성능을 제공하는 서버를 구축할 수 있다.\n 이전에는 1년 간 사용가능한 $300 크레딧을 제공했으나 사용기간이 단축되었다.\n 앞으로 포스팅을 통해서 서버를 생성해 개발환경을 구축하는 방법을 소개하고자 한다. 준비해야 할 단계는 딱 두 개뿐이다. 서버를 생성하고 개발환경을 구성한다.\n 1편 GCP 인스턴스 만들기 2편 Code-Server로 웹 IDE 구축하기  서버가 꼭 GCP로 구성되어야 하는 것은 아니다. 개인 서버를 이용해도 좋고 다른 서비스를 이용해도 좋으나, 나는 이번에 GCP를 활용해보았고 그 방법을 정리해보게 되었다.\n","description":"군대에서 코딩을 어떻게 할 수 있을까? 그 답을 찾기 위한 여정\n","id":7,"section":"posts","tags":null,"title":"군대에서 코딩하기","uri":"https://jeonghun-ban.github.io/posts/development/coding-in-the-military/"}]