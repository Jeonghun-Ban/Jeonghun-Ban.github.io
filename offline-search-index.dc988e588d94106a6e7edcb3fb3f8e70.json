[{"body":"상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공\n 키트(Kit)라는 이름으로도 불린다.\n 동기 윈도우와 맥 OS의 사용자 인터페이스는 서로 다른 룩앤 필을 가지고 있다. 이로 인해 동일한 위젯(스크롤바, 버튼)라 할지라도 모양이 다르고 동작방식도 다르다. 개발한 응용프로그램이 서로 다른 운영체제에서의 이식성을 지니기 위해서는, 운영체제에서 제공하는 위젯을 직접 사용해서는 안된다.\n해당 문제는 추상 클래스인 AbstractFactory를 정의하는 것으로 해결한다. AbstractFactory에 기본 유저 인터페이스 요소(윈도우,스크롤바,버튼 등)를 생성할 수 있는 인터페이스를 정의한다. 그리고 실제적으로 생성되는 객체에 대해서는 AbstractProduct 인터페이스를 정의하고 이를 상속하는 서브클래스를 정의하여 서로 다른 운영체제에 이식성을 제공한다.\n구조 참여자  AbstractFactory: 개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의 ConcreteFactory: 구체적인 제품에 대한 객체를 생성하는 연산을 구현 AbstractProduct: 개념적 제품 객체에 대한 인터페이스를 정의 ConcreteProduct: 구체적으로 팩토리가 생성할 객체를 정의하고 AbstractProduct에서 정의한 인터페이스를 구현 Client: AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용  협력방법  일반적으로 ConcreteFactory 클래스의 인스턴스 한 개가 런타임에 생성된다. 이것은 특정 구현을 갖는 제품 객체를 생성한다. AbstractFactory는 필요한 제품 객체를 생성하는 책임을 ConcreteFactory 서브클래스에게 위임합니다  결과  구체적인 클래스 분리 제품군을 쉽게 대체할 수 있게 함 제품 사이에 일관성 증진 새로운 종류의 제품을 제공하기 어려움   해당 패턴을 사용했을 시 장단점\n 적용된 사례 자바 GUI 라이브러리인 Swing(AWT)의 룩 앤드 필 변경 기능이 대표적인 예시이다. 해당 기능으로 인해 Swing GUI로 짜인 자바 프로그램은 OS에 따라 적합한 인터페이스를 별도로 제공한다. 동일한 위젯이더라도 윈도우와 맥 OS에서 실행했을 시에 보이는 모양이 다르다.\n관련 패턴 AbstractFactory 클래스는 팩토리 메서드 패턴을 이용해서 구현되는데, Prototype 패턴을 이용할 때도 있다. 구체 팩토리는 Singleton 패턴을 이용해 구현하는 경우가 많다.\n참고문헌  Gof의 디자인 패턴 번역본 Department of Computer Science University of North Carolina 위키피디아 추상 팩토리 패턴  ","excerpt":"상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공\n 키 …","ref":"/til/design-patterns/creatinal-patterns/abstract-factory/","title":"추상 팩토리"},{"body":"허가되지 않은 자원의 사용과 허가되지 않은 방법을 통한 자원 사용을 제어하는 것\n절차 접근통제 3단계에 덛붙여 책임 추적성(부인 방지) 단계가 존재\n 식별  본인이 누구인지를 시스템에 밝히는 행위 ID, 계정번호, 메모리카드   인증  주체의 신원을 검증하기 위한 증명 패스워드, 스마트카드, 생채인증   인가  인증된 주체에게 접근을 허용하고 특정 업무를 수행할 권리를 부여 접근제어목록, 보안등급   책임추적성  시스템에 인가된 주체가 시스템에 어떤 행위를 하고 있는지 기록    요구 사항  입력의 신뢰성  접근 제어 시스템은 입력되는 사용자 정보를 신뢰할 수 있어야 한다.   최소 권한 부여  사용자가 작업을 수행하는데 최소한의 자원과 최소한의 접근만 부여한다. 사용자가 의도적 혹은 실수로 자원에 대해 입힐 수 있는 피해를 최소화시킨다. 알 필요성과 같은 의미   직무 분리  한 개인이 전체 업무를 파괴하는 사고를 방지하기 위해 시스템의 기능의 단계를 나누어야 함    ","excerpt":"허가되지 않은 자원의 사용과 허가되지 않은 방법을 통한 자원 사용을 제어하는 것\n절차 접근통제 3단계에 덛붙여 책임 추적성(부 …","ref":"/til/security/access-control/introduction/","title":"Access Control"},{"body":"복합 객체의 생성 과정과 표현방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴\n활용성  복합 객체의 생성 알고리즘이 객체를 합성하는 요소들과 이들의 조립 방법에 독립적일 때 합성할 객체들의 표현이 서로 다르더라도 생성 객체에서 이를 지원해야 할때  구조 참여자  Builder: Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스 ConcreteBuilder: Builder 클래스에서 정의한 인터페이스를 구현하고, 제품의 부품들을 모아 빌더를 복합함 Director: Builder 인터페이스를 사용하는 객체를 합성 Product: 생성할 복합 객체  협력 방법  사용자는 Director 객체를 생성하고, 이렇게 생성된 객체를 자신이 원하는 Builder 객체로 합성 제품의 일부가 구축될 때마다 Director는 Builder에게 통보 Builder는 Director의 요청을 처리하여 제품에 부품을 추가 사용자는 Builder에서 제품을 검색  결과  제품에 대한 내부 표현을 다양하게 변화 생성과 표현에 필요한 코드를 분리 복합 객체를 생성하는 절차를 보다 세밀화  관련 패턴 복잡한 객체를 생성해야 할 때 추상 팩토리 패턴은 빌더 패턴과 비슷하다. 빌더 패턴은 복잡한 객체의 단계별 생성에 중점을 둔다면, 추상 팩토리 패턴은 유사군들에 대한 유연한 설계가 중점이다. 빌더 패턴은 생성의 마지막 단계에서 생성한 제품을 반환하는 반면, 추상 팩토리 패턴에서는 만드는 즉시 제품을 반환한다는 차이도 있다.\n참고 문헌  Gof의 디자인 패턴 번역본 Department of Computer Science University of North Carolina  ","excerpt":"복합 객체의 생성 과정과 표현방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴\n활용성  복 …","ref":"/til/design-patterns/creatinal-patterns/builder/","title":"빌더"},{"body":"연결 모드 능동 모드 제어 포트(TCP/21) / 데이터 전송(TCP/20)\n 클라이언트는 서버의 21번 포트로 연결(제어채널 생성) 사용자가 파일 목록을 불러오는 명령(ls)을 입력 클라이언트는 임시 포트(1024 이상)를 결정하여 서버에게 전달 (PORT 명령) 서버는 클라이언트가 알려준 포트로 연결을 설정(데이터채널 생성) 데이터채널을 통해 데이터를 송신한 후 연결 종료   FTP 클라이언트의 기본 모드\n 수동 모드 제어 포트(TCP/21) / 데이터 전송(TCP/1024~)\n 클라이언트는 서버의 21번 포트로 연결(제어채널 생성) 사용자가 파일 목록을 불러오는 명령(ls)을 입력 클라이언트는 수동모드로 연결하기 위해 PASV 명령을 전송 서버는 임시 포트(1024 이상)를 결정하여 클라이언트에게 전달 클라이언트는 서버가 알려준 포트로 연결을 설정(데이터채널 생성) 데이터채널을 통해 데이터를 송신한 후 연결 종료  종류 익명 FTP(Anonymous FTP) 서버에 계정이 없는 사용자가 서버자원에 한정된 접근이 가능하도록 권한을 제공\n ID: anonymous, PW: email_address 로 로그인 비밀번호는 서버 로그에 기록하기 위한 용도  TFTP(Trivial File Transfer Protocol) 오직 기본적인 IP와 UDP만을 필요로 하는 FTP (포트 : UDP/69)\n 보안 기능이 없음 FTP와의 차이  전송  프로토콜 차이 TFTP는 부스트래핑 시 자주 사용   한정된 개수의 명령  파일 전송만 가능   한정된 데이터 표현 방식  FTP가 지원하는 데이터 표현 방식을 전부 지원하지 않음   인증의 부재    보안 위협 및 대책 FTP 보안 비밀번호, 데이터 전송이 평문이므로 공격자에게 노출 가능성이 있으므로 아래와 같은 프로토콜 사용이 권장된다.\n SFTP(SCP)  SSH기반 파일 전송 프로토콜(TCP/22)   FTPS  SSL/TLS 기반 파일 전송 프로토콜(TCP/990) FTP 응용계층, TCP 계층사이에 보안소켓을 추가하는 형식    TFTP 보안 중요하지 않은 파일에만 접근할 수 있도록 제한하거나 TFTP 서버 근처에 있는 라우터에 보안을 구현하여, 특정 호스트만 서버에 접근하도록 해야 한다.\n보안 대책  secure mode로 운영 지정 디렉터리를 루트 디렉터리로 지정하여 상위 디렉터리로 접근을 제한  익명 FTP 보안 익명 사용자에게 쓰기 권한이 있을 경우 악성코드 생성이 가능\n보안 대책 중요 디렉터리(/bin, /etc 등)의 소유자와 권한(permission)을 관리하거나 사용을 금지\nBounce attack FTP 서버가 데이터를 전송할 때 목적지를 검사하지 않는 문제점을 이용한 공격\n 능동모드에서 PORT 명령어로 공격자는 원하는 곳으로 데이터 전송 가늩  보안 대책  FTP 규약을 어느 정도 제한  다른 서비스가 20번 포트 접속을 요청하면 거절   익명 FTP 서버의 경우 임시적으로 ./incoming에 파일 업로드 제한  서비스 운영 proftpd  보안과 기능의 중점을 둔 FTP 데몬 매우 빠르고 안정적 xinetd / standalone 형태로 동작가능  FTP 접속 시 확인 설정  /etc/passwd, /etc/shadow에 사용자 계정이 있는지 검사 /etc/ftpusers에 사용자 id가 있으면 거부 /etc/shell에 등록되지 않는 쉘을 사용하는 유저는 거부  설정 파일 옵션    옵션 설명     ServerType type 서버 타입 설정(xinetd / standalone)   RootLogin on/off 루트 계정 로그인 허용/거부   user name 익명 접속할 경우 사용자를 name으로 인식   MaxClients num 최대 접속 허용   TimeoutLogin second 클라이언트가 인증을 유지할 수 있는 시간   TimeoutIdleftp second 접속 후 아무런 작업도 없는 상태 유지 시간   TimeoutSession second second초 후에 무조건 접속 종료    vsftpd(Very Secure FTP Daemon)  가상 IP별 별도의 환경 설정 기능 가상 사용자 설정 전송 대역폭 지정 PAM 지원 상세 자체 로그 파일 형식을 지원 xinetd / standalone 형태로 작동 가능  ","excerpt":"연결 모드 능동 모드 제어 포트(TCP/21) / 데이터 전송(TCP/20)\n 클라이언트는 서버의 21번 포트로 연결( …","ref":"/til/security/application/ftp/","title":"FTP"},{"body":"WSL?  기존에 Windows의 미흡한 개발환경을 보완하고자 등장 Windows 상에서 Linux 커널 및 앱을 실행할 수 있게 됨. 이러한 시스템을 Windows Subsystem for Linux 혹은 WSL이라 함.  Windows 10에서 리눅스 서브시스템 사용하기 WSL 활성화   관리자 권한으로 Windows PowerShell 실행\n  다음과 같은 명령어를 실행\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n  Linux 설치  Microsoft Store에서 Linux 검색 후 Ubuntu 설치 설치된 Ubuntu 앱 실행  기본 설정하기   User의 ID 및 PW 설정\nEnter new UNIX username: #원하는 사용자명 Enter new UNIX password: Retype new UNIX password:   WSL 배포판의 패키지 업데이트\n$ sudo apt-get update $ sudo apt full-upgrade   ","excerpt":"WSL?  기존에 Windows의 미흡한 개발환경을 보완하고자 등장 Windows 상에서 Linux 커널 및 앱을 실행할 수  …","ref":"/til/wsl/installation/","title":"Installation"},{"body":"ZSH(Z Shell)은 강력한 자동완성 기능을 제공하는 bash보다 개선된 쉘이다. 그렇기 때문에 개발하는 데 있어서 명령어를 모두 외우지 않아도 된다는 점에서 사용자에게 큰 편의성을 제공한다. 그래서 인지 macOS Catalina에서는 기본 쉘로 zsh이 채택되기도 했다.\nzsh 설치 $ sudo apt-get install zsh # 기본 쉘을 zsh로 변경 $ chsh -s /usr/bin/zsh 혹시라도 아래와 같은 메시지가 나오면 2번을 선택해주면 된다.\nThis is the Z Shell configuration function for new users, zsh-newuser-install. You are seeing this message because you have no zsh startup files (the files .zshenv, .zprofile, .zshrc, .zlogin in the directory ~). This function can help you with a few settings that should make your use of the shell easier. You can: (q) Quit and do nothing. The function will be run again next time. (0) Exit, creating the file ~/.zshrc containing just a comment. That will prevent this function being run again. (1) Continue to the main menu. (2) Populate your ~/.zshrc with the configuration recommended by the system administrator and exit (you will need to edit the file by hand, if so desired). oh-my-zsh 설치 oh-my-zsh는 zsh에 여러가지 플러그인을 추가하여 커스터마이징할 수 있도록 하는 플러그인이다. 설치하는 방법은 아래와 같다.\n$ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 테마 적용 oh-my-zsh의 기본 테마는 robbyrussell로 되어 있으나 agnoster라는 더 이쁜 테마를 사용할 수도 있다. 적용 방법은 이와 같다.\n$ sudo vi ~/.zshrc ZSH_THEME = \"agnoster\" # 해당 부분만 변경 후 저장","excerpt":"ZSH(Z Shell)은 강력한 자동완성 기능을 제공하는 bash보다 개선된 쉘이다. 그렇기 때문에 개발하는 데 있어서 명령어 …","ref":"/til/zsh/installation/","title":"Installation"},{"body":"CSS3 개요 정의  HTML 문서의 색이나 모양 등 외관을 꾸미는 언어 CSS로 작성된 코드를 스타일 시트(Style Sheet)라 함 Cascading Style Sheet의 현재 버전: CSS3  구성  셀렉터  CSS3 스타일 시트를 HTML 페이지에 적용하도록 만든 이름   프로퍼티  스타일 속성 이름, 약 200개 정도의 프로퍼티가 존재   값  프로퍼티의 값   주석문  스타일 시트 내에 붙이는 설명문 /* ... /* 여러 줄, 아무 위치나 사용 가능   대소문자 구분 없음  사용  \u003cstyle\u003e태그에 스타일 시트 작성 style 속성에 스타일 시트 작성 스타일 시트를 별도 파일로 작성  \u003clink\u003e태그나 @import로 불러와 사용    style 태그 \u003chead\u003e \u003cstyle\u003e body{background-color: mistynose; } h3 { color: purple; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e style 태그로 스타일 적용하기\u003c/h3\u003e \u003c/body\u003e style 속성 \u003cp style = \"color : magenta; font-size: 30px\"\u003e style 속성으로 스타일 적용하기 \u003c/p\u003e\" CSS 파일  style 태그를 사용하지 않고 CSS 파일에 작성하고 저장하여 불러올 수 있음. CSS를 불러오는 데에는 link 태그 또는 @import를 사용할 수 있음  \u003chead\u003e \u003clink href=\"style.css\" type=\"text/css\" rel=\"stylesheet\"\u003e @import url(\"style.css\"); @import 'style.css'; \u003c/head\u003e  @import는 두 가지 방식으로 사용가능 작은 따옴표, 큰 따옴표 모두 가능\n CSS3 규칙 스타일 상속 부모 태그로부터 상속\n 부모태그: 자신을 둘러싸는 태그\n 스타일 합치기 태그에 적용되는 모든 스타일이 합쳐짐\n오버라이딩 동일한 태그 상의 스타일에서 순위가 높은 스타일이 우선 적용됨.\n스타일 적용 우선순위  style 속성에 선언된 스타일 \u003cstyle\u003e 태그에 선언된 스타일 .css 스타일 시트 파일에 선언된 스타일 브라우저의 디폴트 스타일  CSS 색 표현 방법  16진수  ex) #8A2BE2   10진수코드와 rgb()  ex) rgb(138,43,226)   색 이름  CSS3 표준에서는 140개의 색 이름이 지정되어 있음.    관련 프로퍼티 color : 색 background-color: 색 border-color: 색 텍스트 프로퍼티 text-indent : \u003clength\u003e|\u003cpercentage\u003e; /* 들여쓰기 */\rtext-align : left|right|center|justify /* 정렬 */\rtext-decoration none|underline|overline|line-through: /* 라인 */\r폰트 CSS3의 폰트와 모양\n font-family  font-family: Arial, \"Times New Roman\", Selif:\r font-size  font-size: 40px;\r font 프로퍼티  font: italic bold 40px consolas, sans-selif;\r/* font: font-style font-weight font-size font-family */\rCSS3의 표준 길이 단위    단위 의미     em 배수   % 퍼센트   px 픽셀 수   cm 센티미터   mm 밀리미터   in 인치     HTML5에서는 단위를 사용하지 않으면 CSS 스타일 오류\n ","excerpt":"CSS3 개요 정의  HTML 문서의 색이나 모양 등 외관을 꾸미는 언어 CSS로 작성된 코드를 스타일 시트(Style …","ref":"/til/css/introduction/","title":"Introduction"},{"body":"디자인 패턴이란? 객체지향프로그래밍(OOP)을 하는 데 있어서 재사용성을 높이는 것은 중요하지만 어려운 과제이다. 이를 위해서는 적절한 객체와 클래스, 인터페이스를 정의하고 관계를 설정해야만 하는데, 여기서 디자인 패턴의 필요성이 드러난다.\n전문가들은 다양한 문제들을 접하며 찾은 해결책들이 집약된 것이 바로 현재 객체지향설계에 사용되는 디자인 패턴이다. 따라서 이러한 패턴을 익히는 것은 이미 여러 차례에 걸쳐 검증된 방식을 효율적으로 사용하기 위해 꼭 필요한 과정이다.\n디자인 패턴 요소 일반적으로 하나의 패턴에는 아래와 같은 요소를 포함한다.\n 패턴 이름: 디자인패턴을 설명하는 단어 문제: 해결할 문제와 그 배경을 설명 해법: 설계 구성요소 간의 관계, 책임, 협력 관계 결과: 디자인 패턴을 적용해서 얻는 결과와 장단점  디자인 패턴 카탈로그 GoF의 디자인 패턴에서는 총 23가지 종류의 패턴이 있다고 소개한다. 여기서는 간단히 이러한 종류가 있구나 하고 넘어가도록 하고, 이후 TIL에서 자세히 정리하도록 하겠다.\n분류 기준 == ‘목적’ GoF가 말하는 디자인 패턴을 나누는 두 가지 기준 중 첫번째는 목적이다.\n생성 패턴 인스턴스를 만드는 과정을 추상화\n 추상 팩토리: 구체적인 클래스를 지정하지 않고 객체들의 집합을 생성하는 인터페이스를 제공. 빌더: 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 다른 결과를 만들 수 있게 함. 팩토리 메서드: 객체를 생성하는 인터페이스는 미리 정의하되 인스턴스를 만들 클래스는 서브클래스에서 결정. 원형: 생성할 객체의 종류를 명세하는 데 원형을 정의하고, 이를 복사함으로써 새로운 객체를 생성. 단일체: 클래스의 인스턴스가 하나임을 보장하고, 이 객체에 접근할 수 있는 전역적인 접촉점을 제공.  구조 패턴 클래스나 객체의 합성\n 적응자: 클래스의 인터페이스를 사용자가 기대하는 것으로 변환하여 호환성을 해결. 가교: 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 함. 복합체: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현. 장식자: 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴. 퍼사드: 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공. 플라이급: 크기가 작은 객체가 여럿 있을 때, 공유를 통해 이들을 효율적으로 지원. 프록시: 객체로 접근하는 것을 통제하기 위해서 대리자 또는 자리채움자를 제공.  행동 패턴 클래스나 객체의 상호작용\n 책임 연쇄: 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 주고받는 객체 사이의 결합을 피함. 명령: 요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장, 로깅, 연산 취소 지원. 해석자: 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의. 해당 문서를 해석하는 해석기 정의. 반복자: 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차 접근. 중재자: 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체 정의. 메멘토: 캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 되돌아올 수 있도록 함. 감시자: 객체들 사이에 일대다 의존 관계를 정의하여, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신할 수 있게 함. 상태: 객체 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가. 전략: 동일 계열 알고리즘군을 정의하고 각각의 알고리즘을 캡슐화하여 이들을 상호 교환이 가능하도록 만드는 패턴. 템플릿 메서드: 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리를 서브클래스 쪽으로 미룸. 방문자: 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴.  분류 기준 == ‘범위’ 두 번째 분류 기준인 범위는 패턴을 클래스에 적용하는지 아니면 객체에 적용하는지를 구분하는 것이다.\n   구분 생성 구조 행동     클래스 팩토리 메서드 적응자(class) 해석자템플릿 메서드   객체 추상 팩토리빌더원형단일체 적응자(object)가교복합체장식자퍼사드플라이급프록시 책임 연쇄명령해석자중재자메멘토감시자상태전략방문자     클래스 패턴  클래스와 서브클래스 간의 관련성을 다루는 패턴 관련성은 주로 상속을 말함 컴파일 타임에 정적   객체 패턴  객체 관련성을 다룸 런타임에 동적    디자인 패턴 관계도 위 관계도는 디자인 패턴 간에 존재하는 참조 관계를 나타낸 것이다. 각 패턴을 따로 익히는 것도 중요하지만 각각의 패턴이 어떤 관계를 맺고 있는 지 확인하면서 공부하는 것이 도움이 될 것이다.\n참조문헌  Gof의 디자인 패턴 번역본 https://www.cs.unc.edu/~stotts/GOF/hires/contfso.htm  ","excerpt":"디자인 패턴이란? 객체지향프로그래밍(OOP)을 하는 데 있어서 재사용성을 높이는 것은 중요하지만 어려운 과제이다. 이를 위해서 …","ref":"/til/design-patterns/introduction/","title":"서론"},{"body":"HTML 언어의 역사  1990년 물리학자인 Tim Berners-Lee가 정의 표준화된 태그로 웹 페이지를 작성하는 언어 HTML, CSS, JavaScripts, 웹 브라우저의 타임라인  HTML5 출현 배경   비표준 기술의 혼재, 웹 브라우저의 비호환성\n  Active-X나 플러그인, 플래시 등 비표준 기술 난립\n  브라우저 사이에 HTML문서와 웹 자원에 대한 심각한 비호환성\n    인터넷 기기의 다양화\n  PC, 모바일 단말기 등에서 모두 웹 사용\n  기존의 웹 페이지가 모바일에서 작동하지 않음\n    새로운 범용 웹 표준의 필요성\n HTML5 탄생    HTMl5 표준과 의의 HTML5 표준 제정   W3C와 하이퍼텍스트 워킹 그룹\n  표준에 담긴 내용\n 웹 페이지의 구조는 HTML5 태그로, 웹 페이지의 모양은 CSS3로, 웹 페이지의 행동은 JavaScript로 분리 개발    HTML태그에서 문서의 모양과 관계된 태그나 속성 파기\n  웹 페이지의 플랫폼이나 장치 의존성 제거\n  HTML5의 기능 HTML5이 전체 기능  웹 문서 작성을 위한 HTML 태그셋  문서 모양을 표현하는 태그 속성 청산 구조를 명확히 표현하는 시맨틱 태그 추가   웹 애플리케이션 작성을 위한 자바스크립트 API 표준화  HTML5 기능 요약  웹 폼 오디오, 비디오 캔버스 - 자바스크립트 사용 웹브라우저 상 동적 2, 3차원 그래픽 SVG - XML로 표현하는 2차원 벡터 그래픽 API 웹 스토리지 - 웹 브라우저 실행 로컬 컴퓨터에 데이터 저장 API 웹 SQL 데이터베이스 인덱스 데이터베이스 파일 입출력 웹 워커 - 백그라운드 작업 만들 수 있는 API 웹 소켓 - 웹 브라우저에서 실행되는 웹 앱이 웹 서버 응용프로그램과 통신 지원 API 오프라인 웹 애플리케이션 - 캐시이용 오프라인에서 웹 앱이 실행될 수 있도록 지원 API  HTML5 문서 편집 HTML5 문서 편집기  텍스트 편집기  메모장 좋은 편집기 Atom, Eclipse, Text 등 .html인 텍스트 파일로 저장 텍스트의 기본 문자셋 - UTF-8 HTML 파일이나 CSS, JS 파일 모두 UTF-8로 저장되어야 함   WYSIWYG 편집기  어도비의 Dreamweaver 등 HTML5 태그 정보 제공    유효성 검사 HTML5 유효성 검사\nCSS 유효성 검사\nHTML 페이지 기본 HTML5 페이지 기본 구조 \u003c!DOCTYPE html\u003e \u003chtml lang=\"ko\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e HTML5 페이지 필수 태그 \u003c!DOCTYPE HTML\u003e \u003c!-- HTML5임을 지정 --\u003e \u003chead\u003e \u003c!-- 문서의 메타데이터 정의 --\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 문서 내용 작성--\u003e \u003c/body\u003e HTML 태그의 특징 HTML 태그의 구성  시작태그와 종료태그가 모두 있는 경우 시작태그만 있는 경우 태그와 속성은 대소문자 구분 없음 속성 값에 불필요한 공백 문자, HTML5 표준에 어긋남  문자, 기호, 심볼 입력  HTML5의 문자: 유니코드 문자셋, UTF-8 코드 체계 예약어: \u0026entity;, \u0026#code; 시맨틱 웹의 철학: 시맨틱 태그 상에 의미를 부여\u003cb\u003e, \u003cstrong\u003e, \u003ci\u003e, \u003cem\u003e와 같이 동일하게 표시되지만 의미가 다른 태그가 있음  블록 태그와 인라인 태그   태그: 블록 태그와 인라인 태그로 구분\n  블록 태그: \u003cp\u003e, \u003ch1\u003e, \u003cdiv\u003e, \u003cul\u003e\n  인라인 태그: \u003cstrong\u003e, \u003ca\u003e, \u003cimg\u003e, \u003cspan\u003e\n    블록 태그\n 항상 새 라인에서 시작하여 출력 양 옆에 다른 콘텐트를 배치하지 않고 한 라인 독점 사용 가장 많이 사용하는 블록 태그: \u003cdiv\u003e 블록 전체에 동일한 CSS 스타일을 적용 혹은 자바 스클립트로 블록을 하나의 단위처럼 다루고자 할 때    인라인 태그\n 블록 속에 삽입되어 블록의 일부로 출력 가장 많이 사용되는 인라인 태그: \u003cspan\u003e    ","excerpt":"HTML 언어의 역사  1990년 물리학자인 Tim Berners-Lee …","ref":"/til/html5/introduction/","title":"Introduction"},{"body":"개요 JavaScript  1995년 넷스케이프 개발 Netscape Navigator 2.0 브라우저에 최초 탑재 웹 프로그래밍 개념 창시  특징  HTML 문서에 내장 조각 소스 코드 스크립트 언어 인터프리터 실행 컴파일 필요 없음 단순함 C언어 구조 차용 배우기 쉬움  웹페이지에서의 역할  사용자의 입력 및 계산  마우스와 키보드 입력은 오직 자바스크립트로만 가능 계산 기능   웹 페이지 내용 및 모양의 동적 제어  HTML 태그의 속성, 콘텐츠, CSS 프로퍼티 값 동적 변경   브라우저 제어  브라우저 윈도우 크기와 모양 제어 새 윈도우 열기 / 닫기 다른 웹 사이트 접속 브라우저 히스토리 제어   웹 서버와의 통신 웹 애플리케이션 작성  캔버스 그래픽, 로컬/세션 스토리지 저장, 위치정보서비스 등    자바스크립트 코드의 위치 HTML 태그의 이벤트 리스너 속성에 작성 \u003cimg src=\"apple.png\" alt=\"img\" onclick=\"this.src='banana.png'\"\u003e script 태그에 작성  \u003chead\u003e나 \u003cbody\u003e 태그 내 어디든 사용 가능 웹 페이지 내에 \u003cscript\u003e 태그 여러번 삽입 가능  자바스크립트 파일에 작성  확장자 .js 파일에 저장 여러 웹페이지에서 불러 사용  \u003cscript src=“파일이름.js”\u003e\u003c/script\u003e URL 부분에 작성 \u003ca href=\"javascript:alert('클릭하셨어요?')\"\u003e 클릭해보세요\u003c/a\u003e 이벤트와 이벤트-리스너 이벤트  사용자의 입력 행위를 브라우저가 웹페이지에 전달하는 수단 사용자가 HTML태그에 출력된 영역에 키를 입력하거나 마우스 클릭하면 발생, 해당 HTML태그에 전달 click, change, mousemove 등 여러 종류  이벤트 리스너  이벤트를 처리하는 자바스크립트 코드 onclick, onchange, onmousemove와 같이 on을 붙인 이름이 HTML태그의 이벤트 리스너 속성으로 사용, 이 속성에 자바스크립트 코드를 작성함  HTML 콘텐츠 출력 자바 스크립트로 HTML 콘텐츠를 웹 페이지에 직접 삽입\n document.write() document.writeln() \u003e writeln()은 텍스트에 ‘\\n＇을 덧붙여 출력  \u003cscript\u003e document.write(\"\u003ch3\u003eWelcome!\u003c/h3\u003e\"); document.write(\"2 + 5 는\u003cbr\u003e\"); document.write(\"\u003cmark\u003e7 입니다.\u003c/mark\u003e\"); \u003c/script\u003e 다이얼로그 프롬프트 사용자로부터 문자열을 입력 받아 리턴\nprompt(\"메시지\", \"디폴트입력값\"); 확인 메시지를 출력하고 확인/최소(OK/CANCEL) 버튼을 가진 다이얼로그 출력\nconfirm(\"메시지\");  확인 버튼을 누르면 true, 취소 버튼이나 강제로 다이얼로그를 닫으면 false 리턴\n 경고 메시지 와 확인 버튼을 가진 다이얼로그 출력\nalert(\"메시지\"); ","excerpt":"개요 JavaScript  1995년 넷스케이프 개발 Netscape Navigator 2.0 브라우저에 최초 탑재 웹 프로그 …","ref":"/til/javascript/introduction/","title":"Introduction"},{"body":"리눅스의 특징   다중 사용자 및 다중 처리 시스템\n Multi-User Multi-task    완전히 공개된 시스템\n kernel, application이 공개됨.    뛰어난 네트워크 환경\n 대부분의 네트워크 프로토콜 지원    다양한 파일 시스템 지원\n  뛰어난 이식성\n Linux는 어셈블리어와 대부분의 C언어로 짜여짐. 어셈블리어로 짜여진 부분만 수정하면 쉽게 이식 가능    유연성과 확장성\n UNIX의 특징 상속, 유닉스 표준(POSIX) 준수. 따라서 UNIX 앱 쉽게 컴파일 가능 특정 H/W에서만 동작하는 UNIX와 달리 커널 소스가 공개되어 다양한 H/W지원이 존재.    뛰어난 안정성과 보안성\n 공개용 S/W를 지지하는 프로그래머들이 오류 수정과 보안 패치를 빠르게 발표.    우수한 가성비\n  다양한 응용프로그램의 제공\n Shell, 기본 명령어 X Window 시스템(GUI) 편집기(vi, emaxs) 서버 및 클라이언트 프로그램 개발도구, 보안도구    다양한 배포판\n  리눅스의 단점  기술지원의 부족 특정 하드웨어에 대한 지원 부족 사용자의 숙련된 기술 요구  여전히 중요한 설정은 명령어를 입력해야 함 관련 환경 설정 파일은 vi와 같은 편집기를 사용    리눅스의 기술적인 특징  계층적인 파일 구조  /root를 기준으로 하위 디렉터리가 존재(usr, var, bin 등) 트리 구조라고도 함   장치의 파일화  H/W 자원을 모두 파일화하여 관리 H/W 장치를 사용하기 위해 해당 파일에 명령을 내림.   가상메모리 사용  메모리 상에 올라와 있는 프로그램을 보조 기억장치에 옮기고 새로운 프로그램을 실행하는 것은 스왑핑이라 함. 스왑을 확인하는 명령어: $ free -m옵션을 사용하면 MB단위로 확인 가능   동적 라이브러리 지원  라이브러리: 프로그램에서 특정 기능을 하는 루틴들을 모아다 놓은 것 실행 파일마다 루틴을 끌어다 쓰는 것은 비효율적임. 공유 라이브러리: 공통되는 루틴을 공유 동적 공유 라이브러리: 프로그램 실행시 라이브러리를 참조   가상 콘솔  하나의 모니터에서 여러 개의 가상화면 제공(6개) [CTRL]+[ALT]+[F1~F6]   파이프  프로세스 통신을 위해 도입 | 기호를 사용 여러 개를 사용해서 파이프라인을 구성예) $ ls | more   리다이렉션  어떤 프로세스의 입/출력을 표준 이외의 것으로 지정할 때 사용.  입출력 표준: 입력(키보드), 출력(모니터)   출력 결과를 파일로 저장하거나 파일 내용을 프로세스 입력으로 사용하는 기법 종류  \u003e: 프로세스 출력을 표준이 아닌 것으로 변경 \u003e\u003e: 프로세스 출력을 지정한 출력(파일)에 추가 \u003c: 프로세스 입력을 표준이 아닌 것으로 변경      리눅스 디렉토리 종류  /: 최상위에 있는 디렉토리로 루트(root) 디렉토리라 함. /bin: ‘binary’의 약자로 명령어들이 담겨 있음. /boot: 부팅시 사용, grub도 여기에 있음. /dev: H/W 장치를 파일화하여 관리 /etc: 시스템 환경 설정 파일 및 부팅과 관련된 여러 스크립트 파일 /home: 개인 사용자들이 사용하는 파일이나 디렉터리 /lib: 각종 라이브러리, 커널 모듈도 여기에 있음. host+found: fsck 명령어로 파일 시스템 복구 시 사용, RHEL 7버전부터 미지원 mnt: 하드디스크를 비롯한 저장장치를 마운트 /misc: 자동 마운트 프로그램(autofs)에 의해 생성 /opt: 응용프로그램 설치에 사용 /proc: 가상 파일 시스템으로 운영되는 다양한 프로세스 상태, H/W, 기타 시스템 정보 /root: 시스템관리자인 root사용자의 홈 디렉토리 /sbin: ‘System Binary’의 약자로 주로 시스템 관리에 대한 명령어들이 담겨 있음. /tmp: 임시 저장 디렉토리, 각종 프로그램이나 소켓 파일, 프로세스 작업 시 임시 파일 /usr: 시스템 운영에 필요한 명령, 응용프로그램이 위치(커널소스, 개발도구 등) /var: 시스템 운영 로그 파일과 스풀링과 같은 가변 데이터 보관  리눅스 배포판 초기 리눅스는 커널만을 지칭했으나, 리눅스 커널과 GNU 프로젝트의 라이브러리와 도구들이 포함되면서 OS로 발전되었다. 이렇게 탄생한 OS를 GNU/Linux라 한다. 리눅스 배포판은 리눅스 커널과 GNU 정신을 바탕으로 만들어진 다양한 자유소프트웨어와 공개프로그램으로 구성된 OS이다. 누구나 패키징하여 자유롭게 배포가 가능하기 때문에 다양한 버전이 존재한다.\n최초의 리눅스 배포판 1992년 피터 맥도널드에 의해 만들어진 소프트랜딩 리눅스 시스템이 최초의 배포판이다. 리눅스 커널과 GNU 프로그램, 기본적인 유틸리티, X 윈도 시스템을 갖추고 있었다. 당시 인기있는 배포판이었지만, 사용자에 의해 버그가 존재함이 알려졌다. 이는 새로운 리눅스 배포판이 등장하게 되는 계기가 되었다.\n주요 리눅스 배포판  슬랙웨어(Slackware) 데비안(Debian) 레드핫(Red Hat) 수세(SUSE) 우분투(Ubuntu)  리눅스 등장 계기  GNU: GNU is Not UNIX의 약어로 UNIX와 호환되면서 더 강력한 운영체제를 만들고자 하는 프로젝트 FSF(Free Software Foundation): 리처드 스톨먼이 설립한 자유 소프트웨어 재단  자유 소프트웨어 목적에 상관없이 프로그램을 실행시킬 수 있는 자유 프로그램이 어떻게 동작하는 지 학습하고, 필요에 따라서 프로그램을 개작할 수 있는 자유 무료 혹은 유료로프로그램을 재배포할 수 있는 자유 프로그램을 개선시킬 수 있는 자유와 개선된 이점을 공동체 전체가 누릴 수 있는 자유   GNU GPL(General Public License)  Copyleft: 자유소프트웨어를 의미, S/W를 개인의 소유에 두지만 자유로운 상태를 유지 리처드 스톨만은 관련 라이선스를 GNU GPL로 명명    ","excerpt":"리눅스의 특징   다중 사용자 및 다중 처리 시스템\n Multi-User Multi-task …","ref":"/til/linux/linux-master/introduction/","title":"Introduction"},{"body":"파이썬이 설치되어 있지 않다면 우선 이 링크에 접속하여 설치한다.\n 맥이나 리눅스의 경우 Python2는 기본적으로 설치되어 있고, 우분투와 같은 경우에는 Python3 또한 설치되어 있다.\n 파이썬을 간단히 살펴보기 위해서 이 교안에서는 프롬프트를 사용할 것이다. shell(cmd나 bash)을 실행하여 python 명령어로 파이썬 프롬프트를 실행할 수 있다.\n 맥이나 리눅스는 python3 명령어를 사용해야 한다.\n 윈도우의 경우 파이썬 shell, 맥의 경우 IDLE를 사용하여도 된다.\n아래와 같이 실행이 되면, 파이썬을 사용할 준비가 된 것이다.\n$ python3 Python 3.8.0 (v3.8.0:fa919fdf25, Oct 14 2019, 10:23:27) [Clang 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e 기본문법 들여쓰기 다른 프로그래밍 언어와 달리 파이썬에서 들여쓰기는 매우 중요하다. 들여쓰기를 잘못 사용하면 코드 문법상 오류가 날 수 있으므로 주의해야 한다!\n주석 파이썬에서는 #을 사용해서 주석처리를 할 수 있다.\n\u003e\u003e\u003e print('Hello World') #문자열을 출력하는 함수 Hello World 세미콜론 파이썬은 기본적으로 세미콜론을 입력하지 않는 언어이다. C언어나 자바가 문장의 구분을 세미콜론을 사용하는 반면 파이썬을 문장 구분을 들여쓰기와 같은 공백으로 인식하기 때문이다.\n 세미콜론을 사용해도 에러가 나지는 않지만 굳이 사용할 필요가 없다.\n ","excerpt":"파이썬이 설치되어 있지 않다면 우선 이 링크에 접속하여 설치한다.\n 맥이나 리눅스의 경우 Python2는 기본적으로 설치되어  …","ref":"/til/python/study/introduction/","title":"Introduction"},{"body":"암호화할 때 사용되는 키와 복호화할 때 사용하는 키가 서로 다른 암호 알고리즘\n키 배송 문제 대칭키 암호를 사용하기 위해서는 키 배송 문제가 발생함.\n해결방법  키 사전 공유  키 관리기관(TA, Trusted Authority)이 사전에 송수신자들에게 비밀 경로를 통하여 키를 전달 문제점  TA가 모든 사용자들의 키(𝑛(𝑛−1)/2개)를 관리해야 함 TA와 사용자 간의 안전한 통로 확보 문제     온라인 키 분배  키배포 센터(KDC, key distribution center)에서 키를 전달 배포 과정  키배포 센터에 통신을 위한 키 요청 키배포 센터는 의사난수 생성기를 통해 세션키를 생성 사용자의 키로 세션키를 암호화하여 전달 사용자는 자신의 키로 복호화하여 세션키를 얻음     Diffie-Hellman의 키 교환 공개키 암호  Diffie-Hellman의 키 교환  최초의 비밀키 교환 프로토콜 이산 로그 문제를 활용  y = g^x mod p  y, p, g를 아는 상태에서 x는 구하기 어렵다는 문제   Key = g^xy mod p  p와 g가 알려져도 x, y는 알 수 없음     실제로는 키를 교환하는 것이 아니라 공유하는 키를 생성  키 교환 절차  통신의 주체는 두개의 수 p와 g를 선택  p(1024bit, 300자리가 넘는 십진수) g(1 \u003c g \u003c p-1)   Alice는 개인키 x를 정하고, R1 = g^x mod p 를 계산 Bob은 개인키 y를 정하고, R2 = g^y mod p 를 계산 서로에게 R1, R2(공개키)를 전달 Alice는 (R2)^x mod p, Bob은 (R1)^y mod p를 계산하여 비밀키 도출 이후 비밀키를 사용하여 통신  공격  이산대수 공격  R1, R2 를 도청자가 가로채 x, y를 구하게 되면 K를 알아 낼 수 있다. 비밀키의 역할을 할 수 없음   중간자 공격(MITM, Man-In-The-Middle Attack)  공격자는 키 교환 중간에 끼어들 수 있음 통신 주체간 인증단계가 없기 때문 해결 방법  전자서명과 공개키 인증서 국대국 프로토콜(STS, Station-To-Station Protocol)      공개키 암호  수학적으로 해결하기 곤란한 문제를 기반으로 기밀성 유지 전자문서의 무결성과 부인방지 기능을 가지는 전자서명 구현, 다양한 암호 프로토콜에 사용 가능 공개키(암호화키), 개인키(복호화키)로 분리  두 키는 수학적 관계로 이루어져 있으므로 별개로 생성 불가    통신 과정  수신자는 공개키를 송신자에게 전달 송신자는 공개키를 이용하여 세션키를 암호화하고 수신자에게 전달 수신자는 개인키로 암호문을 복호화  ","excerpt":"암호화할 때 사용되는 키와 복호화할 때 사용하는 키가 서로 다른 암호 알고리즘\n키 배송 문제 대칭키 암호를 사용하기 위해서는  …","ref":"/til/security/cryptology/asymmetric-cryptography/introduction/","title":"Introduction"},{"body":"평문(Plain Text)를 암호문(Cipher Text)로 만드는 암호기술(Crytography)과 이를 해독하는 암호해독(Cryptanalysis)에 대하여 연구하는 학문\n암호 기법  치환(Substitution)  평문의 문자를 다른 문자로 교환(대체)하는 암호기법   전치(Transposition)  문자 집합 내부에서 자리를 바꾸는(재배열) 암호기법 원문과 암호문에 사용된 문자 사이에 일대일 대응 규칙을 갖는다   블록(Block)  평문을 특정 비트의 블록으로 잘라낸 후 암호화 알고리즘을 적용하여 암호화 Round를 사용하여 반복적인 암호화 과정을 수행 DES, AES 등   스트림(Stream)  데이터 흐름(Stream)을 순차적으로 처리해가는 암호 알고리즘 평문과 키를 XOR하여 생성 블록 암호기법보다 빠른 속도 그래서 무선 통신 환경에서 오디오, 비디오 스트리밍에 사용됨 LFSR, RC4 등    암호화와 복호화  암호화(Encrypt)  평문을 비밀키를 사용하여 암호문으로 암호화한다.   복호화(Decrypt)  암호문을 비밀키를 사용하여 평문으로 복호화한다.    위치에 따른 암호화 구분  링크 암호화(Link Encryption)  통신 링크 양쪽 끝단에 암호화 장치를 놓는 것 대형 네트워크에서 사용하면 필요한 암호화 장치 수가 증가 중간 노드에서 데이터가 평문으로 노출되는 단점   종단간 암호화(End-to-End Encryption)  두 종단 시스템에서 수행 트래픽 분석에 취약하나 링크 암호화보다 높은 수준의 보안    암호 기술  대칭키 암호(Symmetric Cryptography)  암호화키 = 복호화키   비대칭키 암호(Asymmetric Cryptography)  암호화키 ≠ 복호화키   하이브리드 시스템  대칭키 + 비대칭키   일방향 해시함수(one-way hash function)  프로그램의 해시값을 제공하여 정보가 변경되지 않음을 증명   메시지 인증 코드(MAC, Message Authentication Code)  메시지가 전송 도중 변경되지 않았다는 것과 메시지를 송신한 상대가 맞는지 확인하기 위해 사용   전자서명  무결성을 확인하고, 인증과 부인방지를 제공   의사난수 생성기(PRNG, Pseudo Random Number Generator)  난수열을 생성하는 알고리즘 키 생성에 사용    암호 해독 암호 시스템을 무력화시키는 기술로, 합법적인 송수신자가 아닌 제3자가 암호문으로부터 평문을 찾으려는 시도를 말한다. 이때 제3자는 암호 해독자 또는 침해자라고 칭한다.\n 암호문 단독 공격(COA, Cipher-text Only Attack)  암호문만 가지고 이에 대응되는 평문과 키를 찾아내는 방법 침해자는 암호 알고리즘을 알고 있으며 암호문을 가로챌 수 있다고 가정   기지 평문 공격(KPA, Known Plain-text Attack)  암호문과 평문의 관계로부터 키나 평문을 추정하여 해독하는 방법   선택 평문 공격(CPA, Chosen Plaintext Attack)  평문을 선택하면 그에 해당하는 암호문을 얻어내 해독하는 방법 송신자(암호기)에 접근이 가능하고, 평문/암호문 쌍을 침해자가 선택 가능하다고 가정   선택 암호문 공격(CCA, Chosen CIphertext Attack)  암호문을 선택하면 그에 해당하는 평문을 얻어내 암호를 해독하는 방법 수신자(복호기)에 접근이 가능하다고 가정    암호 알고리즘의 안정성 평가 안전성  계산적으로 안전  암호시스템을 공격하기 위해 필요한 계산량이 너무 커 현실적으로 공격할 수 없는 경우   무조건적으로 안전  무한한 계산 능력이 있어도 공격할 수 없는 경우     즉, 암호 알고리즘은 암호 해독비용이 암호화된 정보의 가치를 초과하거나 암호 해독 시간이 정보의 유효 기간을 초과하도록 개발되어야 한다.\n 평가체계  CC(Common Critetia)  정보보호시스템에 대한 공통 평가 기준   CMVP(Cryptographic Module Validation Program)  미국 NIST와 캐나다 CSE가 개발한 암호 모듈의 안전성 검증을 위한 프로그램    암호기술 평가  암호 알고리즘 평가  정보보호제품에 탑재된 암호 알고리즘에 대한 안전성 평가   암호모듈 평가  암호 알고리즘을 이용하여 제공되는 암호 서비스에 대한 안전성 평가   정보보호제품 평가  암호모듈을 탑재한 정보보호 제품에 대한 안전성 평가   응용시스템 평가  각 제품을 연동하여 구성되는 시스템에 대한 안전성 평가    ","excerpt":"평문(Plain Text)를 암호문(Cipher Text)로 만드는 암호기술(Crytography)과 이를 해독하는 암호해 …","ref":"/til/security/cryptology/introduction/","title":"Introduction"},{"body":"암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 같은 암호 알고리즘\n블록 암호 치환과 전치를 이용하여 평문을 일정 단위(블록)로 나누어서 암호문을 생성하는 것\n확산과 혼돈  확산(Diffusion): 평문과 암호문 관계를 숨김 혼돈(Confusion): 암호문과 키의 관계를 숨김  전치 요소(P-box) 평문 비트를 전치시키는 역할\n 단순 P-box  입력받는 n 비트와 출력되는 m 비트의 크기가 같음(n = m) 역함수가 존재   확장 P-box  n 비트를 입력받아 m 비트를 출력(n \u003c m) 입력 비트 중 특정 비트는 한 개 이상의 출력 비트와 연결됨 비트의 양을 증가시키기 위해 사용   축소 P-box  n 비트를 입력받아 m 비트를 출력(n \u003e m) 입력으로 사용된 비트 중 특정 비트는 소실됨    치환 요소(S-box) 평문 비트를 치환하는 역할\n 입력되는 n 비트와 출력되는 m 비트의 크기가 같은 경우에만 역함수 존재\n 합성 암호(Product Ciphers) S-box와 P-box, 그 외의 요소들을 결합하여 합성 암호를 만들어낸다.\n 이 합성 암호(Round)를 반복 사용함으로 확산과 혼돈 성질을 만족시킴\n Feistel  대부분의 대칭 블록 암호 알고리즘(ex. DES)의 기반 n 비트의 블록을 반으로 나누어서 반복된 연산 수행(3번 이상의 짝수 라운드) 암호화 과정 = 복호화 과정 암호강도 결정 요소  평문 블록 길이(64비트 이상) 키 K의 길이(64비트 내외) 라운드 수(16회 이상)     괄호의 조건이 충족되면 충분히 안전함을 의미\n SPN(Substitution-Permutation Network)  입력을 여러 개의 소블록으로 분리 각 소블록을 S-box로 입력하여 대치 S-box의 출력을 P-box로 전치하는 과정을 반복  스트림 암호 키스트림을 이용하여 비트 혹은 바이트 단위로 순차적으로 암호화\n동기식 스트림 암호  키 스트림은 평문 또는 암호문 스트림과 독립적 암ㆍ복호화 과정에서 상호 동기화 필요  OTP(One Time Pad)  암호화를 수행할 때마다 랜덤 키 스트림 사용 이론적으로 해독 불가 (Shannon에 의해 증명)  귀환 시프트 레지스터(FSR, Feedback Shift Register)  시프트 레지스터와 귀환 함수로 구성 S/W, H/W 환경에서 구현 가능 H/W에서 구현 용이  선형 귀환 시프트 레지스터(LFSR, Linear Feedback Shift Register)  많은 스트림 암호가 LFSR을 이용 선형성으로 인해 공격에 취약  비동기식 스트림 암호  키 스트림의 각 비트는 이전의 평문이나 암호문에 종속적으로 결정 키스트림과 평문의 함수관계로 암호문이 생성되므로 변조되어도 자기 동기화 가능 변조된 암호문이 후속 암호문 복호화에 사용되지 않아 오류 파급 낮음  비선형 귀환 시프트 레지스터(NLFSR, Non-Linear Feedback Shift Register)  비선형성으로 LFSR보다 안전 자기 동기식 스트림 암호라고도 함  ","excerpt":"암호화할 때 사용하는 키와 복호화할 때 사용하는 키가 같은 암호 알고리즘\n블록 암호 치환과 전치를 이용하여 평문을 일정 단위( …","ref":"/til/security/cryptology/symmetric-cryptography/introduction/","title":"Introduction"},{"body":"정보보호(Information Security)  정보의 수집, 가공, 저장, 송수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단 또는 그러한 수단으로 이루어지는 행위 기밀성, 무결성, 가용성, 인증성 및 부인방지를 보장하기 위한 기술적, 물리적, 관리적 보호대책을 강구하는 것  목표  기밀성(Confidentiality)  오직 인가된 사람, 프로세스, 시스템만이 알 필요성에 근거하여 시스템에 접근가능해야 한다. 보안 기술  접근 제어 암호화     무결성(Integrity)  정보의 내용이 무단으로 생성 또는 변경되거나 삭제되지 않도록 보호되어야 한다. 보안 기술  접근 제어 메시지 인증 침입 탐지 백업     가용성(Availability)  시스템이 지체 없이 동작하고, 자원이 필요할 때 권한이 있는 사용자가 이용할 수 있어야 한다. 보안 기술  백업 기술 중복 운영 기술       기밀성, 무결성, 가용성의 앞 글자를 따서 CIA라 부르기도 한다.\n 정보보호 관리(Information Security Management)  조직의 정보를 위험으로부터 보호하기 위한 활동 정보보호 관리에는 기술적, 물리적, 관리적 보호대책들이 존재  보호대책  기술적 보호대책  가장 기본적인 대책 접근통제, 암호기술, 보안성 높은 SW 사용 등   물리적 보호대책  자연재해나 적으로부터 정보들을 보호 정보처리 시설의 출입 통제, 잠금장치 등   관리적 보호대책  제도를 만들고 보안 계획을 세워 운영    용어  자산(Asset)  조직이 보호해야할 대상 정보, 하드웨어, 소프트웨어, 시설 등   취약점(Vulnerability)  정보시스템의 결함 관리적, 물리적, 기술적 약점들을 의미 위협의 이용 대상   위협(Threat)  정보시스템에 해를 끼칠 수 있는 사건 및 행동 위험의 원인   위험(Risk)  정보시스템에 존재하는 위협에 의해 자산에 손실이 발생할 가능성 자산×위협×취약점    보안 공격(Security Attack) 보안의 목표 CIA를 위협\n 적극적 공격  무결성과 가용성을 공격 데이터를 변경하거나 재전송  신분 위장 메시지의 송수신 부인 DDos 공격     소극적 공격  기밀성 공격 원치 않는 대상에게 데이터 노출  스누핑 도청 트래픽 분석      통제(Control) 취약점을 감소시키기 위한 메커니즘\n 예방통제  사전에 위협과 취약점에 대처하는 통제   탐지통제  위협을 탐지하는 통제   교정통제  탐지된 위협이나 취약점을 대처하거나 감소시키는 통제    ","excerpt":"정보보호(Information Security)  정보의 수집, 가공, 저장, 송수신 중에 발생하는 정보의 훼손, 변조, …","ref":"/til/security/introduction/","title":"Introduction"},{"body":"블루투스 서로 다른 기능을 가진 장치를 연결하기 위해 설계된 무선 LAN 기술\n 낮은 가격 높은 서비스 케이블 없이 여러 대 동시 연결  구조  피코넷(piconet)  8개의 지국 하나는 주국(Primary)이고, 나머지는 종국(Secondary)   스캐터넷(scatternet)  여러개의 피코넷이 합쳐진 형태 피코넷 안의 종국은 다른 피코넷에서 주국이 될 수 있음    취약점  블루프린팅(Blueprinting): 블루투스 장치를 검색하는 활동 블루스나핑(Bluesnarfing): 블루투스의 취약점을 이용하여 장치의 임의 파일에 접근하는 공격 블루버깅(Bluebugging): 블루투스 장치 간의 취약한 연결 관리를 악용해 공격 대상 장치를 연결하여 임의의 동작을 수행 블루재킹(Bluejacking): 블루투스를 이용해 특정 정보를 익명으로 퍼뜨리는 것  무선랜 취약점 물리적 취약점  도난 및 파손 구성설정 초기화 전원차단 LAN 차단  기술적 취약점  도청 서비스 거부(DOS) 불법 AP  사용자 정보 수집    관리적 취약점  장비 관리 미흡 사용자의 보안의식 결여 전파 관리 미흡  SSID 설정과 폐쇄시스템 운영 SSID 값을 NULL로 하여 접속을 요구하는 사용자를 차단하도록 AP를 설정(폐쇄시스템)\n SSID를 모르는 사용자의 접근 시도 감소/차단 효과 NetStumbler 등을 이용한 스푸핑을 미연에 방지   SSID(Service Set Identifier): 32bytes의 고유 식별자로 구성된 AP를 구분하는 ID\n MAC 주소 인증 접속을 허용하는 사용자의 MAC을 사전에 등록\n 간단한 보안설정으로 효과적인 접근제어 대규모 기관에서는 MAC 주소 관리 어려움  무선랜 인증 기술 WEP(Wired Equivalent Privacy) 인증 사용자 인증과 데이터 암호화를 모두 적용 가능\n 구현이 간단하고, 인증 절차도 간결 정적 WEP  RC4 알고리즘 사용으로 암호화키 복호화에 취약 단방향 인증의 취약성  불법 복제 AP로 인한 피해 발생 가능성   고정된 공유키 사용의 취약성  WEP 키 값이 외부로 유출될 경우 문제 발생     동적 WEP  기존 WEP과 다르게 암호화 키 값이 주기적으로 변경 802.1x에서 암호화 기법으로 채택 기존 RC4 알고리즘을 그대로 사용하므로 취약점 해결 안됨    EAP(Extensible Authentication Protocol) 인증 IEEE 802.1x에서 사용자 인증 방법으로 사용\n 어떠한 링크에도 접속 가능한 단순한 캡슐화 개념 알고리즘 인증 서버와 무선장비 사이에 상호 인증을 허용 사용자가 패스워드, OTP, 인증서 등을 사용성을 제공  무선랜 암호화 기술 WEP(Wired Equivalent Privacy) 무선 AP와 무선 단말기 간에 주고받는 무선 전송데이터를 2개의 장비가 약속한 40bit 공유 비밀키와 임의로 선택되는 24bit의 IV 값을 조합 한 64bit 키를 이용해 전송 데이터를 RC4 스트림 방식으로 암호화\n암호화 절차  공유키와 난수 발생기를 이용하여 RC4 알고리즘을 통한 키스트림 생성 무결성 보장을 위해 CRC-32 알고리즘으로 구성되는 ICV(Integrity Check Value)를 사용 키스트림과 평문과 ICV값이 합쳐진 데이터를 XOR 연산 수행하여 암호문 생성 생성된 암호문에 IV(초기벡터) 값 추가  복호화 절차  송신자가 보낸 패킷에서 IV값 추출 IV값과 WEP키와 난수발생기를 이용해 키 스트림 생성 키 스트림과 암호문을 XOR하여 복호화 복호화된 평문을 CRC-32 연산을 통한 ICV’와 ICV를 비교하여 무결성 검사 무결성 확인 후 평문 수신  취약점  24bit의 짧은 IV 길이 고정된 키 값을 사용하여 외부 유출 위험성  TKIP(Temporal Key Integrity Protocol)  48bit의 확장된 길이의 IV  재사용 공격으로부터 보호   WEP의 CRC-32 알고리즘보다 안전한 MIC를 사용  무결성 보장   WPA가 이 방식을 사용  취약점  여전히 RC4 암호 알고리즘을 사용 키 관리 방법을 제공하지 않음  CCMP(Counter mode with CBC-MAC protocol)  RC4 암호 알고리즘이 아닌 AES 암호 알고리즘을 사용 128bit의 대칭키와 48bit의 IV 사용 Counter 모드 기반의 CBC-MAC에 기반 데이터 영역과 헤더의 무결성 보장, PN(Packet Number)을 통한 재생공격 방지  무선랜 인증 및 암호화 복합 기술 WPA(Wi-Fi Protected Access)  TKIP 암호화 방식 + EAP 인증 수행 WEP의 약점 해결 RC4 암호 알고리즘 사용의 취약점  WPA2(RSN, Robust Security Network)  CCMP 암호화 방식 + IEEE 802.11i 수정안을 포함 AES 알고리즘 사용으로 좀 더 강력한 보안  WPA-PSK(Wi-Fi Protected Access Pre-Shared Key)  인증서버가 설치되지 않은 소규모 망에서 사용 AP와 단말기가 사전에 공유한 비밀키를 4-way-handshake 절차로 확인 128bit 암호화키, 10000개 패킷마다 갱신  802.1x/EAP(WPA-EAP, WPA-Enterprise)  WPA/WPA-2는 키 관리 방식 중점 보안이었다면 WPA-Enterprise 방식인 EAP는 사용자 인증까지 보완한 방식 다양한 인증을 제공하고 세션별 암호화 키 제공  WAP(Wireless Application Protocol) 무선통신을 사용하는 응용 프로그램의 국제표준\n 무선 마크업 언어(WML, Wireless Markup Language)  제한된 통신 용량, 제한된 사용자 입력 기능을 가진 장비에서 콘텐츠와 양식을 표현하기 위한 언어   무선 응용 환경(WAE, Wireless Application Environment)  WAP가 지원하는 응용 프로그램과 장비 개발을 쉽게 하기 위한 도구와 형식의 집합    프로토콜 구조  무선 세션 프로토콜(WSP)  연결형 세션 서비스  WTP 상에서 동작   비연결형 세션 서비스  WDP 상에서 동작     무선 트랜잭션 프로토콜(WTP)  사용자와 응용 서버 간 브라우징, 전자상거래 트랜잭션과 같은 동작을 위해 요청/응답을 전달해 트랜잭션 관리   무선 데이터그램 프로토콜(WDP)  상위 계층 WAP 프로토콜을 모바일 노드와 WAP 게이트웨이 사이서 사용되는 통신방법으로 변경   WTLS(Wireless Transport Layer Security)  TLS에 기반하여 모바일 장비와 WAP 게이트웨이 간의 보안 서비스를 제공 데이터 무결성, 프라이버시, 인증, DDoS 공격 보호 기능을 지원    인증 기술 기기 인증 기술  아이디/패스워드 기반 인증 방법  클라이언트 ID/PW를 서버 DB와 비교 무선 네트워크 아이디(SSID)을 사용한 인증 무선 단말과 AP간 WEP 키를 이용한 인증   MAC 주소 값 인증 암호 프로토콜을 이용한 인증  WPA, WPA2, EAP, CCMP 등   시도/응답 인증  OTP와 유사하게 일회성 해시값을 생성하여 사용자 인증    RFID(Radio Frequency Identifier) 무선 주파수(RF)와 제품에 붙이는 태그에 생산, 유통, 보관, 소비의 전 과정에 대한 정보와 연동되는 식별자인 전자칩을 이용하여 물체를 식별\n RFID 네트워크 공격  도청, 트래픽 분석, 위조, DDoS 공격 등   보안 기술  Kill 명령어  태그를 영구적으로 비활성화 시키는 방식 활용도가 낮음   Sleep / Wake 명령어  일시적으로 정지시켰다가 다시 동작 관리의 어려움   블로커(Blocker) 태그  전용 IC 태그를 소지함으로 가까이에 있는 IC 태그의 ID를 읽을 수 없게 만듦   Faraday Cage  태그를 물리적인 방법으로 막아 무선 신호의 전달을 방해   Jamming  강한 방해 신호를 보내어 불법적인 리더기의 접근을 막음     암호 기술  해시 락(Hash Lock)  일방향 해시 함수를 기반으로 하는 접근제어 메커니즘   XOR기반 원타임 패드 기법  스트림 암호화를 이용한 정보 보호      모바일 보안    구분 iOS 안드로이드     운영체제 유닉스 기반 리눅스 기반   보안 통제권 애플 사용자 또는 개발자   프로그램 실행 권한 Root 사용자   응용프로그램에 대한 서명 애플의 CA 개발자   샌드박스 프로그램 간 통신 통제 비교적 자유로움   부팅 절차 암호화 로직으로 서명된 안전 부팅 -   소프트웨어 관리 단말 기기별 고유 소프트웨어 설치 키 관리 -   애플리케이션 정책 폐쇄적 개방적   애플리케이션 배포 방식 앱스토어 개방   악성 애플리케이션 검수 검수 후 앱스토어 등록 알려지면 삭제    BYOD(bring Your Own Device) 보안 기술  MDM(Mobile Device Management)  모바일 기기를 완전 제어할 수 있도록 잠금, 제어, 보안 정책 실행기능 제공 보안 정책에 위반되는 앱은 설치 불가 탈옥한 기기는 사용 불가능, 도난 기기 원격 데이터 삭제 등 기능 제공   컨테이너화  암호화된 별도 공간에 업무용 데이터와 개인용 데이터를 분리하고 관리   모바일 가상화  하나의 모바일 기기에 개인용과 업무용 OS를 동시에 담아 분리   MAM(Mobile Application Management)  기기에 설치된 업무 관련 앱에만 보안 및 관리 기능을 적용   NAC(Network Access control)  기업 내부 네트워크 접근 전 보안정책 준수 여부 검사하는 접근통제 수행    ","excerpt":"블루투스 서로 다른 기능을 가진 장치를 연결하기 위해 설계된 무선 LAN 기술\n 낮은 가격 높은 서비스 케이블 없이 여러 대  …","ref":"/til/security/network/introduction/","title":"Introduction"},{"body":"에러메시지 flutter failed to build iOS app Error output from Xcode build: ↳ ** BUILD FAILED ** Xcode's output: ↳ Runner.app: resource fork, Finder information, or similar detritus not allowed Command CodeSign failed with a nonzero exit code note: using new build system note: building targets in parallel note: planning build note: constructing build description Could not build the application for the simulator. Error launching application on iPhone 11 Pro Max. 해결 방법  우선 클라우드(Onedrive 등)가 동기화중인 경로는 사용하지 않음  혹시라도 클라우드가 적용된 폴더에서 작업중이라면 밖으로 이동   프로젝트의 루트 경로에서 xattr -cr . 명령어 실행  ","excerpt":"에러메시지 flutter failed to build iOS app Error output from Xcode build: ↳ …","ref":"/til/flutter/ios-build-error/","title":"IOS Build Error"},{"body":"개발 과정 계획 → 분석 → 설계 → 구현 → 테스트 설계 단계의 객체가 분석 모델에서부터 만들어진 경우도 있지만, 객체지향 설계 모델이 항상 실세계와 대응 관계를 갖는 것은 아니다. 분석 모델의 객체는 실세계 객체이며, 설계 모델의 객체는 구현 수준에 가까운 객체(리스트, 배열 등)이기 때문이다.\n디자인 패턴은 이러한 추상적인 개념과 이것을 구체화한 객체를 잡아낼 수 있게 도와주며, 유연한 설계를 돕는다.\n객체 설정 객체지향 프로그래밍(OOP)에서 객체는 데이터와 프로시저로 이루어진 것이며, 이것들이 모여 객체지향 프로그램을 구성한다.\n 프로시저는 메소드(Method) 또는 연산(Operation)이라고도 한다.\n 객체는 요청(Request) 또는 메시지(Message)를 사용자에게서 받아 연산을 수행한다.\n 요청: 객체가 연산을 실행하게 하는 유일한 방법 연산: 객체의 내부 데이터 상태를 변경하는 유일한 방법  이러한 접근의 제약 사항으로 객체의 내부 데이터는 캡슐화된다. 이것의 의미는 객체 외부에서 객체 내부 데이터에 직접 접근이 불가하며, 객체의 내부 데이터 타입을 알 수 없다는 것이다.\n시스템을 구성할 객체의 분할을 결정하는 것은 여러 요인들을 고려해야 하므로 매우 어려운 작업이다. 고려해야 할 요인에는 캡슐화, 크기 결정, 종속성, 유연성, 성능, 진화, 재사용성 등이 있다.\n객체 구현 명세 OMT(Object-Modeling Technique)란 소프트웨어 구성 요소를 그래픽 표기로 모델링하는 기법을 말한다.\nObject 모델링 → Dynamic 모델링 → Functioanl 모델링  Object 모델링: 객체 다이어그램으로 표시하며 객체 사이의 관계를 정하는 모델링 Dynamic 모델링: 상태 다이어그램(상태도)를 이용하여 제어 흐름을 모델링 Functional 모델링: 자료 흐름도(DFD)를 이용하여 다수의 프로세스 사이의 자료 흐름을 중심으로 처리 과정을 표현한 모델링  클래스 객체의 구현은 클래스(Class)를 이용하여 객체의 내부 데이터와 연산을 정의한다.\n객체는 클래스가 인스턴스화 됨으로 생성된다. 따라서 해당 관계는 위와 같이 표현할 수 있다.\n서브 클래스 하나의 클래스는 다른 클래스로 상속되기도 하는데 이러한 경우 상속하는 클래스는 부모 클래스(Parent Class or Super Class), 상속되는 클래스는 서브 클래스(Sub Class or Child Class)라고 한다.\n 상속은 부모 클래스의 구성을 모두 갖는 새로운 클래스를 만드는 것이다.\n 추상 클래스 추상(Abstract Class)는 모든 서브클래스 사이의 공통되는 인터페이스를 정의하는 것이다. 이러한 클래스는 상속을 통해 만들어진 구체클래스(Concrete Class)인 서브클래스에서 구체적인 명세가 이루어진다. 일반적인 클래스와는 다르게 추상 클래스는 단지 정의만 하고 구현은 하지 않는다.\n 보통 추상 클래스는 이텔릭체로 표기한다.\n 믹스인 클래스 믹스인 클래스(Mixin Class)는 서브클래스에게 인터페이스를 제공하려는 목적을 가지는 클래스이다. 인스턴스로 만들 의도가 없다는 점에서 추상클래스와 비슷하나, 다수의 클래스가 서브클래스에게 인터페이스를 상속하기 위한 것이라는 점에서 큰 차이가 있다.\n다중상속은 여러 인터페이스의 기능을 상속한 하나의 클래스를 만드는 것이다. 반면 믹스인은 위에서 설명했듯이 여러 클래스의 기능을 상속하여 하나의 클래스를 만든다.\n인터페이스는 선언만을 할 뿐 구현이 전혀 이루어져 있지 않다면, 클래스는 구현까지 모두 이루어져 있다. 따라서 클래스는 다중 상속할 경우 동일한 이름의 메소드의 구현이 다른 부분에서 충돌이 일어날 수 있다. 믹스인은 이러한 충돌을 해결해서 클래스를 다중상속할 수 있도록 하는 것이다.\n인터페이스 명세 객체는 인터페이스로 자신을 드러내므로 외부에서 객체를 알 수 있는 방법은 인터페이스 밖에 없다. 따라서 인터페이스를 통해서만 처리 요청이 가능하며 구현에 대해서는 전혀 알 수 없다.\n 시그니처(Signature): 객체가 선언하는 연산으로 연산명, 매개변수, 리턴 값을 명세 인터페이스(Interface): 객체가 정의하는 모든 시그니처로 객체가 처리할 수 있는 연산의 집합 타입(Type): 특정 인터페이스 서브 타입(Sub-Type): 다른 인터페이스를 포함하는 인터페이스 슈퍼 타입(Super-Type): 다른 인터페이스가 포함하는 인터페이스  서로 다른 객체라 할 지라도 동일한 타입이라 한다면 해당 인터페이스에서 지원하는 연산을 동일한 방식으로 요청이 가능하지만, 그 내부 구현에 따라 다른 결과를 전달 받을 수 있다.\n 동적 바인딩: 위 원리를 활용하여 런타임에 사용자 요청을 처리하는 객체를 결정하는 것 다형성: 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있는 성질로, 객체지향 시스템의 핵심 개념  디자인 패턴을 이용하면 인터페이스에 정의해야 하는 요소가 무엇이고 어떤 데이터를 주고 받아야 하는지 식별할 수 있게 도와준다. 메멘토 패턴은 객체 내부 상태를 어떻게 저장하고 캡슐화해야 하는지를 정의함으로 나중에 그 상태를 복구할 수 있는 방법을 알려준다.\n디자인 패턴은 또한 인터페이스 간의 관련성도 정의한다. 유사한 인터페이스를 정의하거나 인터페이스에 여러 제약을 정의한다. 데코레이터 패턴과 프록시 패턴은 대상 객체와 장식되고 중재하는 객체가 동일한 인터페이스를 갖도록 한다. 또한 방문자 패턴에서 방문자 인터페이스는 방문자 객체가 방문하는 개체의 인터페이스를 반영한다.\n클래스 상속 vs 인터페이스 상속  클래스: 객체가 어떻게 구현되는지르 정의, 객체의 내부 상태와 연산에 대한 구현 방법을 정의 인터페이스(타입): 객체가 응답할 수 있는 요청의 집합을 정의  하나의 객체는 여러 타입을 가질 수 있으며, 서로 다른 클래스의 객체들이 동일한 타입을 가질 수도 있다. 즉, 객체의 구현은 다르더라도 인터페이스는 같을 수 있다는 의미다.\n 클래스 상속: 개체의 구현을 정의할 때 이미 정의된 객체를 기반으로 하는 것. 인터페이스 상속(서브타이핑): 어떤 객체가 다른 객체 대신에 사용(동적 바인딩)될 수 있는 경우 사용.  C++에서 순수한 인터페이스 상속은 순수 가상 함수를 정의한 추상 클래스를 public으로 상속한다. 반면 클래스 상속은 private으로 상속하게 되는데 이는 부모 클래스의 구현을 캡슐화하기 위함이다. 이로 인해 서브클래스의 사용자에게는 부모클래스에 정의된 연산이 공개되지 않게 된다.\n책임 연쇄 패턴에 나오는 객체들은 반드시 동일한 타입을 가져야 하지만, 이들이 구현을 공유하지는 않는다. 복합체 패턴에서 Component 클래스는 공통의 인터페이스를 정의하고 Composite 클래스는 공통의 구현을 정의한다. 커맨드, 옵저버, 상태, 전략 패턴은 순수 인터페이스인 추상 클래스를 써서 구현하는 경우가 많다.\n인터페이스 프로그래밍 클래스 상속은 부모 클래스에 정의된 구현을 재사용해서 빠르게 새로운 기능을 구현하는 것이 가장 큰 목적이다. 즉, 상속을 이용하면 중복되는 코드를 줄여준다는 장점이 있다. 다만 상속은 이런 단순한 작업뿐 아니라 더 복잡한 일도 이루어낼 수 있다.\n동일한 인터페이스를 갖는 객체들을 공통된 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있다. 이렇게 만들어진 인터페이스를 공유하는 객체군들은 모두 부모 클래스에 정의된 요청을 처리할 수 있게 된다. 앞에서도 언급했지만 이러한 원리를 이용하면 프로그램이 동작중인 런타임 중에 사용자 요청을 처리할 객체를 동적으로 결정할 수 있다. 이는 객체 지향에서 중요한 개념인 다형성이라는 성질이다.\n추상 팩토리, 빌더, 팩토리 메서드, 프로토타입, 복합체 패턴에서는 구체 클래스에서 인스턴스를 생성하도록 한다. 객체 생성 과정을 추상화 함으로써 인스턴스화할 때 인터페이스와 구현을 연결하는 방법을 제공한다.\n재사용 가능한 소프트웨어 개발 객체 합성 객체 합성은 클래스 상속에 대한 대안으로 다른 객체들을 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것이다. 객체를 합성하기 위해서는 합성하는 객체의 인터페이스를 명확하게 정의해야만 한다. 이런 방법의 재사용을 블랙박스 재사용(black-box reuse)라고 한다. 객체의 내부가 공개되지 않고 인터페이스를 통해서 재사용되기 때문이다.\n 클래스 상속은 부모 클래스의 내부가 서브클래스에 공개되므로 화이트박스 재사용(white-box reuse)라 한다.\n public class Computer { private CPU cpu; private Memory memory; private MainBoard mainBoard; private PowerSupply powerSupply: public Computer() { cpu = new CPU(); memory = new Memory(); mainBoard = new MainBoard(); powerSupply = new PowerSupply(): } public void run() { powerSupply.on(); mainboard.run(); cpu.run(); memory.run(); } } 위 예제는 컴퓨터를 구성하는 부품 객체들을 합성하여 컴퓨터 클래스를 정의한 것이다. 객체 합성을 사용하면 각 클래스를 한 가지 작업에 특화시켜 응집도가 높고 결합도가 낮은 소프트웨어를 만들 수 있다는 점에서 클래스 상속보다 좋은 방법이다.\n객체 위임 위임(delegation)은 객체 합성 원리를 이용하여 특정 객체의 필요한 기능만을 가져오는 것이다. 상속은 필요없는 부분도 다 물려받아야 된다는 점과 대조된다.\nimport java.util.ArrayList; public class MyStack { private ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); public boolean isEmpty() { return list.isEmpty(); } public int getSize() { return list.size(); } public String peek() { return list.get(getSize() - 1); } public String pop() { String text = list.get(getSize() - 1); list.remove(getSize() - 1); return text; } public void push(String text) { list.add(text); } } 위 예제는 기존에 존재하는 ArrayList를 활용하여 MyStack 클래스를 생성하는 것이다. 해당 예제를 보면 알 수 있듯이 객체 위임은 부모 클래스가 제공하는 기능을 가져오기만 하는 것이 아니라 재정의해서 사용할 수 있다는 특징을 가진다.\n매개변수 타입 JAVA에서 제네릭(generic)이라 하며 c++에서는 템플릿(template)이라 하는 매개변수 타입을 활용하면 프로그램을 보다 동적으로 짤 수 있게 된다. 타입을 컴파일 전에 정의하지 않고 런타임 중에 정의하는 방법이다.\nclass ArrayList\u003cE\u003e implements List\u003cE\u003e { ... } private ArrayList\u003cString\u003e stringList = new ArrayList\u003c\u003e(); private ArrayList\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); 제네릭 형식의 ArrayList가 정의한 것을 활용하여 문자열 리스트와 정수형 리스트를 생성하는 예제이다. 제네릭을 활용하지 않았다면 각각의 리스트를 만들기 위한 클래스가 필요했을 것이다.\n변화에 대비한 설계 재사용을 최대화하기 위해서는 새로운 요구사항과 기존 요구사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야한다.\n 특정 클래스에서 객체 생성  문제점: 특정 인터페이스가 아닌 특정 구현에 종속 해결방법: 추상 팩토리, 팩토리 메서드, 프로토타입   특정 연산에 대한 의존성  문제점: 요청을 만족하는 한 가지 방법에만 종속 해결방법: 책임 연쇄, 커맨드   하드웨어와 소프트웨어 플랫폼에 대한 의존성  문제점: 플랫폼 이식에 어려움 해결방법: 추상 팩토리, 브릿지   객체의 표현이나 구현에 대한 의존성  문제점: A가 B의 구현을 알고 있다면 B를 변경할 때, A도 변경해야 함 해결방법: 추상 팩토리, 브릿지, 메멘토, 프록시   알고리즘 의존성  문제점: 알고리즘을 변경하기 어려움 해결방법: 빌더, 이터레이터, 전략, 템플릿 메서드, 방문자   높은 결합도  문제점: 클래스를 독립적으로 사용할 수 없음 해결방법: 추상 팩토리, 브릿지, 책임 연쇄, 커맨드, 중재자, 옵저버   서브클래싱을 통한 기능 확장  문제점: 새로운 클래스마다 객체를 재정의해야 함 해결방법: 브릿지, 책임 연쇄, 테커레이터, 옵저버, 전략   클래스 변경이 편하지 못한 점  문제점: 변경사항에 서브클래스 다수를 수정해야 하는 불편함 해결방법: 어댑터, 테커레이터, 방문자    디자인 패턴 고르기  패턴의 문제 해결방법 파악 패턴의 의도 파악 패턴들 간의 관련성을 파악 비슷한 목적의 패턴들을 모아서 공부 재설계의 원인을 파악 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악  참고문헌  Gof의 디자인 패턴 번역본 Department of Computer Science University of North Carolina 코드 재사용을 위한 Mixin  ","excerpt":"개발 과정 계획 → 분석 → 설계 → 구현 → 테스트 설계 단계의 객체가 분석 모델에서부터 만들어진 경우도 있지만, 객체지향  …","ref":"/til/design-patterns/object-oriented-design/","title":"객체지향설계"},{"body":"공개키 암호 알고리즘의 표준으로 인수분해 문제 해결이 어렵다는 사실에 기반하고 있다. 암호화와 전자서명 등에 사용된다.\n키 생성  N = pq  p와 q는 서로 다른 소수   Φ(N) = (p-1)(q-1) Φ(N) 보다 작고, Φ(N)과 서로소인 정수 e를 찾음 de ≡ 1 (mod Φ(N))를 만족하는 정수 d  확장 유클리드 호제법 사용    암호화/복호화 통신 주체는 상대방의 공개키로 평문을 암호화하여 송신하고 수신자는 자신의 개인키로 암호문을 복호화하여 평문을 획득함\n 암호화  C = M^e mod n e: 공개키   복호화  M = C^d mod n d: 비밀키    취약점  소인수분해 공격  현실적인 시간 내에 효율적인 소인수분해는 아직 불가능 이러한 알고리즘이 개발된다면 안전하지 않음   중간자 공격  통신 주체사이에서 RSA를 하는 공격자의 위험성 공개키 인증서를 사용하여 방지   선택 암호문 공격(CCA, Chosen Ciphertext Attack)  임의의 데이터를 송신하면 그것을 암호문으로 간주하고 회신해주는 서비스를 공격자가 이용할 수 있다는 것을 가정한 공격 이러한 공격을 막기 위해 최적 비대칭 암호화 패딩(OAEP)으로 평문을 수정하는 것이 권장된다.    권장사항 공개키 N과 e로부터 비밀키 d를 구할 수 있다면 RSA는 해독이 가능하므로 아래 권장사항을 지켜야만 한다.\n 소수 p와 q는 최소 512bit, N은 최소 1024bit p와 q는 같지 않고 거의 비슷한 크기의 소수 p-1과 q-1은 큰 소인수를 가져야 함 p-1과 p-1 최대공약수는 작은 수  ","excerpt":"공개키 암호 알고리즘의 표준으로 인수분해 문제 해결이 어렵다는 사실에 기반하고 있다. 암호화와 전자서명 등에 사용된다.\n키 생 …","ref":"/til/security/cryptology/asymmetric-cryptography/rsa/","title":"RSA"},{"body":"기존 운영체제 내에 보안기능을 통합시킨 보안 커널을 추가로 이식한 운영체제\n주요 제공 기능 메모리, 보조기억장치 데이터, 프로세스, 디렉터리, 하드웨어 장치 등을 보호한다.\n 물리적 분리: 사용자 별로 별도의 장비 사용 시간적 분리: 프로세스는 동일 시간에 하나만 실행 논리적 분리: 각 프로세스에 논리적 구역 지정 암호적 분리: 내부에서 사용되는 정보를 외부에서 알 수 없게 암호화  보안 기능  파일 시스템 보호  파일 소유자가 보호장치를 만들어 둔 것 파일의 공용문제와 병행하여 고려되어야 함 보호방법  이름 명명 패스워드 암호화     사용자 식별 및 인증  개별 사용자들의 안전한 식별을 요구하며, 각각의 사용자들은 고유하게 식별될 수 있어야 함   임의적/강제적 통제(DAC, MAC) 객체 재사용 보호  파일 삭제 시 OS에 남아있지 않음   완전한 조정  임의적/강제적 통제가 효과적이기 위해서는 모든 접근을 통제해야 함   신뢰 경로  패스워드 설정, 정책 설정 시 신뢰 경로를 통한 통신   감사 및 감사 기록 축소  모든 보안 관련 사건은 감사기록부에 기록되어야 하며 명백하게 보호되어야 함    보안 커널(Secure Kernel) 주체와 객체 사이 모든 접근과 기능 중재\n 참조 모니터 개념을 구현한 것 TCB 내에 있는 컴퓨터 시스템으로 구성됨  참조모니터(Reference Monitor) 보안 커널의 가장 중요한 부분으로 자원에 대한 모든 액세스를 제어하는 추상 머신\n 격리성: 부정조작 방지 완전성: 항상 무시되고 호출 검증가능성: 모든 동작 분석/테스트로 확인 가능  신뢰 컴퓨팅 기반(TCB, Trusted Computing Base) 컴퓨터 시스템(OS, H/W, F/W, S/W 등) 내의 모든 보호 메커니즘의 총체\n신뢰 플랫폼 모듈(TPM, Trusted Platform Module) 신뢰 컴퓨팅을 위한 H/W, S/W 방법에서 핵심이 되는 하드웨어 모듈\n 암호화된 키, 패스워드, 디지털 인증서 등의 안전한 저장 공간을 제공하는 보안 모듈 신뢰 컴퓨팅(TC, Trusted Computing)의 가장 하위에 위치 훼손 방지가 필수적이므로 하드웨어칩으로 구현(SW적으로도 가능) 물리적인 공격(도난)에도 정보 노출이 어려움  신뢰 관련 연산  암호화 키의 생성과 저장 패스워드 저장 무결성 검증 디지털 인증서 관련 신뢰 연산  기본 서비스  인증된 부트 서비스: 운영체제가 적재될 때 각 부분이 사용을 위해 승인된 버전임을 인증 인증 서비스: 다양한 인증에 사용(개인키를 이용한 디지털 인증 등) 암호화 서비스: 특정 설정 상태에서만 복호화가 가능하게 하는 암호화 지원  ","excerpt":"기존 운영체제 내에 보안기능을 통합시킨 보안 커널을 추가로 이식한 운영체제\n주요 제공 기능 메모리, 보조기억장치 데이터, 프로 …","ref":"/til/security/system/secure-os/","title":"Secure OS"},{"body":"개요 하노이의 탑(Tower of Hanoi)은 퍼즐의 일종이다. 세 개의 기둥과 이 기둥에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있다.\n게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것이다.\n 한 번에 하나의 원판만 옮길 수 있다. 큰 원판이 작은 원판 위에 있어서는 안 된다.  문제 해결  원판이 한 개일 때  1: 1 \u003e 3   원판이 두 개일 때  1: 1 \u003e 2 2: 1 \u003e 3 1: 2 \u003e 3   원판이 세 개일 때  1: 1 \u003e 3 2: 1 \u003e 2 1: 3 \u003e 2 3: 1 \u003e 3 1: 2 \u003e 1 2: 2 \u003e 3 1: 1 \u003e 3     원판이 n개일 때  1 ~ n-1번 원판: 1 \u003e 2 n번 원판: 1 \u003e 3 1 ~ n-1번 원판: 2 \u003e 3    자바 코드 import java.util.Scanner; public class Hanoi { public int count = 0; public static void main(String[] args) { // TODO Auto-generated method stub  System.out.println(\"원반 갯수를 입력하세요.\"); Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.close(); Hanoi hanoi = new Hanoi(); hanoi.move(n, \"1\", \"2\", \"3\"); hanoi.showCount(); } public void move(int n, String source, String auxiliary, String destination) { if (n==1) { System.out.println(n+\" : \"+source+\" -\u003e \"+destination); ++count; } else { move(n-1, source, destination, auxiliary); // 소스 기둥 -\u003e 보조 기둥  System.out.println(n+\" : \"+source+\" -\u003e \"+destination); // 마지막 원판 목적지로 이동(전체원판수가 1이 아닐때)  ++count; move(n-1, auxiliary, source, destination); // 보조 기둥-\u003e 목적지 기둥  } } public void showCount() { System.out.println(\"이동 횟수: \" + count); } } 소스코드는 Hanoi.java에서 확인할 수 있습니다.\n 참조: https://algorithms.tutorialhorizon.com/towers-of-hanoi/\n","excerpt":"개요 하노이의 탑(Tower of Hanoi)은 퍼즐의 일종이다. 세 개의 기둥과 이 기둥에 꽂을 수 있는 크기가 다양한 원판 …","ref":"/til/algorithm/towers-of-hanoi/","title":"Towers Of Hanoi"},{"body":"데이터 전송 방식 네트워크에서 데이터가 항상 순서대로 최적의 경로를 따라 전송되지는 않으며, 전송 방식에 따라 데이터 전송 속도는 차이가 발생한다.\n회선 교환망  통신 전에 물리적인 연결로 전용 통신 선로를 설정 통신이 끝날 때까지 연결을 독점적으로 사용 전화망이 대표적인 예시  패킷 교환망  전송하고자 하는 정보를 패킷이라는 단위로 나눔 각각의 패킷에는 발신자와 수신지의 주소가 담김 패킷 교환기(라우터)가 수신지까지 전달 회선 통신망과 달리 통신 경로가 확정적이지 않음 네트워크 상태에 따라 여러 경로로 전송됨  셀 교환망  망 내에서는 프로토콜을 간략화하여 데이터를 셀이라고 부르는 패킷 단위로 전송 셀은 전송에 필요한 최소 기능만을 담당 흐름 제어와 오류 제어는 단말 간에서 처리 비동기 전송 방식(ATM)이 대표적인 형태 고속 네트워크 전송에 효율적  위상 버스형  통신 회선 하나를 모든 노드가 공유 한 노드가 전송한 메시지 모든 노드에게 전달 노드가 많으면 통신 시 충돌이 발생 \u0026 속도 저하  스타형  중앙 제어 노드가 모든 통신 제어 스위칭 허브의 등장으로 발전된 형태 노드 간 데이터가 다른 노드에겐 전달 X 중앙 노드의 성능에 크게 좌우됨 중앙 제어 노드가 작동하지 않으면 네트워크 마비  링형  토큰 네트워크가 이것의 일종임 한 노드에 이상이 생기면 통신망 마비 토큰을 받아야 데이터 전송 가능  지연 시간 발생    허브/트리형  계층적 구조 작은 버스형 네트워크 여러 개를 연결  규모 LAN(Local Area Network)  일반적으로 300m 이하의 통신 회선으로 연결된 PC 메인 프레임과 워크스테이션의 집합을 의미 한 건물에서 가장 효과적으로 사용할 수 있도록 연결된 고속 통신망  MAN(Metropolitan Area Network)  LAN을 고속의 백본(backbone)으로 묶은 형태, LAN 수준의 높은 데이터 전송률을 제공 LAN보다는 크지만 WAN보다는 작은 지역에서 사용 가능  WAN(Wide Area Network)  지리적으로 흩어진 통신망을 의미 지방과 지방, 국가와 국가, 대륙과 대륙을 연결  ","excerpt":"데이터 전송 방식 네트워크에서 데이터가 항상 순서대로 최적의 경로를 따라 전송되지는 않으며, 전송 방식에 따라 데이터 전송 속 …","ref":"/til/network/types/","title":"Types"},{"body":"장고란?   파이썬을 기반으로 하는 오픈소스 웹 애플리케이션 프레임워크이다.\n 프레임워크는 애플리케이션 개발에 필요한 기본 뼈대를 제공하는 것을 말한다. 장고는 웹 백엔드 구축에 필요한 다양한 기능들을 제공하고 있다.\n   2020년 1월 기준 장고 최신 버전: v3.0.2\n  장고 소프트웨어 재단에 의해 개발이 진행되고 있다.\n 공식 사이트: https://www.djangoproject.com/ 공식 개발문서: https://docs.djangoproject.com/ko/3.0/    장고의 구조  고전적인 MVC 디자인 패턴을 변형한 MTV 패턴을 따른다.  M(Model) T(Template) V(View)   MVC 디자인 패턴과 유사하지만, 몇가지 차이가 존재한다.\n   장고의 특징   웹 백엔드 개발에 필수적인 기능을 기본적으로 제공한다.\n 데이터베이스 관리 사용자 인증 시스템 관리자 인터페이스 세션 관리 기능 CSRF, SQL인젝션 방지와 같은 보안 대책    추가로 필요한 기능들은 외부 패키지를 이용하여 편리하게 구현 가능하다.\n 장고를 위한 수많은 재사용 가능한 앱 https://pypi.org/ 파이썬을 기반의 다양한 패키지 https://djangopackages.org    대표적인 서비스  인스타그램 핀터레스트  ","excerpt":"장고란?   파이썬을 기반으로 하는 오픈소스 웹 애플리케이션 프레임워크이다.\n 프레임워크는 애플리케이션 개발에 필요한 기본 뼈 …","ref":"/til/django/study/what-is-django/","title":"What is Django?"},{"body":"윈도우 시스템 5개의 링으로 구성됨\n HAL(Hardware Abstraction Layer): H/W와 S/W가 원활히 통신할 수 있게 도움 마이크로 커널: 하드웨어와 통신만 하는 최소한의 커널  프로세스 스케줄링, 메모리 관리 등은 manager가 맡음    파일 시스템    항목 FAT16 FAT32 NTFS     용량 저용량(최대 2GB) 고용량(2GB~2TB) 대용량   암호화ㆍ압축 X X O   클러스터 1632KB 4KB 가변 클러스터(512B ~ 4KB)   장점 호환성 우수저용량 볼륨에 최적화  강력한 보안기능, 감사 기능디스크의 효율적 사용대용량 볼륨, 긴 파일이름   단점 보안 취약대용량 볼륨에 비효율적  NT계열외의 OS에는 호환 X저용량 볼륨에서 FAT보다 속도 저하    NTFS 구조    항목 설명     MBR(Master Boot Recode) 파티션 생성 시 물리적 디스크의 첫 번째 섹터에 위치한 512bytes 크기의 영역 부팅 시 BIOS에 의해 POST 과정을 마친 후 이 영역의 부트 코드를 호출 부트 코드는 Active 파티션을 찾아 해당 VBR 부트 코드를 호출   VBR(Volume Boot Recode) 부팅을 위한 기계어 코드와 볼륨 및 클러스터의 크기, MFT의 시작 주소 등의 설정 정보를 가짐   MFT(Master File Table) 모든 파일과 디렉터리의 속성 정보(파일 이름, 크기, 생성 시간 등)를 담은 테이블   시스템 파일 복구하는데 사용할 파일들이 저장   파일 영역 각 파일에 대한 실제 데이터가 저장    부팅 순서  윈도우 XP 이전  POST(Power On Self Test) 기본 부팅 관련 설정사항(CMOS) 로드 MBR 로드 (기본 파일시스템 정보 로드) NTLDR(NT Loader) 실행 ntoskrnl.exe 실행 -\u003e hal.dll을 읽음   윈도우 Vista 이후  3단계까지 위와 동일 윈도우 부트 서브 시스템 실행 윈도우 OS 로더(Winload.exe) 실행  각종 장치 드라이브를 로드하고, ntoskrnl.exe를 실행      윈도우 계정 기본 계정  Administrator: 관리자 권한의 계정 SYSTEM: 시스템에서 최고 권한을 가진 계정  사용자는 이 계정으로 시스템에 로그인할 수 없음   Guest: 제한적인 권한을 가진 계정  기본 그룹  Administrators: 도메인 자원이나 로컬 컴퓨터에 대한 모든 권한 Account Operators: 계정을 관리하는 그룹 Backup Operators: 시스템 백업을 위해서 모든 시스템의 파일과 디렉터리에 접근 가능 Guests: 도메인 사용 권한이 제한 Print Operators: 도메인 프린터에 접근 Users: 도메인과 로컬 컴퓨터를 일반적으로 사용  개인 사용자 환경을 생성 가능하나 설정 항목에 한계 존재   Power Users: Users 그룹보다 확장된 권한  디렉터리나 네트워크 공유, 공용 프로그램 그룹 생성, 시계 설정   Server Operation: 도메인의 서버를 관리할 수 있는 권한  SID(Security Identifier) Unix/Linux 시스템의 UID와 비슷한 윈도우 개념\n 각 사용자나 그룹에게 부여되는 고유 식별번호 Whoami /SID 명령어나 Whoami /USER 명령어를 통해 SID를 확인  윈도우 인증  LSA (Local Security Authority)  모든 계정의 로그인에 대한 검증, 자원 및 파일에 접근 권한 검사 SRM이 생성한 감사로그 기록 NT보안의 중심요소, 보안 서브시스템이라고도 함   SAM (Security Account Manager)  사용자/그룹 계정 정보에 대한 DB를 관리 로그인 입력 정보와 SAM 로그인 정보를 비교해 인증 여부 결정 인가되면 SRM에 알림   SRM (Security Reference Monitor)  사용자에게 SID를 부여 SID에 기반하여 파일/디렉터리에 대한 접근 권한 결정 감사 메시지 생성    공유 자료 관리 접근 권한  제공되는 권한  수정, 읽기 및 실행, 폴더 내용 보기, 읽기, 쓰기   사용자가 여러 그룹에 속한 경우 접근 권한은 누적 파일에 대한 접근 권한이 디렉터리에 대한 접근 권한에 우선 허용 권한보다 거부 권한이 우선  공유 폴더  C$,D$ 등  드라이브에 대한 관리목적 공유 폴더   ADMIN$  윈도우 설치 폴더에 접근하는 관리목적 공유 폴더   IPC$(Inter Process Communication)  네트워크 등에서 프로세스 간의 통신을 위해서 사용하는 통로    관리  netshare 명령어로 숨겨진 공유 폴더(이름 끝에 $) 확인 침입자가 네트워크에 액세스할 수 있는 위험  netshare 공유이름 /delete로 공유 비활성화 (OS 재부팅 시 활성화) 레지스트리를 통해 완벽하게 제거(HKLM)   IPC$는 정상적인 방법으로 제거할 수 없으며 제거할 경우 특정 서비스가 실행되지 않을 수 있음  암호 기능  EFS(Encrypting File System)  파일/폴더를 암호화할 수 있는 기능 인증서 추가/삭제를 통해 EFS가 적용된 파일을 읽을 수 있는 사용자 추가/변경   BitLocker  볼륨(파티션)에 저장된 모든 파일이 자동으로 암호화 시스템 파티션 제외    레지스트리 윈도우 부팅 시 하이브 파일에서 값을 읽어 들여 구성\n Master Key: 하이브 파일에서 직접 읽어 들여 구성되는 키 Derived Key: Master Key로부터 값을 가져와서 재구성하는 키  Master Key  HKEY_LOCAL_MACHINE(HKLM)  하드웨어와 드라이버 설정 사항에 관련된 정보 HKLM\\HARDWARE  부팅 시 하드웨어와 드라이버 정보(휘발성)   HKLM\\SAM  사용자와 도메인 정보 시스템 계정만 접근 가능   HKLM\\SECURITY  시스템 범위의 보안 정책과 사용자 권리 할당 정보 시스템 계정만 접근 가능   HKLM\\SOFTWARE  시스템 범위의 소프트웨어 목록과 그 환경설정 정보(이름, 경로 등)   HKLM\\SYSTEM  부팅될 때 필요한 시스템 범위의 환경설정 정보(서비스 목록 등)     HKEY_USERS(HKU)  시스템에 있는 모든 계정과 그룹에 관한 정보 모든 계정의 프로파일이 있다는 것을 제외하고 서브키가 HKCU와 동일    Derived Key  HKEY_CLASSES_ROOT (HKCR)  시스템에 등록된 파일 확장자와 그것을 열 때 사용할 어플리케이션의 매핑 정보 COM(Component Object Model) 오브젝트 등록 정보   HKEY_CURRENT_USER (HKCU)  현재 시스템에 로그인 중인 사용자와 관련된 시스템 정보 HKCU 키에서 설정한 내용이 HKU보다 우선권   HKEY_CURRENT_CONFIG (HKCC)  시스템이 시작할 때 사용하는 하드웨어 프로파일 정보 HKLM에 서브로 존재하는 config의 내용만을 담고 있음    공격  부팅 시 악성코드 실행 공격  재부팅 시 악성 프로그램을 구동시키기 위해 레지스트리(HKLM과 HKCU)를 변조 대상 파일  HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run (개별 사용자 지속) HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce (개별 사용자 일회성) HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run (전체 사용자 지속) HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce (전체 사용자 일회성)     특정 확장자 실행 시 악성코드 실행 공격  특정 확장자 실행 시 원하는 악성 프로그램을 실행 HKCR 내용 변경하여 수행    ","excerpt":"윈도우 시스템 5개의 링으로 구성됨\n HAL(Hardware Abstraction Layer): H/W와 S/W가 원활히 통신 …","ref":"/til/security/system/server/windows/","title":"Windows"},{"body":"기존에 사용하던 DES의 문제점은 키의 길이가 54bit로 짧아 Brute Force Attack(무차별 대입 공격)이 가능하다는 것이었다. 그래서 NIST(미국 국립기술표준원)는 DES를 대체하기 위한 알고리즘을 공모하였고 최종적으로 AES가 선정되었다.\n구조  non-Feistel 알고리즘, SPN 구조 키 사이즈에 따라 라운드가 상이  AES-128(10라운드) AES-192(12라운드) AES-256(14라운드)    라운드 과정  SubBytes  바이트 단위로 치환 비 선형성을 갖는 S-box를 적용   ShiftRows  행 단위로 순환 시프트 수행   MixColumns  열 단위로 혼합 높은 확산을 제공 마지막 라운드에서 수행 X   AddRoundKey  라운드 키와 state를 XOR 연산    ","excerpt":"기존에 사용하던 DES의 문제점은 키의 길이가 54bit로 짧아 Brute Force Attack(무차별 대입 공격)이 가능하 …","ref":"/til/security/cryptology/symmetric-cryptography/aes/","title":"AES"},{"body":"","excerpt":"","ref":"/til/security/cryptology/asymmetric-cryptography/","title":"Asymmetric-Cryptography"},{"body":"아래 코드를 이용하면 폼을 이용해 업로드한 이미지를 원형으로 자를 수 있다.\n 이미지 변형을 위해 Pillow 라이브러리를 우선 설치해두어야 한다.\n from PIL import Image, ImageOps, ImageDraw from io import BytesIO from django.core.files.uploadedfile import InMemoryUploadedFile # make circle image im = Image.open(request.FILES['image']) im = im.resize((1920, 1920)); bigsize = (im.size[0] * 3, im.size[1] * 3) mask = Image.new('L', bigsize, 0) draw = ImageDraw.Draw(mask) draw.ellipse((0, 0) + bigsize, fill=255) mask = mask.resize(im.size, Image.ANTIALIAS) im.putalpha(mask) output = ImageOps.fit(im, mask.size, centering=(0.5, 0.5)) output.putalpha(mask) buffer = BytesIO() output.save(buffer, format='png') file = InMemoryUploadedFile( buffer, '{}'.format(request.FILES['image']), '{}'.format(request.FILES['image']), 'image/png', buffer.tell(), None, ) profile.image = file 해당 코드는 Lionstagram 프로젝트에서 원형 프로필 사진 업로드 적용을 위해 사용되었다. 해당 소스 코드가 이 프로젝트에서 어떻게 활용되었는지는 링크를 통해 살펴볼 수 있다.\n","excerpt":"아래 코드를 이용하면 폼을 이용해 업로드한 이미지를 원형으로 자를 수 있다.\n 이미지 변형을 위해 Pillow 라이브러리를 우 …","ref":"/til/django/circle-image-cropping/","title":"Circle Image Cropping"},{"body":"악성 소프트웨어 의도적으로 컴퓨터 보안 속성을 침해할 목적으로 작성된 프로그램\n분류 바이러스(Virus) 자기 자신 또는 자신의 변형을 복사하여 컴퓨터 작동에 피해를 주는 명령어의 집합\n세대별 분류  원시형  코드의 변형이나 변화 없이 고정된 크기 기억장소에 상주하며 부트 영역이나 파일 감염   암호화  백신 프로그램이 진단할 수 없도록 일부 암호화 실행 시작점 부분에 위치하는 암호해독 데이터는 항상 일정   은폐형  기억소에 위치하면서 감염된 파일의 길이 변동 유무를 숨김 바이러스 검출하려 할 때, 감염 이전의 모습을 보여 속임   갑옷형  여러 단계의 암호화와 다양한 기법 동원 바이러스 분석을 어렵게 하고 백신 개발 지연   매크로  데이터 파일(워드, 엑셀 등)이 열릴 때 바이러스 실행 플랫폼과 무관하고 쉽게 전염 문서를 감염시키고 코드의 실행부분은 감염시키지 않음    대응 방안  안티 바이러스 필터링  signature scanning  특정 바이러스만이 가진 유일한 형태의 signature를 탐색   behavioral virus scanning  바이러스가 수행 중에 어떤 행동을 보이는지 추적     바이러스 예방책  신뢰있는 업체에서 구입한 상업용 S/W를 사용 Windows Script Host, Active X, VBScript, JavaScript는 비활성화    웜(Worm) 자기 자신을 복제하여 네트워크를 통해 스스로 확산\n 숙주 파일 X (독립성) 다른 시스템에 직접적인 영향 X() 메일, 파일 공유, 원격실행, 로그인, 파일전송, 모바일코드로 확산  종류  MASS Mailer형 웜  대량 메일 발송을 통해 확산되는 웜 감염된 시스템이 많으면 SMTP 서버의 네트워크 트래픽 증가   시스템 공격형 웜  OS 고유 취약점을 이용해 내부 정보를 파괴 컴퓨터를 사용할 수 없는 상태로 만듬 백도어 설치   네트워크 공격형 웜  특정 네트워크나 시스템에 대해 서비스 거부(DoS) 공격을 수행    대응 방안 안티 바이러스를 통해서 제거하거나 네트워크 활동과 사용을 모니터링\n 웜 모니터링 소프트웨어를 통한 방어 엔터프라이즈 네트워크와 인터넷 사이 경계에 위치  트로이목마(Trojan horse) 자신의 실체를 드러내지 않으면서 마치 다른 프로그램의 한 유형인 것처럼 가장하여 활동하는 프로그램\n 자기복제 X, 다른 파일 감염 X 원격 조정, 키로거(Keylogger), 사용자 정보 유출, 시스템 파괴, DoS 공격에 이용  스파이웨어(Spyware) 설치된 시스템의 정보를 주기적으로 원격지의 특정한 서버에 보냄\n 광고나 마케팅을 목적으로 배포하면 애드웨어(Adware) 수집한 데이터는 신원 도용, 스팸, 사기 등에 이용될 수 있음  그 외  백도어: 정상적인 인증을 수행하지 않고 시스템에 접근 Exploit: 정상적인 파일 혹은 웹사이트의 극히 일부 소스코드만을 변경 Kit: 바이러스를 자동으로 생성하는 도구 모음 루트킷(Rootkit): 컴퓨터 시스템에 침입 후 root 권한을 얻기 위해 사용하는 해킹 도구 모음 Attack Kit: 다양한 번식 방법과 payload 기술을 사용하는 새로운 악성코드를 자동으로 만들어주는 툴 프리더: 서비스 거부 공격(DOS)에 사용하는 코드  웹브라우저 보안 쿠키 보안 취약점  XSS(Cross-Site Scripting): 자바스크립트가 사용자의 컴퓨터에서 실행된다는 점을 이용한 공격 스니핑(Sniffing): 네트워크를 통해 전송되는 암호화되지 않은 쿠키를 탈취  세션 하이재킹 클라이언트-서버 간의 연결이 유지되는 상태를 가로채는 것을 말한다.\n 세션: 클라이언트 정보를 서버에 저장하는 기술로, 클라이언트 별로 세션ID를 부여되며 클라이언트는 세션쿠키를 통해 서버에 인증하고 세션(연결상태)을 유지한다.\n ","excerpt":"악성 소프트웨어 의도적으로 컴퓨터 보안 속성을 침해할 목적으로 작성된 프로그램\n분류 바이러스(Virus) 자기 자신 또는 자신 …","ref":"/til/security/system/client/","title":"Client"},{"body":"","excerpt":"","ref":"/til/security/cryptology/","title":"Cryptology"},{"body":"Windows Subsystem for Linux 터미널의 문제점\n 기본적으로 제공하는 색상이나 폰트가 예쁘지 않고 가독성이 떨어짐. Windows에서 제공하는 기본 터미널인 CMD를 기반으로 하기 때문임.  터미널 배경색 변경 폰트나 배경 색상을 바꾸는 것으로 위 문제점들을 해결할 수 있다. WSL에서 제공하는 터미널은 CMD를 활용한 것이므로, CMD의 색상 설정으로 WSL 색상 변경이 가능하다.\nWSL 테마 설정  설치된 Ubuntu와 같은 WSL Shell을 실행 창에서 마우스 우클릭, 속성 선택 WSL 설정 창에서 색 탭 선택 색상 슬롯의 RGB값을 지정  우분투 기본 색상에 맞추고 싶으면 아래와 같이 설정해준다.\n Ubuntu default Background-color: RGB(48,10,36)  CMD 색상 변경 Microsoft Colortool을 이용하면 CMD를 비롯한 WSL Shell의 배경색상을 변경할 수 있다.\n CMD 실행 ‘colortool’이 담긴 디렉터리로 이동 아래 코드 입력  colortool.exe -b solarized_dark # 컬러 스키마 설정 터미널 폰트 변경 기본 폰트가 코딩을 하는데 있어서 가독성이 떨어지므로, 다른 폰트로 변경하는 것이 좋다.\nWSL 폰트 변경  WSL Shell 실행 창에서 마우스 우클릭, 속성 선택 WSL 설정 창에서 글꼴 탭 선택 설치된 폰트 중에서 선택  가독성 좋은 폰트 기본적으로 윈도우에서 제공하는 Consolas 폰트도 괜찮긴 하지만 우분투에서 사용하는데에는 가독성이 좋지 않다. 그러므로 아래와 같은 폰트로 변경하는 것이 좋을 것이다.\n Bitstream Vera Sans Mono DejaVu Sans Mono D2Coding  개인적으로 이 중에서 한글 지원이 잘 되는 D2Coding 폰트가 사용하기 좋았다.\nzsh/oh-my-zsh WSL에서 기본적으로 제공하는 리눅스 Shell은 bash이다. 다양한 테마와 기능을 제공하는 zsh를 사용하면 보다 편리하게 코딩 작업이 가능하다.\nzsh와 oh-my-zsh를 설정하는 문서를 별도로 분리하게 되었다. 해당 문서는 여기를 클릭하면 이동할 수 있다.\n","excerpt":"Windows Subsystem for Linux 터미널의 문제점\n 기본적으로 제공하는 색상이나 폰트가 예쁘지 않고 가독성이  …","ref":"/til/wsl/customization/","title":"Customizing"},{"body":"식별자 자바스크립트 프로그램의 변수, 상수, 함수의 이름\n식별자를 만드는 규칙 첫번째문자  알파벳(A-Z, a-z), _(언더스코어), $만 사용 가능  두번째문자 이상  알파벳, _(언더스코어), $ 대소문자는 구분되어 다루어짐  예약어 사용불가  false, for, if, null 등  데이터 타입 숫자 정수, 실수(예: 42, 3.14)\n논리형 참, 거짓(예: true, false)\n문자열 (예: ‘좋은세상’, “a”, “365”, “2+4”)\n객체 레퍼런스 객체를 가리킴. C 언어의 포인터와 유사\nnull 값이 없음을 표시하는 특수 키워드. Null, NULL과는다름\n 자바스크립트에는 문자 타입 없음. 문자열로 표기\n 변수 자바스크립트 코드가 실행중 데이터 저장공간\n선언 변수이름을 정하고, 저장공간 할당\nvar score; 지역변수와 전역변수    지역변수 전역변수     함수 내에 var로 정의 함수 밖에 선언되거나, 함수 내에 var 없이 선언된 변수   선언된 함수 내에서만 접근 가능 프로그램 전역에서 사용 가능    this로 전역변수 접근 var x; // 전역변수 function f() { var x; // 지역변수  x = 1; // 지역변수 x에 1 저장  this.x= 100; // 전역변수 x에 100 저장  } 상수 데이터값 그 자체\n문자열 상수 \"\"와 '' 모두사용\n\u003cp onmouseover=\"document.body.style.color = 'brown'\"\u003e  인용부호를 문자를 그대로 사용하고자 하는 경우 \\\" 사용\n 식과 연산 연산자 산술 연산자 더하기(+), 빼기(-), 곱하기(*), 나누기(/), 나머지(%)\n증감 연산자 ++나 -- 사용\n 전위 연산자: 증감 연산을 실행하고 값 반환 ex) b = ++a 후위 연산자: 값을 우선 반환하고 증감 연산 실행 ex) b = a++  대입 연산자 오른쪽 식의 결과를 왼쪽 변수에 대입\n비교 연산자 두 값 비교, true or false의 결과를 내는 연산\n논리 연산자 AND(\u0026\u0026), OR(||), NOT(!)\n조건 연산자 condition ? expT : expF condition이 true면 전체 결과는 expT의 계산 값, false면 expF의 계산 값\n비트 논리 연산    연산자 설명     a \u0026 b 두 비트 모두 1이면 1, 아니면 0   a | b 두 비트 모두 0이면 0, 아니면 1   a ^ b 두 비트가 다르면 1, 같으면 0   ~ a 1을 0으로, 0을 1로 변환    비트 시프트 연산 시프트: 저장 공간에서 비트 이동\n   연산자 설명     a « b a의 비트들을 왼쪽으로 b번 이동, 최하위 비트의 빈자리는 0으로 채움, 한 비트 시프트마다 곱하기 2의 효과 발생, a의 값은 변환 X   a » b a의 비트들을 오른쪽으로 b번 이동, 최상위 비트의 빈자리는 시프트 전 최상위 비트로 채움, 한 비트 시프트마다 나누기 2의 효과 발생, a의 값은 변화 X   a »\u003e b a의 비트들을 오른쪽으로 b번 이동, 최상위 비트의 빈자리는 0으로 채움, a의 값은 변화 X    문자열 연산자  문자열 연결(+) 비교 연산자(!=, ==, \u003e , \u003c, \u003c=, \u003e=)는 문자열 비교에 사용  조건문 if문 var grade; var score = prompt(\"점수를 입력하세요\", 100); score = parseInt(score); // 문자열을 숫자로 바꿈 if(score \u003e= 90) // score가 90 이상 \tgrade = \"A\"; else if(score \u003e= 80) // 80 이상 90 미만 \tgrade = \"B\"; else if(score \u003e= 70) // 70 이상 80 미만 \tgrade = \"C\"; else if(score \u003e= 60) // 60 이상 70 미만 \tgrade = \"D\"; else // 60 미만 \tgrade = \"F\"; switch문  값에 따라 서로 다른 코드를 실행 실행 문장을 중괄호로 둘러싸지 않는다  switch(식) { case 값1: // 식의 결과가 값1과 같을 때 실행 문장 1; break; case 값2: // 식의 결과가 값2와 같을 때 실행 문장 2; break; ... case 값m: 실행 문장 m; // 식의 결과가 값과 같을 때 break; default: // 어느 값과도 같지 않을 때 실행 문장 n; } case문의 값\n case문의 값으로는 상수만 가능 값에 변수나 식은 사용 불가  break 문의 역할\n switch문 종료  반복문 for문 for (초기문; 조건식; 반복 후 작업){ // 실행 문장 } while문 while (조건식) { // 실행 문장 } do-while문 do { // 실행문장 } while (조건식); break문 가장 안쪽 반복문 하나만 벗어나도록 제어\ncontinue문 반복 코드 실행 중단, 다음 반복으로 점프\n함수  목적을 가지고 작성된 코드 블록 데이터 전달받아 처리한 후 결과를 돌려주는 코드 블록  함수 정의와 호출 function adder(a, b) { // 함수 정의 // 실행코드 var sum; sum = a+b; return sum; } var n = adder(24567, 98374); // 함수 호출 JS에서 제공하는 전역 함수    전역함수명 설명     eval(exp) exp의 자바스크립트 식을 계산하고 결과 리턴   parseInt(str) str 문자열을 10진 정수로 변환하여 리턴   isNaN(value) value가 숫자가 아니면 true 리턴    ","excerpt":"식별자 자바스크립트 프로그램의 변수, 상수, 함수의 이름\n식별자를 만드는 규칙 첫번째문자  알파벳(A-Z, a-z), _(언더 …","ref":"/til/javascript/data-type/","title":"Data Type"},{"body":"프로그래밍을 하는데 있어서 자료형은 매우 중요하다. 어떤 형태의 데이터를 활용할 것인가에 따라서 사용해야 하는 자료형이 달라지기 때문이다. 프로그래밍을 본격적으로 시작하기에 앞서 파이썬에 어떤 자료형이 존재하는지를 숙지하도록 하자.\n숫자형 종류 int 정수형(integer)은 음의 정수, 양의 정수, 0을 표현할 수 있다.\n\u003e\u003e\u003e a = 124 \u003e\u003e\u003e a = -63 \u003e\u003e\u003e a = 0 \u003e\u003e\u003e type(a) # 데이터 자료형 반환 \u003cclass 'int'\u003e  여기서 a는 데이터를 담는 변수이다.\n 데이터를 저장할 수 있는 공간으로 다양한 자료형들의 값을 담기 위해서 사용한다.\n\u003e\u003e\u003e a = 'python' \u003e\u003e\u003e a 'python' \u003e\u003e\u003e a = 3 \u003e\u003e\u003e a 3 float 실수형(Floating-point)은 소수점이 포함된 숫자를 말한다.\n\u003e\u003e\u003e a = 2.35 \u003e\u003e\u003e type(a) \u003cclass 'float\u003e Complex 복소수(Complex) 자료형은 두가지 방법으로 사용 가능하다.\n\u003e\u003e\u003e a = complex(1, 3) \u003e\u003e\u003e a (1+3j) \u003e\u003e\u003e type(a) \u003cclass 'complex'\u003e \u003e\u003e\u003e a = 2-4j \u003e\u003e\u003e type(a) \u003cclass 'complex'\u003e operations    Operation Result     x + y x와 y의 합   x - y x와 y의 차   x * y x와 y의 곱   x / y x와 y의 몫   x // y x와 y의 몫(소수점 포함)   x % y x와 y의 나머지   -x x의 부정   +x x   abs(x) 절대값 x   int(x) x를 정수로 변환   float(x) x를 실수로 변환   complex(re, im) re: 실수부, im: 허수부(기본값 0)   c.conjugate() 복소수 c의 켤레복소수   divmod(x, y) 몫과 나머지(a//b, a%b과 동일)   pow(x, y) x의 y 제곱근   x ** y x의 y제곱    문자열 자료형 문자열(String)은 문자의 집합으로 이루어진 것으로 작은 따옴표(' ')나 큰 따옴표(\" \") 사이에 작성한다.\n표현 방식 파이썬에서는 다른 언어와 다르게 문자열을 표현하는 방법으로 4가지를 제공한다.\n 작은 따옴표(' ‘) 큰 따옴표(\" “) 작은 따옴표 3개(’'' ‘'') 큰 따옴표 3개(”\"\" “\"\")  일반적인 따옴표 이렇게 다양한 방법을 제공하는 이유는 문자열에 따옴표가 포함되는 경우 다음과 같은 문제가 발생할 수도 있기 떄문이다.\n\u003e\u003e\u003e 'I'm not the only one' File \"\u003cstdin\u003e\", line 1 'I'm not the only one' ^ SyntaxError: invalid syntax 위와 같은 경우에는 I만이 작은 따옴표에 둘러싸여 있기 때문에 I 이후에 작성한 문자들은 문자열로 인식되지 못하고 오류가 발생한다.\n 해당 오류는 작은 따옴표가 아니라 큰 따옴표에서도 동일하게 발생할 수 있다.\n 연속적인 따옴표 작은 따옴표나 큰 따옴표를 세번 감싸는 방식을 사용하면 위와 같은 문제를 해결할 수 있다.\n\u003e\u003e\u003e '''I'm not the only one''' \"I'm not the only one\" 이렇게 사용하게 되면 문자열에 따옴표가 얼마든지 포함되어도 에러가 발생하지 않는다.\n\u003e '''I wish this would be over now But I know that I still need you here''' 'I wish this would be over now\\nBut I know that I still need you here' 그냥 따옴표와는 다르게 여러 줄로 개행된 문자열을 표현하는데 사용할 수도 있다.\n 일반적인 따옴표로 여러 줄로 개행된 문자열을 표현하려면 이스케이프 문자를 사용해야 한다.\n 백슬래시(\\)와 함께 문자를 조합하여 특수한 기능을 사용하는 것으로, 대표적인 이스케이프 문자는 다음과 같다.\n   이스케이프 문자 기능     \\' 작은따옴표 출력   \\\" 큰따옴표 출력   \\/ 슬래시 출력   \\\\ 역슬래시 출력   \\n 개행    연산 더하기 '1'+'1'은 '11'이다?\n\u003e\u003e\u003e '1' + '1' '11' 문자열 사이에서 더하기 연산자(+)는 문자열을 서로 연결해준다.\n숫자 문자열 또한 예외없이 연결만 해주기만 하므로 '1'+'1'은 '11'이 된다.\n곱하기 \u003e\u003e\u003e 'loop ' * 3 'loop loop loop' 문자열에서 곱셈 연산자(*)는 문자열을 반복해서 출력한다.\n인덱싱과 슬라이싱 \u003e\u003e\u003e a = 'Python is simple' \u003e\u003e\u003e a[0] # a의 0번째 문자를 가져온다. 'P' \u003e\u003e\u003e a[-6] # a의 뒤에서 6번째 문자를 가져온다. 's' \u003e\u003e\u003e a[0:6] # a의 0번쨰부터 6번째 문자까지 가져온다. 'Python' \u003e\u003e\u003e a[10:] # a의 10번째 이후 문자를 가져온다. 'simple' \u003e\u003e\u003e a[:] # a의 문자열 전체를 가져온다. 'Python is simple'  index란? 순서가 있는 자료형(문자열, 리스트, 튜플)에서의 요소를 가르키는 번호를 말하며 0번째부터 시작한다.\n 관련함수 \u003e\u003e\u003e a = \"Python is simple\" \u003e\u003e\u003e len(a) # 문자열 길이 반환 16 \u003e\u003e\u003e a.upper() # 대문자 변환 'PYTHON IS SIMPLE' \u003e\u003e\u003e a.lower() # 소문자 변환 'python is simple' \u003e\u003e\u003e a.replace('simple', 'complicated') # 문자열 치환 'python is complicated' \u003e\u003e\u003e a.split() # 문자열 나누어 리스트 리턴 ['python', 'is', 'complicated'] 리스트 자료형 여러 요소를 묶어서 하나의 변수로 활용하기 위해 사용한다.\n\u003e\u003e\u003e a = [1, 'cafe', ['twosome', 'starbucks', 'ediya']] 위 리스트는 3개의 요소(숫자형, 문자열, 리스트)를 담고 있다. 이처럼 리스트 자료형에는 어떤 형식의 데이터가 들어가도 상관 없다.\n리스트 인덱싱과 슬라이싱 문자열과 마찬가지로 리스트에서도 인덱싱과 슬라이싱이 가능하다.\n\u003e\u003e\u003e a[0] 1 \u003e\u003e\u003e a[-1] # 뒤에서 첫번째 요소 ['twosome', 'starbucks', 'ediya'] \u003e\u003e\u003e a[-1][2] # 리스트 a 내 리스트의 2번째 요소 'starbucks' \u003e\u003e\u003e a[:2] [1, 'cafe'] 라스트 관련함수 \u003e\u003e\u003e cafe = a[-1] \u003e\u003e\u003e cafe ['twosome', 'starbucks', 'ediya'] \u003e\u003e\u003e len(cafe) # 리스트 길이 반환 3 \u003e\u003e\u003e cafe.sort() # 내림차순 정렬 \u003e\u003e\u003e cafe ['ediya', 'starbucks', 'twosome'] \u003e\u003e\u003e cafe.reverse() # 오름차순 정렬 \u003e\u003e\u003e cafe ['twosome', 'starbucks', 'ediya'] \u003e\u003e\u003e cafe.pop(0) # 선택한 요소 출력 후 삭제 'twosome' \u003e\u003e\u003e cafe ['starbucks', 'ediya'] \u003e\u003e\u003e cafe.append('hollys') # 요소 추가 \u003e\u003e\u003e cafe ['starbucks', 'ediya', 'hollys'] \u003e\u003e\u003e cafe.insert(0, 'twosomeplace') # 0번쨰 자리에 'twosome' 추가 \u003e\u003e\u003e cafe ['twosome', 'starbucks', 'ediya', 'hollys'] 리스트 연산 \u003e\u003e\u003e a = [1, 2, 3] \u003e\u003e\u003e b = ['a', 'b', 'c'] \u003e\u003e\u003e c = a + b \u003e\u003e\u003e c [1, 2, 3 , 'a', 'b', 'c'] \u003e\u003e\u003e a * 3 [1, 2, 3, 1, 2, 3, 1, 2, 3] 튜플 자료형 튜플은 리스트와 거의 비슷하지만 약간의 차이가 있다.\n 리스트는 []로 감싸지만 튜플은 ()로 감싼다. 리스트와 달리 함수를 이용하여 요소들을 생성, 삭제, 수정하는 것들이 불가능하다.  \u003e\u003e\u003e t = (1, 'cafe', ('twosome', 'starbucks', 'ediya')) \u003e\u003e\u003e t (1, 'cafe', ('twosome', 'starbucks', 'ediya'))  리스트와 마찬가지로 인덱싱, 슬라이싱, 연산 등은 동일하게 가능하다.\n 딕셔너리 자료형 리스트나 튜플이 인덱스를 이용해서 요소를 불러올 수 있는 것과 달리, 딕셔너리는 key라는 문자열로 요소(value)를 불러올 수 있다.\n딕셔너리명 = {Key1:Value1, Key2:Value2, Key3:Value3, ...}  딕셔너리는 중괄호로 정의한다.\n \u003e\u003e\u003e profile = {'name':'python', 'feature':['simple', 'OOP'], 'version':'3.8.0'} \u003e\u003e\u003e profile['feature'] ['simple', 'OOP'] 요소 변경/추가/삭제 \u003e\u003e\u003e profile['version'] = '3.8.1' # 요소 수정 \u003e\u003e\u003e profile['framework'] = 'django' # 요소 추가 \u003e\u003e\u003e profile {'name': 'python', 'feature': ['simple', 'OOP'], 'version': '3.8.1', 'framework': 'django'} \u003e\u003e\u003e del profile['framework'] # 요소 삭제 \u003e\u003e\u003e profile {'name': 'python', 'feature': ['simple', 'OOP'], 'version': '3.8.1'} 딕셔너리 관련함수 \u003e\u003e\u003e profile.keys() # 딕셔너리의 key 리스트 반환 dict_keys(['name', 'feature', 'version']) \u003e\u003e\u003e profile.items() # 딕셔너리의 key-value 리스트 반환 dict_items([('name', 'python'), ('feature', ['simple', 'OOP']), ('version', '3.8.1')]) 집합 자료형 집합에 관련된 작업을 쉽게 하기 위해서 만들어진 자료형이다.\n\u003e\u003e\u003e s1 = set([1,2,3]) \u003e\u003e\u003e s1 {1, 2, 3} 특징  중복을 허용하지 않는다. 순서가 없다  \u003e\u003e\u003e s2 = set('hello') \u003e\u003e\u003e s2 {'l', 'e', 'o', 'h'} 집합 관련함수 \u003e\u003e\u003e s2.add(4) # 요소 추가 \u003e\u003e\u003e s2 {'e', 4, 'l', 'o', 'h'} \u003e\u003e\u003e s2.update(1, 2, 3) # 여러 요소 추가 {1, 'e', 2, 3, 4, 'l', 'o', 'h'} \u003e\u003e\u003e s2.remove(2) {1, 'e', 3, 4, 'l', 'o', 'h'}  여러 요소를 추가할 때는 update함수에 리스트로 값을 대입한다.\n 집합 연산 집합 자료형은 교집합, 합집합, 차집합 등의 연산을 제공한다.\n\u003e\u003e\u003e s1 \u0026 s2 # s1과 s2의 교집합  {1, 3} \u003e\u003e\u003e s1 | s2 # s1과 s2의 합집합 {1, 2, 3, 'e', 4, 'l', 'o', 'h'} \u003e\u003e\u003e s1 - s2 # s1과 s2의 차집합 {2} 논리형 참(True) 혹은 거짓(False)를 나타내는 자료형이다.\n 파이썬에서는 논리형을 첫 글자 대문자로 표기한다. (True 혹은 False)\n \u003e\u003e\u003e 1 == 1 True \u003e\u003e\u003e 3 \u003c 1 False \u003e\u003e\u003e 3 \u003e 2 and 2 \u003c 1 False 관련 연산자    관계연산자 설명     x \u003c y x가 y보다 작다   x \u003e y x가 y보다 크다   x == y x와 y가 같다   x != y x와 y가 같지 않다   x \u003c= y x가 y보다 작거나 같다   x \u003e= y x가 y보다 크거나 같다       논리연산자 설명     x and y x와 y 모두 참(True)이다   x or y x와 y 중 하나가 참(‘True’)이다   not x x가 거짓이다       멤버연산자 설명     x in y x가 y에 포함되어 있다   x not in y x가 y에 포함되어 있지 않다     여기서 y는 리스트, 튜플, 문자열 중 하나이다.\n 자료형의 참 거짓 자료형에는 이미 참, 거짓이 정해져 있는 경우도 있다.\n\u003e\u003e\u003e bool([1,2,3]) True \u003e\u003e\u003e bool([]) False \u003e\u003e\u003e bool(0) False \u003e\u003e\u003e bool(3) True  “\"(빈 문자열), [ ](빈 리스트), ()(빈 튜플), {}(빈 딕셔너리), 0 (빈 숫자), None의 경우, 모두 거짓(False)이다.\n ","excerpt":"프로그래밍을 하는데 있어서 자료형은 매우 중요하다. 어떤 형태의 데이터를 활용할 것인가에 따라서 사용해야 하는 자료형이 달라지 …","ref":"/til/python/study/data-type/","title":"Data Type"},{"body":"1973년, 미국 국립기술표준원(NIST)에서 국가적으로 사용할 대칭키 암호시스템으로 채택\n구조  데이터 길이  평문: 64bit 키: 56bit(오류검출비트 8bit 제외) 암호문: 64bit   2개의 P-box  초기 전치(initial permutation) 최종 전치(final permutation)   라운드 키 생성기  56비트 키에서 48비트의 라운드 키를 생성 이러한 라운드 키는 각 라운드에서 사용됨   라운드 함수  Feistel 암호로 되어 있음 혼합기(mixer) 교환기(swapper)가 존재    DES 함수 라운드 함수를 구성하는 함수로 4가지로 이루어져 있음\n 확장 P-box 키 XOR 8개의 S-box 단순 P-box  설계 기준  S-box  비선형 함수 혼돈을 제공 한 비트가 변경되면 두 비트 이상이 바뀜   P-box  확산의 성질을 만족    3DES DES를 세 번 반복해서 사용한 것으로 암호화-복호화-암호화 과정을 거친다.\n특징  H/W에서 효율적이나 S/W에서 비효율적 느린 처리 속도  종류  2개의 키를 이용하는 3중 DES  첫 번째와 세 번째에서 동일한 키 사용 기지 평문 공격에 취약   3개의 키를 이용하는 3중 DES(DES-EDE3)  평문을 첫 번째 키로 암호화 그 결과를 두 번째 키로 복호화 그 결과를 세 번째 키로 암호화    ","excerpt":"1973년, 미국 국립기술표준원(NIST)에서 국가적으로 사용할 대칭키 암호시스템으로 채택\n구조  데이터 길이  평문: …","ref":"/til/security/cryptology/symmetric-cryptography/des/","title":"DES"},{"body":"구조  사용자 대행자  MUA(Mail User Agent)  메시지 작성, 읽기, 답장 보내기 등을 수행하는 S/W     전송 대행자  MTA(Mail Transfer Agent)  전자우편을 SMTP을 이용하여 다른 전자우편 서버로 전달하는 S/W   MDA(Mail Delivery Agent)  전자우편을 수신자의 사서함으로 전달하는 S/W     접근 대행자  MAA (Mail Access Agent)  메시지를 검색하고자 할 때 사용 IMAP, POP3      프로토콜 SMTP(Simple Mail Transfer Protocol)  MTA 클라이언트와 서버를 규정하는 공식적인 프로토콜(TCP/25) 송신자와 송신자의 메일서버 사이 그리고 두 메일 서버들 사이에서 총 두 번 사용된다.  POP3(Post Office Protocol ver3)  메일을 PC에 다운할수 있도록 해주는 프로토콜(TCP/110) 다운시 서버에 있던 메일 내용은 삭제  IMAP4(Internet Mail Access Protocol ver4)  서버서 메일을 읽는 프로토콜(TCP/143) 제공 기능  전자우편 내려 받기 전에 헤더 검사 내용 검색, 부분적 다운로드 메일서버에서 편지함을 생성, 삭제, 이름 변경    보안 기술 PEM(Privacy Enhanced Mail)  IETF서 인터넷 드래프트로 채택 기밀성, 인증, 무결성, 부인방지를 지원하는 이메일 보안 기술 SMTP에 암호화된 정보, 전자서명, 암호화를하여 전송 이론 중심, 사양 방대, 구현의 복잡성 때문에 많이 사용되지 않음  PGP(Pretty Good Privacy)  구현이 용이하여 널리 사용 다양한 플랫폼 지원 인증된 알고리즘 사용 기밀성, 메시지 인증, 사용자 인증, 송신 부인방지 지원 수신 부인방지는 지원하지 않음  S/MIME(Secure Multipurpose Internet Mail Extensions)  PEM의 구현 복잡성, PGP의 낮은 보안성을 보완하기 위해 RSADSI 기술을 기반으로 개발된 기술 메시지 기밀성, 무결성, 사용자 인증, 송신 부인 방지 기능 제공 보안 메커니즘  전자서명: DSS(디지털 서명 표준), RSA 알고리즘 세션키 암호화: Diffie-Hellman, RSA 알고리즘    동작  사용자가 메시지를 보내기 이전, 보안 메커니즘(전자 서명, 암호화) 설정 MIME 형태로 작성된 메시지를 S/MIME 메시지로 변환 송신자는 메일 서버로 전송, 수신자는 S/MIME 클라이언트를 통해 메시지 수신   MIME: 전자우편을 통해 ASCII가 아닌 데이터가 송신될 수 있도록 허용하는 부가적인 프로토콜\n 스팸메일 보안 대책 메일서버 등록제 (SPF, Sender Policy Framework)  메일 헤더에 표시된 IP가 실제로 메일을 발송한 서버 IP와 일치하는지 비교함으로써 발송자 정보의 위변조 여부를 판단 발송자의 서버를 DNS에 미리 등록하고 수신자의 서버에 메일이 도착하면 등록된 서버로부터 발신되었는지 확인하여 수신자에게 전달되기 전에 스팸메일을 차단하는 기술 (오픈 소스 기반) 필터링 방식에 비해 서버 및 네트워크 자원 소모가 낮고 잘못 탐지할 가능성이 낮음  스팸 필터 솔루션  메일서버 앞단에 위치하여 프록시 메일서버로서 동작하며, SMTP 프로토콜을 이용한 DoS 공격이나 폭탄 메일, 스팸 메일을 차단 주요 기능  메일 헤더 필터링 제목 필터링 본문 필터링 첨부파일 필터링   본문 검색 기능으로 내부 정보 유출 차단도 가능  ","excerpt":"구조  사용자 대행자  MUA(Mail User Agent)  메시지 작성, 읽기, 답장 보내기 등을 수행하는 S/W      …","ref":"/til/security/application/email/","title":"Email"},{"body":"라이선스 종류 GPL  General Public License\n 리눅스는 GNU프로젝트와 연계하여 발전해왔기 때문에 FSF(Free Software Foundation)의 GPL(General Public License)를 따른다.\n  GPLv1: 프로그램의 소스 코드를 공개하지 않은 채 바이너리 파일만 배포하는 것을 막기 위해 GPLv1 프로그램을 배포할 때는 사람이 이해하기 쉬운 코드를 같이 배포해야 한다는 조건을 닮. GPLv2: 특허로 인해 추가적으로 돈을 지불해야 하거나 소스코드 공개가 불가능하여 실행 바이너리 프로그램만 배포할 경우, 소스 코드뿐만 아니라 실행 바이너리 프로그램까지 배포할 수 없도록 보완 GPLv3: 소프트웨어 특허 대처법, 다른 라이선스와의 호환성, 원시 코드 구성 부분, 디지털 제한 관리(DRM) 관련 내용이 추가   LGPL  Library/Lesser General Public License\n GPL의 강력한 제약을 완화시키기 위해서 탄생했다. 기존 GPL과 다른 점은 자유 소프트웨어뿐만이 아니라 독점 소프트웨어에서도 사용 가능하다는 것이다.\n  다만, LGPL 라이브러리의 소스 코드를 수정한 것은 2차적 파생저작물에 해당하므로 라이브러리 소스코드를 공개해야 함. LGPL로 개발된 이후에 GPL로 변경하는 것은 가능.   BSD  Berkeley Software Distribution\n 버클리 캘리포니아대학에서 배포하는 공개소프트웨어 라이선스로 해당 소프트웨어를 누구나 개작할 수 있으며, 수정 후 배포가 가능하다.\n  수정 후 재배포는 의무사항이 아니므로, 2차적 파생물에 대한 원시 소스코드 비공개도 허용됨. BSD 라이선스는 소스코드를 공개하지 않는 상용 소프트웨어에서도 사용이 가능함.   Apache 아파치 소프트웨어 재단에서 자체적으로 만든 소프트웨어에 대한 규정. 아파치 재단의 프로그램은 모두 이 라이선스를 적용하고 있음.\n  v2.0: 누구든 자유롭게 아파치 소프트웨어를 다운 받아 부분 혹은 전체를 개인적/상업적 목적으로 이용 가능 재배포시 소스코드를 공개하지 않아도 됨. 다만 반드시 아파치 라이선스 v2.0을 사용함을 명시해야 함.   MPL  Mozila Public License\n 모질라 재단에서 규정한 라이선스로 BSD와 GPL 라이선스의 혼합적 성격을 띈다. MPL은 파이어폭스를 비롯한 모질라 재단 프로그램에 적용되어 있으며, 썬 마이크로시스템즈의 라이선스인 CDDL(Common Development and Distribution License) 탄생에 영향을 주었다.\n  소스 코드 수정 시 소스 코드 공개 필수 MPL과 다른 코드를 결합해서 만든 프로그램의 경우, MPL 코드만 공개해도 됨.   MIT  Massachusetts Institute of Technology\n 미국 MIT 대학에서 개발한 라이선스로 BSD 라이선스를 기초로 작성되었기 때문에 BSD와 매우 유사하다. 이 라이선스가 적용된 소프트웨어에는 X 윈도우 시스템, JQuery, Node.js가 있다.\n  해당 소프트웨어를 누구나 개작가능 수정본의 재배포 시 소스 비공개 가능   라이선스 특징 비교    라이선스 무료이용 배포 소스코드 취득 및 수정 2차적 저작물 소스코드 공개 독점 소프트웨어     GPL 무료 허용 가능 공개 불가능   LGPL 무료 허용 가능 공개 가능   BSD 무료 허용 가능 비공개 가능 가능   Apache 무료 허용 가능 비공개 가능 가능   MPL 무료 허용 가능 공개 가능   MIT 무료 허용 가능 비공개 공개 가능    ","excerpt":"라이선스 종류 GPL  General Public License\n 리눅스는 GNU …","ref":"/til/linux/linux-master/license/","title":"License"},{"body":"네트워크 자원들에 대하여 적절한 관리행위\n 네트워크 사업자와 사용자에게 안정적인 네트워크 서비스 제공 네트워크의 규모가 커질 경우 전체 네트워크의 원할한 동작을 위함 ISP 사업자들이 인터넷 서비스에 대한 신뢰도 향상  관리 기능  계정 관리: 개방시스템에서 일어나는 어떤 활동에 의해 소비되는 자원에 관한 모든 정보 관리  인증, 과금 등 기능   구성 관리: 구성원들 사이의 관계와 상태를 보여줌 성능 관리 장애 관리 보안 관리: 패스워드, 암호화된 데이터링크를 유지 보수 및 보안 행위를 기록  암호화 사용, 암호화 키 생성 및 분배 관리    SNMP(Simple Network Management Protocol) 관리자가 라우터나 서버인 에이전트 집단을 제어 및 관리\n정보 교환 방식  폴링(Polling): 에이전트의 정보를 주기적으로 수집하는 것 트랩(Trap): 에이전트에서 이벤트가 발생하는 경우 관리자에게 인터럽트  구성 요소  SMI(Structure of Management Information)  객체에 이름을 붙이고 객체 유형을 정의   MIB(Management Information Base)  관리될 각 개체를 위해 객체의 수를 결정 SMI를 통해 생성된 객체를 유형에 연결   PDU(Protocol Data Unit)  데이터 통신에서 상위 계층이 전달한 데이터에 붙이는 제어정보 SNMPv3는 8개 유형의 PDU을 정의   커뮤니티 스트링(Community String)  관리자가 에이전트로부터 데이터를 요청하기 위해 사용하는 패스워드 Read-only(Public)  매니저가 MIB에 보관된 데이터를 읽을 수 있음   Read-Write(Private)  매니저가 데이터를 읽고 쓸 수 있음      원격 접속 서비스  Telnet  가상 터미널 서비스에 대한 표준 TCP/IP 프로토콜 원격 시스템과 연결에 사용   Rlogin  원격지 접속을 지원하는 프로토콜(BSD기반 간)   SSH  암호화된 원격 로그인 수행 Telnet과 RLogin을 대체하기 위해 사용 SSH-1과 SSH-2는 서로 호환되지 않음    SSH 컴포넌트  SSH 전송 계층 프로토콜(SSH-TRANS)  TCP상에 안전한 채널을 생성하는 프로토콜   SSH 인증 프로토콜(SSH-AUTH)  SSH는 서버에 대해 클라이언트를 인증하는 소프트웨어를 호출   SSH 연결 프로토콜(SSH-CONN)  여러개의 논리적 통신채널의 다중화를 수행   SSH 응용(SSH-Application)  여러개의 응용 프로그램이 연결을 사용할 수 있도록 설정    기능  포트 전달(Port Forwarding)  보안서비스를 제공하지 않는 프로그램에 접속하기 위해 SSH에서 이용 가능한 안전한 채널 사용   SSH 터널링  원격의 사설 네트워크를 로컬 네트워크처럼 사용가능    암호화 SSH는 암호화 통신 할 때 공개키 암호기법을 사용한다.\n 접속과 인증: RSA 통신: Blowfish, DES, 3DES, RC4, IDEA 등 과정  클라이언트가 서버로부터 공개키를 얻어옴 클라이언트가 자신의 개인키로 데이터를 암호화, 서버의 공개키로 암호화 후 서버에 전송 서버는 암호화된 데이터를 자신의 사설키로 복호화, 클라이언트의 공개키로 데이터 복호화 후 데이터 읽음    ","excerpt":"네트워크 자원들에 대하여 적절한 관리행위\n 네트워크 사업자와 사용자에게 안정적인 네트워크 서비스 제공 네트워크의 규모가 커질  …","ref":"/til/security/network/management/","title":"Management"},{"body":"장고는 MTV(Model, Template, View) 패턴을 따른다. 해당 디자인 패턴을 통해서 웹 페이지가 어떻게 동작하는지 그 로직에 대해서 간단히 살펴보도록 하자.\nMTV 구조 MTV 패턴을 사용하는 웹 페이지는 다음과 같이 동작한다.\n웹 서버의 데이터를 단순히 조회하는 경우, 데이터베이스 상의 데이터는 Model을 통해서 가져오게 된다. 그리고 가져온 데이터는 View에서 적절히 가공되며 이것이 Template으로 전달된다.\n결과적으로, 사용자는 크롬과 같은 웹브라우저를 통해서 Template에 표현된 웹페이지를 볼 수 있다.\n구성 요소 Model Model은 데이터베이스 상에 저장되는 데이터를 처리하는 부분으로, 데이터베이스의 데이터 형식이 클래스로 정의된다. 장고에서는 ORM이라는 데이터베이스를 관리하는 강력한 기능을 제공하는데, 이 기능은 Model에서 정의한 데이터 형식으로 데이터베이스를 생성해주는 것이다. 이후 교안에서 이것의 사용방법에 대해서 자세히 다루도록 하겠다.\nTemplate Template은 웹페이지에서 실질적으로 보여지는 부분으로, 주로 html 파일로 정적인 페이지를 구성된다. 장고에서 제공하는 문법(템플릿 언어, Template Language)을 사용하면 페이지를 동적으로 작동하게 할 수 있다.\nView View는 웹 애플리케이션 상에서 데이터를 처리하는 로직을 작성하는 부분이다. 데이터베이스의 조회, 추가, 삭제, 수정 등의 로직들이 모두 여기서 이루어지며, 이것을 통해 Template을 동적으로 처리할 수 있다.\n","excerpt":"장고는 MTV(Model, Template, View) 패턴을 따른다. 해당 디자인 패턴을 통해서 웹 페이지가 어떻게 동작하는 …","ref":"/til/django/study/mtv-pattern/","title":"MTV Pattern"},{"body":"기본 요소  구문(Syntax)  전송하고자 하는 데이터의 형식, 부호화, 신호 레벨등을 규정   의미(Semantics)  두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정   시간(Timing)  두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정    기능 주소 설정 한 개체가 상태 개체에 데이터를 전송하려면 상대의 이름을 알아야 하는데, 프로토콜에는 각 전송 계층에 맞는 주소를 지정하는 기능이 있다.\n순서 제어 프로토콜 데이터 단위가 전송될 때 보내지는 순서를 명시하는 기능으로, 연결 지향성에만 사용한다.\n 프로토콜 데이터 단위(PDU, Protocol Data Unit): 데이터 전송 시, 일정 크기의 데이터 블록\n 순서를 지정하는 이유는 전달, 흐름 제어, 오류 제어 등을 위해서이다. PDU를 상대 개체에 보내면 수신측에서 순서에 맍게 데이터를 재구성한다. 이때 잘못된 PDU는 재전송을 요구한다.\n단편화 및 재조합 대용량 파일의 경우 한 번에 전달하는 것이 불가능하므로 전송 효율이 높은 작은 단위로 나누어 전송한다. 이를 수신하는 시스템에서는 응용 프로그램에서 사용하기 위해 재조합해야 한다.\n캡슐화 데이터에 제어 정보를 덧붙이는 것으로 SDU에 PCI를 더하는 과정이라 할 수 있다.\nPDU(Protocol Data Unit) = SDU(Service Data Unit) + PCI(Protocol Control Information) # SDU: 전송하려는 데이터 # PCI: 제어 정보(주소, 오류검출코드, 프로토콜 제어 정보 등) 이러한 캡슐화는 해커로부터 통신 내용을 숨길 수 있게 한다.\n연결 제어 데이터를 교환할 때 연결 설정 여부에 따라 두 가지로 나뉨\n 연결 지향형 데이터 전송  연결 설정 -\u003e 데이터 전송 -\u003e 연결 해제 데이터 전송 중 연결 지속 대표적 예시: TCP   비연결 지향형 데이터 전송  이렇게 전송되는 데이터 = 데이터그램 대표적 예시: UDP    흐름 제어 송신측에서 오는 데이터의 양이나 속도를 조절하는 기능으로 정보 유실을 방지한다.\n 정지-대기(stop and wait)  패킷 하나를 보낸 후 응답이 오면 다음 패킷 전송   슬라이딩 윈도우(sliding window)  가용 데이터 분량의 패킷을 한번에 보낸 뒤 응답받음 이후 동일한 양의 패킷을 한번에 전송    오류 제어 데이터를 교환할 때 SDU나 PCI가 잘못되었을 경우, 이를 발견하는 기법\n 패리티 비트(parity bit) 순환 잉여도 검사(CRC, Cyclic Redundancy Check)  순서를 검사하거나 특정 시간 안에 받지 못하면 재전송을 요구하는 방식\n동기화 데이터를 전송할 때 각 개체는 특정 타이머 값이나 윈도우 크기 등을 기억해야 하는데, 이것들을 공유하는 것을 동기화라 한다.\n다중화 통신 선로 하나에서 여러 시스템이 동시에 통신할 수 있는 기법\n전송 서비스 우선순위 결정, 서비스 등급과 보안 요구 등을 제어하는 서비스\n종류 프로토콜의 종류를 설명하기 위해서 OSI 7계층과 함께 살펴보도록 하겠다.\n데이터 링크 계층 OSI 7계층에서 물리 계층 위에 있는 2번째 계층이다. 하드웨어에 대한 MAC(Media Access Control) 주소를 기반으로 하드웨어 간 통신을 위한 프로토콜을 제공한다.\n이더넷 프로토콜  제록스의 PARC에서 1970년대에 개발 패킷 최소 길이: 64KB, 최대 길이: 1,518KB 1980년대 IEEE 802.3이 규약의 기초 현재는 CSMA/CD LAN을 이르는 말로 사용됨  네트워크 계층 OSI 7계층의 3계층으로, 논리적인 주소인 IP주소를 이용해 통신하기 위한 프로토콜을 제공한다.\nARP(Address Resolution Protocol)  네트워크 계층에서의 통신을 위해서는 하위 계층인 데이터 링크 간의 통신 경로가 확보되어야 함.  IP간 통신을 위해서는 MAC 주소를 확보가 우선   ARP은 IP를 보조하기 위한 프로토콜  MAC 주소를 사용해 통신을 하지만 정보로 담기는 값 = IP 데이터 링크 계층과 네트워크 계층 중간에 위치한다고 볼 수 있음   RARP는 ARP의 반대 역할  MAC 주소를 가지고 IP를 확인하는 프로토콜    IP(Internet Protocol)  하위 계층의 서비스를 이용하여 두 노드 간의 데이터 전송 경로를 확립  데이터 링크 계층은 같은 회선(LAN 구간) 간 통신 네트워크 계층은 회선이 서로 다른 노드 사이(WAN 구간) 통신   IP(v4)는 32자리 2진수로 개수 제한  체계적 사용을 위한 규칙이 있음 A~E클래스로 구분  A 클래스: 첫 자리 네트워크 주소, 나머지 호스트 주소 B 클래스: 두 자리 네트워크 주소, 나머지 호스트 주소   C 클래스: 세 자리 네트워크 주소, 나머지 호스트 주소    ICMP(Internet Control Message Protocol)  호스트 서버와 인터넷 게이트웨이 사이에서 메시지 제어, 오류 검출 비연결 지향형 프로토콜인 IP를 보조하여 패킷 전송을 보장한다. ping이 대표적인 예  IGMP(Internet Group Management Protocol) 멀티 캐스트에 관여하는 프로토콜로 멀티캐스트 그룹을 관리\nIP 통신 방식 - 유니캐스트 - 한 호스트에서 다른 호스트로 전송한 것 - 일반적인 IP 데이터 전송은 모두 이것을 사용 - 브로드캐스트 - 호스트에서 IP 네트워크 상 전체 호스트로 데이터 전송 - 일반적인 브로트캐스트는 `255.255.255.255` - 멀티캐스트* - 그룹에 속한 모든 호스트에게 전달 - D 클래스 주소 대역을 사용 전송 계층 프로토콜 응용 프로그램 주소를 포트 번호로 이용해 통신하는 프로토콜을 제공\nTCP(Transmission Control Protocol) 전송 계층에서 동작하는 연결 지향형 프로토콜\n 특징  높은 신뢰성 연결의 설정과 해제 시간 초과와 재전송 가상 회선 연결 방식 데이터 체크섬 데이터 흐름 제어    연결을 설정하는 과정을 3-way handshacking이라 한다.\n연결 생성 과정\n 클라이언트는 포트가 Closed 상태이고 서버는 Listen 상태 클라이언트는 임의의 포트 번호를 열고 서버에 SYN을 보냄 서버는 클라이언트의 요청을 받고 SYN + ACK 패킷을 보냄 클라이언트가 연결 요청에 대한 서버 응답을 확인했음을 ACK 패킷을 보냄  연결 해제 과정\n 통신 중인 상태(Established) 클라이언트가 서버에 FIN 패킷을 보내서 통신을 끊고자 함을 전달 서버는 연결 종료 요청을 확인하고 ACK 패킷으로 응답, 연결을 종료한다는 의미에서 FIN 패킷을 보냄 클라이언트는 연결 종료 요청에 대한 서버의 응답을 확인했다는 의미로 ACK 패킷을 서버에 보냄  UDP(User Datagram Protocol) 비연결 지향형 프로토콜로 상대방이 보낸 응답에 확인하지 않는다.\n 특징  데이터의 목적지 확인 절차를 생략하므로 네트워크 부하가 적음 데이터의 비신뢰성 수신한 데이터 무결성 보장 X    응용 계층 우리가 사용하는 응용 프로그램이 네트워크와 통신하기 위해 사용하는 프로토콜\nFTP(File Transfer Protocol) 파일 전송을 위한 가장 기본 프로토콜\n 연결 방식  컨트롤 연결  21번 포트를 열고 클라이언트 요청 대기(수동적 포트 오픈) 클라이언트에서 포트를 설정하고 FTP 요청(능동적 포트 오픈)   데이터 연결  클라이언트에서 임의의 포트 오픈 (수동적 포트 오픈) 클라이언트에서 PORT 명령어로 포트 번호를 서버에게 전송 서버에서 20번 포트를 오픈 (수동적 포트 오픈)      Telnet 사용자가 원격에 있는 서버에 로그인하도록 TCP 연결을 설정하며, 단말기가 원격 컴퓨터 바로 옆에 있는 것처럼 직접 조작할 수 있도록 한다.\n 기능  네트워크 가상 단말기 기능 클라이언트-서버 간 통신 옵션 교환 메커니즘 양단 통신 대칭적 수행    ","excerpt":"기본 요소  구문(Syntax)  전송하고자 하는 데이터의 형식, 부호화, 신호 레벨등을 규정   의미(Semantics)   …","ref":"/til/network/protocol/","title":"Protocol"},{"body":"정의 선택자(Selector): HTML 태그의 모양을 꾸밀 스타일 시트를 선택하는 기능\n태그 선택자  태그 이름이 선택자로 사용됨 선택자와 같은 이름의 모든 태그에 CSS3 스타일 시트 적용  class, id 선택자 class 선택자  .으로 시작하는 이름의 선택자 HTML 태그의 class 속성으로 지정  \u003chead\u003e \u003cstyle\u003e .warning {color : red } body.main { background : aliceblue } \u003c/style\u003e \u003c/head\u003e \u003cbody class=\"main\"\u003e \u003cdiv class=\"warning\"\u003e 60점 이하는 F \u003c/div\u003e \u003c/body\u003e id 선택자  #으로 시작하는 이름의 선택자 HTML 태그의 id 속성으로 지정  \u003chead\u003e \u003cstyle\u003e #list { background : aliceblue } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cul id = \"list\"\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJS\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e 특징 id 선택자 특징  id 속성의 목적은 각 태그를 유일하게 구분 적합한 활용  id 선택자는 여러 태그 중 특정 태그에만 CSS 스타일을 적용    class 선택자 특징  태그의 종류와 관계없이 class 활용 가능 적합한 활용  여러 태그를 하나의 그룹으로 묶어 동일한 CSS 스타일을 적용    이외 선택자 선택자 조합  2개 이상의 선택자 조합  조합에 적합한 HTML 태그에만 사용   자식 선택자  부모 자식 관계인 두 선택자를 \u003e기호로 조합 예) div \u003e strong {background-color: yellow;}   자손 선택자  자손 관계인 2개 이상의 태그 나열 예) div strong {background-color: yellow;}    전체 선택자와 속성 선택자  전체 선택자  와일드 문자(*)를 사용하여 모든 태그에 적용시키는 선택자   속성 선택자  HTML 태그의 특정 속성에 대해 값이 일치하는 태그에만 스타일 적용하는 선택자 ex) input[type=text] { color : red; }    가상 클래스 선택자  어떤 조건이나 상황에서 스타일을 적용하도록 만든 선택자 40여개의 가상 클래스 선택자 존재     셀렉터 설명     :hover 마우스가 올라갈 때 스타일 적용   :active 마우스로 누르고 있는 상황에서 스타일 적용   :focus 폼 요소가 키보드나 마우스 클릭으로 포커스를 받을 때 스타일 적용   :link 방문하지 않은 링크에 스타일 적용   :visited 방문한 링크에 스타일 적용    ex) a:visited { color : green; } 방문한 사이트 링크에 color : green 스타일 적용\n","excerpt":"정의 선택자(Selector): HTML 태그의 모양을 꾸밀 스타일 시트를 선택하는 기능\n태그 선택자  태그 이름이 선택자로  …","ref":"/til/css/selector/","title":"Selector"},{"body":"메타 태그 HTML 페이지에 대한 메타 데이터를 담기 위한 태그 \u003cbase\u003e, \u003clink\u003e, \u003cscript\u003e, \u003cstyle\u003e, \u003ctitle\u003e 등이 있음.\n메타 태그들은 \u003chead\u003e 태그안에 작성 \u003cscript\u003e는 \u003cbody\u003e안에 작성하는 경우도 있음\nbase 웹 페이지들은 기본 URL과 페이지가 출력될 윈도우 지정\n\u003chead\u003e \u003cbase href=\"http://mysite.com/score/\"\u003e \u003c/head\u003e link 외부 자원 연결\n\u003chead\u003e \u003clink type=\"text/css\" rel=\"stylesheet\" href=\"mystyle.css\"\u003e \u003c!--해당 주소에 있는 파일을 가져올 수 있음--\u003e \u003c/head\u003e meta 다양한 메타 데이터 표현\n 웹 페이지의 저작자, 문자 인코딩 방식, 내용 등  \u003cmeta name=\"author\" content=\"반정훈\"\u003e \u003cmeta name=\"description\" content=\"내용 설명\"\u003e \u003cmeta name=\"keywords\" content=\"키워드\"\u003e \u003cmeta charset=\"utf-8\"\u003e 기본 태그 img \u003cimg src=\"이미지 소스\" alt=\"이미지 손상시 표시\" width=\"가로\" height=\"세로\"\u003e list 순서 있는 리스트  \u003col type=\"A\"\u003e \u003cli\u003e순서\u003c/li\u003e \u003cli\u003e있는\u003c/li\u003e \u003cli\u003e리스트/li\u003e \u003c/ol\u003e  \u003col\u003e은 type속성을 이용해서 표시기호를 변경할 수 있음. ex) type = \"A\" 알파벳 대문자로 표기\n 순서 없는 리스트  \u003cul\u003e \u003cli\u003euno\u003c/li\u003e \u003cli\u003edos\u003c/li\u003e \u003cli\u003etres\u003c/li\u003e \u003c/ul\u003e 정의 리스트  \u003cdl\u003e \u003c!--용어--\u003e \u003cdt\u003eMarkdown\u003c/dt\u003e \u003c!--설명--\u003e \u003cdd\u003e일반 텍스트 문서의 양식을 편집하는 문법이다.\u003c/dd\u003e \u003c/dl\u003e table \u003ctable\u003e은 표 생성 태그로 \u003ctr\u003e, \u003cth\u003e, \u003ctd\u003e 태그를 이용해서 실제 내용을 삽입한다.\n\u003ctable\u003e \u003ccaption\u003e표제목\u003c/caption\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e이름\u003c/th\u003e \u003cth\u003e학번\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003c!--표 제목--\u003e \u003ctfoot\u003e \u003ctr\u003e \u003ctd\u003e인원\u003c/td\u003e \u003ctd\u003e1명\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c!--표 밑글--\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e반정훈\u003c/td\u003e \u003ctd\u003e60181895\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c!--표 내용--\u003e \u003c/table\u003e 비정형 표  colspan: 셀의 세로 길이를 지정 rowspan: 셀의 가로 길이를 지정  hyperlink \u003ca\u003e 태그의 href 속성을 이용하여 하이퍼링크를 작성한다.\n 같은 웹 사이트에 있는 웹 페이지에 연결  \u003ca href=\"pick.html\"\u003e\u003c/a\u003e  다른 웹 사이트 웹페이지 연결  \u003ca href=\"이동할 사이트 주소\"\u003e\u003c/a\u003e  이미지 하이퍼링크 만들기  \u003ca href=\"주소\"\u003e \u003cimg\u003e \u003c/a\u003e target 속성\n blank: 새로운 윈도우로 링크 접속 _self: 현재 윈도우로 링크 접속 _parent: 파생되어 온 윈도우로 링크 접속 _top: 브라우저 윈도우로 링크 접속  앵커\nhtml 페이지 내의 특정 위치 지정\n\u003ca href=#meta\u003e 메타태그 \u003c/a\u003e \u003c!-- 지정한 id로 이동--\u003e \u003ca href=#standard\u003e 기본태그 \u003c/a\u003e \u003ch1 id=\"meta\"\u003e 메타태그 \u003c/h1\u003e \u003ch1 id=\"standard\"\u003e 기본태그 \u003c/h1\u003e Inline Frame \u003ciframe\u003e을 통해서 인라인 프레임을 생성 HTML 페이지 내에 HTML 페이지 삽입\n\u003ciframe src=\"html 파일\" width=\"100\" height=\"100\"\u003e\u003c/iframe\u003e 미디어삽입 HTML5에서 웹 페이지에 미디어 삽입 표준화\n audio, video 태그  플러그인 필요 없음 지원되는 확장자 미디어 재생   비표준 미디어 재생시  flash embed, object 태그 이용    video \u003cvideo src=\"파일\" width=\"320\" height=\"240\" controls autoplay loop\u003e\u003c/video\u003e \u003cvideo controls autoplay\u003e \u003csource src=\"파일\"\u003e \u003c!--source 태그로 지정 가능--\u003e \u003c/video\u003e  autoplay 속성은 크롬에서는 지원하지 않는다.\n audio \u003caudio src=\"파일\" controls autoplay loop\u003e\u003c/audio\u003e ","excerpt":"메타 태그 HTML 페이지에 대한 메타 데이터를 담기 위한 태그 \u003cbase\u003e, \u003clink\u003e, \u003cscript\u003e, \u003cstyle\u003e, …","ref":"/til/html5/tag/","title":"Tag"},{"body":"유닉스 시스템  대화식 운영체제 : Shell(셸) 멀티태스킹, 멀티유저, 호환성/이식성 우수 계층적 파일시스템 뛰어난 통신기능 및 다양한 유틸리티 제공  커널  항상 메모리에 상주하면서 하드웨어 자원을 제어 프로세스 스케줄링, 기억장치 관리, 파일관리, 시스템 호출, 입출력 서비스 제공 가장 하위 수준에서 하드웨어와 직접 관계  쉘  커널과 사용자 간의 인터페이스 기능  명령어 해석 기능 프로그래밍 기능 사용자 환경 설정 기능    파일 시스템 계층적 파일시스템으로 구성\n i-node(index node)  파일에 대한 정보를 기억하는 약 120Byte의 고정된 크기의 구조체 구성요소  파일에 대한 정보(파일의 허가권, 소유권, 그룹, 최근 수정된 시간) 파일에 할당된 데이터 블록의 주소를 저장하는 필드     Super Block  파일시스템의 정보를 유지하는 자료구조 파일의 요약 정보와 사용하지 않는 i-node 디스크 블록 위치정보를 가짐    프로세스  PID 0(swapper)  부팅 시간동안 OS에 의해 생성(커널 프로세스) init과 pagedaemon 프로세스를 만들기 위해 fork/exec를 두 번 실행   PID 1(init)  시스템의 모든 프로세스는 init프로세스의 자손   PID 2(pagedaemon)  swapper와 함께 커널 모드에서 영구적으로 실행(커널 프로세스)   고아 프로세스  부모 프로세스가 자식 프로세스보다 먼저 종료된 경우 발생 init 프로세스가 고아 프로세스의 부모 프로세스 역할   좀비 프로세스  자식 프로세스가 종료되었지만 부모 프로세스가 이를 확인하지 못하는 경우 자식 프로세스는 부모 프로세스가 확인할 때까지 프로세스 테이블에 남음    Run Level /etc/inittab 파일에 정의된 런레벨에 따라 /etc/rc[x].d 디렉터리에 나열된 스크립트가 실행됨\n   Run Level 설명     0 PROM 모드 (BIOS 수준에서 작업) / 시스템 종료 (LINUX)   S, s 시스템 단일 사용자 모드, 로컬 파일시스템이 마운트되지 않은 상태   1 시스템 단일 사용자 모드, 로컬 파일시스템이 마운트된 상태   2 NFS를 지원하지 않는 다중 사용자 모드 (NFS 클라이언트 모드)   3 네트워킹을 지원하는 다중 사용자 모드 (NFS 서버 모드), UNIX 기본 Run Level   4 사용자 정의 레벨   5 시스템 종료 / X윈도우 환경 (LINUX)   6 시스템 재부팅    시스템 보안 passwd 파일  /etc/passwd 사용자와 관련된 정보 저장     항목 설명     user_account 로그인 아이디   user_password /etc/shadow 파일에 암호화되어 저장되어 있음   user_id(UID) 보통 100번 이하는 시스템이 사용, 0번은 시스템 관리자   group_id(GID)    comment 사용자 설명   home_directory 로그인 성공 후에 사용자가 위치할 홈 디렉터리의 절대경로   login_shell 로그인 셸의 절대경로 로그인이 불필요한 계정의 셸은 /sbin/nologin, /bin/false으로 지정    shadow 파일  /etc/shadow 암호화된 패스워드만 저장되도록 하고 관리자만 읽을 수 있도록 제한     항목 설명     user_account 사용자 계정   encryption_pw 일방향 해시 알고리즘 통해 암호화한 패스워드 형식: $id$salt$encrypted_password   last_change 마지막으로 패스워드를 변경한 날   minilife 최소 패스워드 변경 일수(패스워드를 변경할 수 없는 기간)   maxlife 최대 패스워드 변경 일수(패스워드 변경 없이 사용할 수 있는 일수)   warn 경고 일수(maxlife 필드에 지정한 일수가 얼마 남지 않았음을 알림)   inactive 최대 비활성 일수   expires 계정이 만료되는 날    접근 권한 마스크(umask)  시스템 관리자는 /etc/profile에 umask를 설정하여 전체 사용자에게 동일한 umask 값을 적용 개별 사용자에 대한 설정은 $HOME/.profile  권한 상승/디렉터리 접근권한  SetUID: 실제 사용자가 아닌 해당 파일의 소유자 권한으로 실행  /etc/passwd 파일에 적용   SetGID: 실제 사용자 계정이 아닌 소유 그룹의 권한으로 실행  부서원의 권한을 일괄적으로 적용할 때 사용   sticky-bit: 디렉터리에 특별한 접근권한 부여(공유모드)  설정된 디렉터리는 시스템에 있는 모든 사용자가 파일이나 하위 디렉터리를 생성 가능 삭제는 소유주나 root에게만 허용    네트워크 보안 슈퍼 서버(inetd 데몬) n개의 개별 서버를 하나로 통합하여 클라이언트로부터 서비스 요청이 올 때마다 해당 서비스와 관련된 실행 모 듈을 실행\n 시스템에서 불필요한 서비스를 제한하기 위해 /etc/inetd.conf 파일을 수정 inetd 데몬을 다시 가동해야 반영됨  파일 설정  서비스 이름 소켓 타입(TCP-stream/UDP-dgram) 프로토콜 대기설정(TCP-nowait/UDP-wait) 로그인 이름 서버(실행할 파일의 절대 경로) 인자(데몬 실행 시의 명령어)  접근통제 (TCP Wrapper) 외부에서 들어오는 클라이언트에 대해 IP주소를 확인하여 접근통제 수행\n inetd 데몬 tcpd 데몬 접근 권한 검사 해당 데몬에 연결   inted 데몬이 관리하지 않는 standalone 데몬은 inetd 데몬이 통제할 수 없다.\n 설정 파일  접근 허용 리스트: /etc/hosts.allow 접근 제한 리스트: /etc/hosts.deny /etc/hosts.allow → /etc/hosts.deny 순으로 정책이 적용 /usr/sfw/sbin/tcpdchk을 실행하여 오류 점검  PAM(Pluggable Authentication Modules, 장착형 인증 모듈) 각 응용 프로그램에 대한 인증, 사용자 권한, 접근 자원을 선택할 수 있는 라이브러리\n 리눅스 배포판에서 사용자 인증의 핵심 각 프로그램은 인증이 필요한 부분에 PAM 라이브러리를 호출  설정 파일  type: 모듈의 종류  account: 사용자의 시스템 사용권한 확인 auth: 인증기능 password: 비밀번호 설정 및 확인 session: 인증 성공 시 세션   control: 모듈 실행 후 PAM 라이브러리 행동 결정  requisite: 모듈 실패 시 인증 거부 required: 동일 유형 모듈 실행 완료 시점에서 거부 sufficient: 인증 시 승인, 실패 시 재인증 optional: 모듈의 성공, 실패 응답을 상관하지 않음    서버 취약점 분석, 평가 root 계정 원격 접속 제한 원격 접속 시 root 계정으로 직접 로그인할 수 없도록 설정\n패스워드 정책 점검  암호입력 횟수 제한 패스워드 길이 제한 사용 기간 점검 Brute Force Attack, Password Guessing 공격 방지  PATH 변수 확인  root 계정의 PATH 환경변수에 .가 포함되어 있으면 root 계정의 인가 비의도적으로 현재 디렉터리의 명령어가 실행될 수 있음 root 계정의 환경변수 설정 파일(/etc/profile)에서 .을 마지막에 위치시키거나 삭제  $ echo $PATH #변수 출력    파일 및 디렉터리 소유자 설정  유저를 삭제한 경우 소유자가 없는 파일 발생 파일이나 디렉토리를 검색해서 해결  $ find / -nouser -print $ find / -nogroup -print    ","excerpt":"유닉스 시스템  대화식 운영체제 : Shell(셸) 멀티태스킹, 멀티유저, 호환성/이식성 우수 계층적 파일시스템 뛰어난 통신기 …","ref":"/til/security/system/server/unix-and-linux/","title":"UNIX/Linux"},{"body":"인증에는 메시지 인증과 사용자 인증이 존재한다.\n 메시지 인증  메시지 전송 중 발생할 수 있는 수정, 삭제 등 무결성 검증 메시지 암호화, MAC(Message Authentication Code), 해시 함수 등 이용   사용자 인증  정당한 사용자의 접속인지 확인하는 절차 시스템 내 자원의 불법적인 접근을 막음     사용자 인증의 유형에는 지식, 소유, 존재, 행위가 있으며 이 중 둘을 결합하여 사용하는 것을 Two Factor, 그 이상을 결합하여 사용하는 것을 Multi Factor라고 한다.\n 지식 기반 인증 사용자가 알고 있는 것에 의존하는 방법\n 장점  다양한 분야에서 사용 가능 검증이 확실 관리 비용 저렴   단점  소유자의 분실 가능성 공격자의 추측 가능 사회 공학적 공격에 취약(피싱)    패스워드 가장 간단하면서 오랫동안 사용된 개체인증 방식\n고정된 패스워드 접속시 반복해서 사용\n 테이블에 ID/PW 원본 데이터 저장 PW를 해시한 값으로 저장 PW에 솔트(Salt)를 붙여 해시한 값을 저장  일회용 패스워드(OTP, One-Time Password) 동적 패스워드, 인증시 한번 유효\n 사용자와 시스템이 PW 목록 합의하고, 오직 한번만 사용 사용자와 시스템이 PW를 순차적으로 업데이트하기로 합의 사용자와 시스템이 해시함수를 이용하여 순차적으로 업데이트하기로 합의  시도-응답 개인 식별 프로토콜 대칭형 암호와 공개키 암호에 기반하여 도청이 가능한 환경에서 안전\n 일방향 개인 식별 프로토콜: 서버 또는 클라이언트 중에 어느 한 대상을 식별하는 프로토콜 상호 개인 식별 프로토콜: 상호간에 대상을 식별하는 프로토콜  영지식 개인 식별 프로토콜 자신의 비밀정보를 제공하지 않고 자신의 정당한 신분만을 밝힘으로써 식별되는 유형의 프로토콜\n 스마트카드, 원격지 로그인 시 사용자 식별 등  I-PIN(Internet Personal Identification Number) 주민번호 대신에 ID와 PW로 대체하는 수단\n 주민번호 유출예방 본인확인 강화  소유 기반 인증 실생활에서 사용되는 다양한 매체를 이용하여 사용자 인증을 수행\n 장점  신용카드 등 다양한 수단이 사용될 수 있음 입증된 기술(신용카드) 생체 인증보다 경제적   단점  소유물이 없을 경우 인증이 어려움 복제 가능 자산 관리 기능 요구    메모리 카드  정보를 저장할 수 있지만 정보 처리 불가  스마트 카드  정보 저장 및 처리 가능 접촉식과 비 접촉식으로 나뉨  일회용 패스워드(OTP, One-Time Password) OTP용 프로그램에서 사용자 패스워드와 OTP 생성용 입력 값을 입력하면 암호 알고리즘을 사용해서 OTP를 생성하는 사용자 인증 방식\n질의응답 방식  시도-응답 방식 구조가 간단하며 OTP 생성 매체와 인증서버 간 동기화가 필요 없음 사용자가 질의 값을 직접 입력해야 하며 같은 질의 값이 생성되지 않도록 인증 서버 관리가 필요  시간과 이벤트 동기화 방식  토큰장치와 인증서비스는 반드시 동일한 비밀키를 공유하여 암ㆍ복호화에 사용 시간 동기화 방식  토큰장치와 비밀키에 나타나는 시간 값은 OTP를 생성하는데 사용 OTP 생성 매체와 인증서버의 시간 정보이 동기화되어 있어야 함   이벤트 동기화 방식  사용자가 토큰장치의 버튼을 누르면 다음 인증 값이 나타남 OTP 생성 매체와 인증서버의 계수기 값이 동기화되어 있어야 함    S/KEY 방식  유닉스 계열 OS에서 인증에 사용되는 해시 체인 기반의 방식 동작방식  클라이언트에서 임의의 비밀키를 서버에 전송 이 비밀키를 첫 번째 값으로 해시 체인 방식으로 이전 결과값에 대한 해시 값을 구하는 작업을 n번 수행 n개의 OTP를 서버에 저장    개체 특성 기반 인증  장점  사용하기 쉬움 분실, 손실, 도난 X 위조가 어려움   단점  잘못 판단할 가능성 관리가 어려움 인증을 위한 임계치 설정의 어려움    생체인증 생체적 혹은 행동적 특성을 측정하여 신원을 확인하는 방법\n 기술 평가항목: 보편성, 유일성, 지속성, 획득성, 성능, 수용성, 반기만성 처리 속도는 느리며, 처리량은 낮음  정확도  FRR(False Rejection Rate, 오거부율)  인식되어야 할 사람이 얼마나 시스템에 의해서 인식이 되지 않았는지에 대한 값   FAR(False Acceptance Rate, 오인식률)  인식되어서는 안 될 사람이 얼마나 시스템에 의해서 인식이 되는지에 대한 값   CER(Crossover Error Rate)/EER(Equal Error Rate)  FRR과 FAR이 일치하는 지점 수치가 낮을수록 정확    ","excerpt":"인증에는 메시지 인증과 사용자 인증이 존재한다.\n 메시지 인증  메시지 전송 중 발생할 수 있는 수정, 삭제 등 무결성 검증  …","ref":"/til/security/access-control/user-authentication/","title":"User Authentication"},{"body":"설치 설치하는 방법에는 두 가지가 존재하는 데 필자는 플러그인으로 추가하는 방법을 추천한다.\n일반 설치 설치 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git echo \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" \u003e\u003e ${ZDOTDIR:-$HOME}/.zshrc 위 코드를 그대로 복사 후 Shell에서 실행\n 설치된 경로가 zshrc의 마지막 줄에 추가된다.\n 적용 source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh  syntax highlighting 재실행 없이 적용\n plugin manager 이용 oh-my-zsh의 plugin으로써 설치하고 사용하는 방법은 다음과 같다.\n설치 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 플러그인을 .zshrc에 추가 plugins=( [plugins...] zsh-syntax-highlighting) # zsh-syntax-highlighting 마지막에 추가 적용 우분투 Shell을 재실행하면 적용된다.\n오류 해결 plugin manager로 적용시키다 보면 insecure directories라는 오류가 발생할 수 있는데, 이럴때는 아래와 같은 코드를 실행하면 된다.\ncompaudit | xargs chmod g-w,o-w ","excerpt":"설치 설치하는 방법에는 두 가지가 존재하는 데 필자는 플러그인으로 추가하는 방법을 추천한다.\n일반 설치 설치 git clone …","ref":"/til/zsh/zsh-syntax-highlighting/","title":"zsh-syntax-highlighting"},{"body":"","excerpt":"","ref":"/til/security/access-control/","title":"Access Control"},{"body":"박스 모델 HTML 태그는 사각형 박스로 다루어진다.\n 각 HTML 태그 요소를 하나의 박스로 다룸 박스 크기, 배경 색, 여백, 옆 박스와의 거리 등 제어 가능  구성 Contents HTML 태그의 텍스트나 이미지가 출력되는 부분 Border 박스 모델의 테두리로서, 직선이나 점선 혹은 이미지로 테두리를 그릴 수 있음 Padding 콘텐츠를 직접 둘러싸고 있는 내부 여백 Margin 박스의 맨 바깥 영역이며 테두리 바깥의 공간으로 인접한 아래위 이웃 태그의 박스와의 거리\n프로퍼티     콘텐츠 패딩 테두리 여백     크기 관련 프로퍼티 width height padding-top padding-right padding-bottom padding-left border-top-width border-right-width border-bottom-width border-left-width margin-top margin-right margin-bottom margin-left   크기 단축 프로퍼티  padding border-width margin   스타일 관련 프로퍼티   border-top-style border-right-style border-bottom-style border-left-style    스타일 단축 프로퍼티   border-style    색 관련 프로퍼티   border-top-color border-right-color border-bottom-color border-left-color    색 단축 프로퍼티   border-color    전체 단축 프로퍼티   border     다양한 스타일 둥근 모서리 border-radius: 50px;\rborder-radius: 0px 20px 40px 60px;\r/* 왼쪽 상단부터 시계 방향으로 적용 */\r이미지 테두리 border-image: url(\"border.jpg\") 30 round:\r/* border.jpg 이미지를 불러와서 테두리로 사용 */\r round– 테두리 길이만큼 이미지 크기 조절해서 반복 배치 repeat-이미지 반복 배치, 이미지 크기 조절X stretch–이미지를 테두리 길이만큼 늘여 배치\n 배경  background-color: 배경 색 background-image: 배경 이미지 background-position: 배경 이미지 위치 background-repeat: 배경 이미지 반복 출력  단축 프로퍼티 background : skyblue url(\"media/spongebob.png\") center center/100px 100px repeat-y;\r/* color, image, position/size, repeat, origin 순 */\r###시각적 효과\n텍스트 그림자 text-shadow: h-shadow v-shadow blur-radius color|none\r h-shadow v-shadow  원본 텍스트와 그림자 텍스트 사이의 거리   blur-radius  흐릿한 그림자를 만드는 효과로 번지는 길이    박스 그림자 box-shadow: h-shadow v-shadow blur-radius spread-radius color|none|inset\r spread-radius: 그림자 크기 inset: 음각 박스로 보이게 박스 상단 안쪽에 그림자 형성  배치 블록 박스와 인라인 박스  HTML 태그는 인라인 태그와 블록 태그로 나뉨  인라인 태그는 인라인 박스, 블록 태그는 블록 박스로 출력   블록 박스와 인라인 박스의 디폴트 출력 모양  display 디폴트 박스 유형을 무시하고, HTML 태그의 박스 유형을 달리 지정\ndisplay: block;\rdisplay: inline;\rdisplay: inline-block;\r 블록박스  항상 새 라인에서 시작 블록 박스 내에만 배치 옆에 다른 요소 배치 불가능 width와 height로 크기 조절 padding, border, margin 조절 가능   인라인 박스  새 라인에서 시작 못함 모든 박스 내 배치 가능 옆에 다른 요소 배치 가능 width와 height로 크기 조절 불가능 padding, border, margin 조절 가능 불가능   인라인 블록 박스  새 라인에서 시작 못함 모든 박스 내에서 배치 가능 옆에 다른 요소 배치 가능 width와 height로 크기 조절 가능 padding, border, margin 조절 가능    position 박스의 배치에 사용하는 프로퍼티\n normal flow  웹 페이지에 나타난 순서대로 HTML 태그 배치   position 프로퍼티를 이용한 배치  정적 배치 - position: static 상대 배치 - position: relative 절대 배치 - position: absolute 고정 배치 - position: fixed 유동 배치 - float : left|right     position을 이용할 때, 태그 위치와 크기는 top, bottom, left, right, width, height 프로퍼티로 지정\n z-index HTML 태그들을 z축을 따라 수직으로 쌓는 프로퍼티로 값이 클수록 위에 위치\n z-index의 지정이 없는 경우, HTML문서에 나오는 순서로 z-index의 값이 자동 결정 z-index는 position의 프로퍼티가 relative나 absolute인 경우에만 작동  visibility 태그를 보이거나 숨길 때 사용\n 사용법: visibility: visible|hidden hidden을 사용하더라도 공간은 차지  overflow 콘텐츠가 width와 height 프로퍼티에서 설정한 태그의 크기를 넘어가는 경우 콘텐츠를 자를지 말지 지정함\n 블록태그에만 적용됨 overflow 프로퍼티는 박스 크기가 지정되어 있어야 함 사용법: overflow: visible|hidden|scroll|auto  visible: 콘텐츠가 잘리지 않고 태그 영역을 넘어 출력(디폴트) Hidden: 콘텐츠를 태그 크기로 잘라 넘어가는 것은 보이지 않음. 스크롤바없음 Scroll: 스크롤바를 항상 부착하여 콘텐츠 출력 Auto: 콘텐츠가 박스높이(height)보다 넘치면 스크롤바 자동생성    ","excerpt":"박스 모델 HTML 태그는 사각형 박스로 다루어진다.\n 각 HTML 태그 요소를 하나의 박스로 다룸 박스 크기, 배경 색, 여 …","ref":"/til/css/box-model/","title":"Box Model"},{"body":"if문 특정 조건의 참/거짓에 따라 프로그램의 흐름을 분기시키기 위해 사용한다.\n if문은 조건문이라고도 한다.\n 기본 구조 if 조건식:\r수행할 명령문\r...\relse:\r수행할 명령문\r...\rif문의 조건식이 True면 그 아래에 정의한 명령문을 수행하고, False이면 else문 아래에 정의한 명령문을 수행한다.\n조건식은 논리형으로 결과가 나오는 연산이므로, 이와 관련된 연산자들을 숙지해야만 한다. 만약 이 부분이 덜 숙지되어 있다면 이전 교안을 참고하도록 하자.\n주의사항   들여쓰기\n들여쓰기를 한 칸이라도 더하거나 덜하더라도 오류가 발생할 수 있으므로 어디서 들여쓰기 해야하는 지 꼭 숙지해야 한다.\n  콜론\nif 조건문 뒤에는 반드시 콜론(:)이 들어가야 한다.\n  다중 조건 if문과 else문을 사용하면 단지 두 가지의 경우만을 판단할 수 있는데, ‘elif’를 사용하면 그 이상의 경우도 판단할 수 있다.\n\u003e\u003e\u003e backpack = ['notebook', 'charger', 'pencil'] \u003e\u003e\u003e if 'charger' in backpack: ... print(\"충전기로 충전해라\") ... elif 'powerbank' in backpack: ... print(\"보조배터리로 충전해라\") ... else: ... pass # 아무것도 실행하지 않는다. ... 충전기로 충전해라 만약 핸드폰을 충전하려할 때, 가방에 어떤 물건이 들었는지에 따라서 출력되는 문장이 달라지는 프로그램은 다음과 같이 짤 수 있을 것이다.\nwhile문 조건이 참(True)일때 명령문을 반복하여 수행한다.\n기본 구조 while 조건식:\r수행할 명령문\r...\r조건식은 if문과 동일한 방법으로 작성된다.\n사용 예시 “열 번 찍어 안 넘어가는 나무 없다\"는 속담을 파이썬 프로그램으로 만든다면 다음과 같을 것이다.\n\u003e\u003e\u003e count = 0 \u003e\u003e\u003e while count \u003c 10: ... count = count + 1 # count에 1씩 더하기 ... print(\"나무를 %d번 찍었습니다.\" % count) ... if count == 10: ... print(\"나무가 넘어갔습니다.\") ... 나무를 1번 찍었습니다. 나무를 2번 찍었습니다. 나무를 3번 찍었습니다. 나무를 4번 찍었습니다. 나무를 5번 찍었습니다. 나무를 6번 찍었습니다. 나무를 7번 찍었습니다. 나무를 8번 찍었습니다. 나무를 9번 찍었습니다. 나무를 10번 찍었습니다. 나무가 넘어갔습니다. 위 코드는 count라는 변수를 0으로 초기화해두고, count가 10되기 직전까지 1씩 더하면서 나무를 몇번 찍었는지 출력하는 명령문을 반복하여 실행하게 한다.\n보조 제어문 파이썬에서 반복문에 사용할 수 있는 보조 제어문으로는 break와 continue가 존재한다. 사용하는 방법은 예시를 통해서 살펴보도록 하겠다.\nbreak문 반복문을 완전히 빠져나가는 제어문\n\u003e\u003e\u003e count = 0 \u003e\u003e\u003e while True: ... count = count + 1 # count에 1씩 더하기 ... print(\"나무를 %d번 찍었습니다.\" % count) ... if count == 10: ... print(\"나무가 넘어갔습니다.\") ... break # 반복문 탈출 ... 나무를 1번 찍었습니다. 나무를 2번 찍었습니다. 나무를 3번 찍었습니다. 나무를 4번 찍었습니다. 나무를 5번 찍었습니다. 나무를 6번 찍었습니다. 나무를 7번 찍었습니다. 나무를 8번 찍었습니다. 나무를 9번 찍었습니다. 나무를 10번 찍었습니다. 나무가 넘어갔습니다. 위 코드는 while문의 조건식이 항상 True이므로 명령문이 무한정 반복하게 될 것이다. 이런 경우에 반복문을 빠져나오기 위해서는 break문을 사용해야 한다.\nif count == 10라는 조건문을 한 번 보자. 이 조건이 만약 참이라면 그 아래에 있는 명령문이 실행되면서 “나무가 넘어갔습니다.“를 출력하고 break문이 실행되면서 while문을 빠져나온다.\ncontinue문 반복문의 조건식으로 돌아가는 제어문\n\u003e\u003e\u003e count = 0 \u003e\u003e\u003e while True: ... count = count + 1 ... if count % 2 != 0: # 홀수일 경우 ... continue # 아래 명령문 수행하지 않는다 ... print(\"나무를 %d번 찍었습니다.\" % count) ... if count == 10: ... print(\"나무가 넘어갔습니다.\") ... break ... 나무를 2번 찍었습니다. 나무를 4번 찍었습니다. 나무를 6번 찍었습니다. 나무를 8번 찍었습니다. 나무를 10번 찍었습니다. 나무가 넘어갔습니다. 위 코드는 홀수의 경우에는 명령문을 계속 수행하지 않고 반복문의 조건식으로 돌아가게 한다. 그렇기 때문에 나무를 짝수번 찍은 것만 출력한다.\nfor문 기본구조 for 변수 in 리스트(튜플, 문자열):\r실행할 명령문\r...\r5명의 수험생이 시험을 보았을 때, 점수 60점을 넘기면 합격을 통보해주는 프로그램을 만들어보면 다음과 같다.\n\u003e\u003e\u003e score = [63, 32, 67, 54, 80] \u003e\u003e\u003e n = 0 \u003e\u003e\u003e for i in score: ... n = n + 1 ... if i\u003c60: continue ... print(\"%d번 수험생 합격입니다.\"%n) ... 1번 수험생 합격입니다. 3번 수험생 합격입니다. 5번 수험생 합격입니다.  while문과 마찬가지로 continue문을 사용할 수 있다.\n range 함수 range 함수는 숫자 리스트를 만들어주는 함수로 for문과 함께 사용하는 경우가 많다.\n\u003e\u003e\u003e number \u003e\u003e\u003e for i in range(1, 11): ... number = number + i ... \u003e\u003e\u003e print(number) 55 range(1, 11)은 숫자 1부터 10까지(1이상 11미만)의 수로 구성된 리스트를 생성한다. 따라서 변수 i에는 1부터 10까지 차례로 하나씩 대입되고 이것을 number에 더하는 것으로 1~10의 합을 구할 수 있게 된다.\n range(10)은 range(0, 10)와 같다. 즉 0~9까지의 수로 구성된 리스트가 생성됨.\n ","excerpt":"if문 특정 조건의 참/거짓에 따라 프로그램의 흐름을 분기시키기 위해 사용한다.\n if문은 조건문이라고도 한다. …","ref":"/til/python/study/control-statement/","title":"Control Statement"},{"body":"윈도우 파일 시스템에서 Linux 디렉토리 접속 경로 C:\\Users\\%USERNAME%\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\ WSL에서 Windows 디렉토리 접속 경로  /mnt/드라이브명를 통해서 자신이 원하는 드라이브로 이동 /mnt/드라이브명/디렉토리명으로 해당 드라이브 상의 특정 폴더 접속  ","excerpt":"윈도우 파일 시스템에서 Linux …","ref":"/til/wsl/directory-path/","title":"Directory path"},{"body":"===\nzsh-syntax-highlighting을 사용하는 경우, 파일이나 디렉터리의 경로가 밑줄이 그어진다. 다만 WSL 우분투에 위 기능을 사용하게 되면 창 리사이즈 시 밑줄이 화면 한 줄을 차지해버리는 문제가 발생한다. 따라서 이 기능을 지워서 사용하는 것이 오히려 편리하다.\nunderline 기능 없애기 ~/.zshrc를 편집기로 실행한다.\nZSH_HIGHLIGHT_STYLES[path]=none\rZSH_HIGHLIGHT_STYLES[path_prefix]=none\r위 코드를 .zshrc의 맨 하단에 추가하고, 저장 및 종료한다. 그러면 파일 경로 밑줄 표시 기능이 없어진다.\n","excerpt":"===\nzsh-syntax-highlighting을 사용하는 경우, 파일이나 디렉터리의 경로가 밑줄이 그어진다. 다만 WSL  …","ref":"/til/zsh/disable-zsh-syntax-highlighting-underline/","title":"disable zsh-syntax-highlighting underline"},{"body":"서비스 거부 공격(DoS) 시스템에 과도한 부하를 일으켜 시스템의 사용을 방해하는 공격 방식(가용성 침해)\nTCP SYN Flooding Attack TCP 연결 과정 중에 3-way handshaking 과정에서 Half-Open 연결 시도가 가능하다는 취약점을 이용한 공격 기법\n 클라이언트가 SYN을 보내면 서버는 이에 대한 응답으로 SYN + ACK을 보내고 SYN Received 상태가 됨 이후 서버는 클라이언트로부터의 ACK 패킷 수신을 일정시간동안 대기하게 된다.  공격 방법  조작된 IP로부터 SYN 메시지를 공격대상자에게 대량 전송 서버는 조작된 IP로 SYN+ACK 전송 만약 시스템이 존재하는 IP라면 RST(Reset) 패킷이 전송되어 연결 끊김  해당 클라이언트가 서비스 요청을 하지 않았음을 확인   존재하지 않는 IP라면 클라이언트가 RST 패킷을 전송하지 않음 서버는 일정시간동안 SYN+ACK을 재전송하며 대기 서버의 TCP 연결테이블 공간을 차지하기 때문에 정상적인 서비스 요청이 거부됨  보안 대책  SYN 연결 요청에 임계치 설정  동일 클라이언트로부터 과도한 연결요청 DROP   SYN쿠키 기법  요청이 들어오면 SYN쿠키만 보내놓고 세션을 닫음 공격자의 계속적인 SYN Flooding을 막는 방법   TCP 연결테이블 엔트리 선택적 삭제  테이블 오버플로우 발생 시 일부 삭제   연결테이블 확장  SMURF Attack IP 위장과 ICMP의 특징을 이용한 광범위한 DoS 공격\n공격 방법  공격자는 IP를 공격대상 서버의 IP주소로 위장, ICMP를 broadcast로 다수의 시스템에 전송 ICMP broadcast를 수신한 다수의 시스템은 ICMP Echo 패킷을 공격대상 서버로 전송하게 됨 다수의 ICMP Echo를 수신한 공격대상 서버는 시스템 성능에 문제가 생기게 됨  보안 대책  라우터에서 다른 네트워크에서 자신의 네트워크로 들어오는 IP directed broadcast 패킷을 막도록 설정 호스트는 IP broadcast address로 전송된 ICMP 패킷에 대해 응답하지 않도록 함 침입탐지 시스템(IPS)를 통해서 패킷 모두 DROP  Land Attack 패킷 전송 시 출발지 IP 주소와 목적지 IP 주소 값을 똑같이 만들어서 공격 대상에 보내는 기법\n보안 대책  출발지 주소가 내부 IP인 패킷을 차단 자신의 시스템 주소와 동일한 출발지 주소를 가진 외부 패킷을 필터링  Ping of Death ping을 이용하여 ICMP 패킷을 정상 크기(65,535bytes)보다 아주 크게 만들어 전송\n 라우팅되어 공격대상자에게 전송되는 동안 많은 Fragment로 쪼개서 전송됨 공격 대상은 조각화된 패킷을 모두 처리해야 하므로 부하가 발생  보안 대책  OS 패치 방화벽에서 ICMP 차단  Teardrop Attack IP 단편화시 오프셋 값을 고의적으로 중복되도록 설정하거나 범위를 넘어서는 오버플로우를 일으켜 시스템 기능을 마비시킴\n 패킷을 전송할 때 IP 단편화(fragmentation)를 진행하고, 수신자는 재조립을 통해 단편화된 데이터를 복구하는데 이 과정에서 정확한 조립을 위해 오프셋 값을 사용한다.\n 보안 대책  침입차단시스템(IPS), 방화벽 OS 패치  Inconsistent Fragmentation Attack  Bonk: 패킷을 fragment(조각화)하여 전송할 때 순서번호를 모두 1번으로 조작하여 전송 Boink: 패킷 순서번호를 비정상적인 상태로 보내는 공격  분산 서비스 거부 공격(DDos) 여러 대의 컴퓨터(좀비 PC)로 엄청난 분량의 패킷을 동시에 전송하여 네트워크 성능 저하나 시스템 마비를 유발\n구성 요소  공격자(봇 마스터): 공격을 주도하는 해커의 컴퓨터 마스터(C\u0026C 서버): 공격자에게 직접 명령을 받은 시스템  여러 에이전트를 관리   에이전트(좀비): 공격 대상에 직접적인 공격을 가하는 시스템 데몬 프로그램: 에이전트 역할을 수행  대응 절차 공격의 인지  유입 트래픽 크기  IDS, 방화벽 등 사용   웹 서버 로그 동시접속 정보 유입 트래픽 샘플링  공격 유형 파악  패킷 덤프를 이용한 트래픽 확보 확보된 트래픽 분석 시나리오 기반의 공격유형 파악 웹서버 접속 로그  유형에 따른 차단정책 대역폭 소진 공격 대응 방안\n 공격 유형: UDP Flooding, ICMP Flooding  방화벽이나 웹서버 상단의 라우터 해당 프로토콜을 차단하는 ACL 정책 적용   공격 유형: TCP Flooding  프로토콜로 기준으로 차단하는 것에 한계가 있음 Source IP별 PPS 임계치 설정    웹서버 자원 소모 대응 방안\n 공격 유형: SYN Flooding  Source IP별 PPS 임계치 설정 패킷 헤더 검사를 통한 비정상적인 옵션 필드 가진 패킷 차단   공격 유형: Slow Header Flooding, Slow Data Flooding  완료되지 않은 연결 상태 유지 요청에 대한 타임아웃 설정    DB 커넥션 부하 유발 대응 방안\n 공격 유형: Get Flooding, Post Flooding  다량의 HTTP 요청으로 웹서버와 DB연동에 부하 클라이언트 요청 수에 대한 임계치 초과하는 IP 차단 HTTP 표준에 맞지 않는 필드값을 차단 시그니처로 설정    사후 조치  정책 업데이트 좀비 PC IP 확보  공격 사례  트리누(Trinoo) 공격  UDP Flood 서비스 공격을 유발   TFN(Tribed Flood Network) 공격  트리누의 발전형 UDP Flood 외 다양한 공격(TCP SYN Flood, smurf 공격) 가능   Stacheldraht 공격  마스터 시스템 및 에이전트 데몬과의 사이 암호화 통신(TELNETC)   TFN2K 공격  TFN의 발전된 형태. 통신에 특정 포트가 사용되지 않고 암호화 조금 더 다양한 OS에서 사용 가능 UDP, TCP, ICMP가 복합적으로 사용 지정한 TCP 포트에 백도어 실행 가능    공격 유형 HTTP Traffic Flooding 공격  GET Flooding  TCP 3-way handshaking 과정을 통해 정상 접속 특정 페이지를 HTTP의 GET Method를 통해 무한대로 실행   Cache Control Attack (CC Attack)  HTTP 메시지의 캐시 옵션을 조작 캐싱서버가 아닌 웹서버가 메시지를 처리하도록 하여 웹서버의 자원 소진   동적 HTTP Request Flooding 공격  웹 방화벽 차단 기법을 우회하기 위해 지속적으로 요청 페이지를 변경하여 웹페이지를 요청    HTTP Header/Option Spoofing Flooding 공격  Slow HTTP POST DoS  POST 지시자를 통해서 서버에 전송할 다량의 데이터를 장시간에 걸쳐 분할전송 서버는 POST 데이터를 모두 수신하지 않았다고 판단하여 연결을 장시간 유지   Slow HTTP Header DoS(Slowloris)  헤더 정보를 조작하여 구분할 수 없게 만듬 헤더 정보 수신을 위해 서버는 장시간 연결 유지   Slow HTTP Read DoS  TCP 윈도우 크기 및 데이터 처리율을 감소시킨 후 HTTP 데이터를 송신 웹서버가 정상적으로 응답하지 못하도록 DoS 상태    HULK(Http Unbearable Load King) DoS 웹서버의 가용량(최대 접속 가능 클라이언트 수)을 모두 사용하도록 하여 정상적인 서비스가 불가능하도록 유도\n GET Flooding 공격 중 하나\n SIP(Session Initiation Protocol) Flood  하나의 INVITE request 메시지가 상당한 양의 자원을 소모하게 한다는 것을 이용 수많은 INVITE request를 위조된 시작주소에 넣어 전송하는 공격 SIP Proxy 서버에 부하   SIP: VoIP 전화 연결에 많이 사용하는 프로토콜\n 분산 반사 서비스 거부 공격(DRDoS) 별도의 에이전트 설치 없이 프로토콜 구조의 취약점을 이용해 정상적인 서비스를 운영하는 시스템을 에이전트로 활용하여 공격\n DNS 증폭 DRDoS 공격  많은 양의 레코드 정보를 요구하는 DNS 질의 타입을 요청 공격 대상에게 대량의 트래픽을 유발시킴   NTP 증폭 DRDoS 공격  최근 접속한 클라이언트 목록(monlist 명령)을 요청   SNMP 증폭 DRDoS 공격  MIB와 같은 정보를 대량 요청   CHARGEN 증폭 DRDoS 공격  대량의 문자열 전송    위협 요소  패킷이 전송되는 경로가 무수히 많음 반사 서버의 단계적 사용 및 확산  공격 경로를 끊임없이 변경 가능   공격대상 IP를 출발지 IP로 위조하여 전송  역추적 어려움    대응 방안  네트워크에서의 대응  IP 주소가 위조된 패킷이 인터넷망으로 들어오지 않도록 ISP가 직접 차단(Ingress Filtering)   반사서버에서의 대응  ICMP 프로토콜이 필요 없는 시스템인 경우 해당 프로토콜을 차단   공격대상에서의 대응  내부 사용자용 DNS 서버인 경우 내부 사용자 주소만 Recursive Query가 가능하도록 제한    ","excerpt":"서비스 거부 공격(DoS) 시스템에 과도한 부하를 일으켜 시스템의 사용을 방해하는 공격 방식(가용성 침해)\nTCP SYN …","ref":"/til/security/network/dos-attack/","title":"DoS Attack"},{"body":"1980년대 초 ISO(International Organization for Standardization)는 여러 업체가 만든 시스템을 상호 연동 가능케 하는 표준 네트워크 모델 제정의 필요성을 인식하고, 이런 요구를 수용해 OSI(Open System Interconnection) 네트워크 모델을 만들었다.\n물리 계층 시스템 간의 연결 선으로, 실제 장치를 연결하는 데 필요한 전기적, 물리적 세부 사항을 정의\n케이블 랜(LAN) 케이블이 대표적이지만 케이블의 속도에 따라 CAT 1~6로 나뉘며 재질에 따라 구분된다.\n케이블의 구분\n   구분 내용     UTP(Unshielded Twisted Pair) 두 선 간의 전자기 유도를 줄이기 위해 절연의 구리선이 서로 꼬여 있다. 제품 전선과 피복만으로 구성   FTP(Foil Screened Twisted Pair) 알루미늄 은박이 4가닥 선을 감싸고 있다. UTP보다 절연 기능이 탁월해 공장 배선용으로 많이 사용   STP(Shielded Twisted Pair) 연선으로 된 케이블 겉에 외부 피복, 또는 차폐재가 추가(쉴드 처리), 차폐재가 접지 역할을 하므로 외부 노이즈를 차단하거나 전기적 신호 간섭을 줄이는 데 탁월    일반적으로 사용하는 랜 케이블은 CAT 5(or CAT 6)인 UTP 케이블이다.\n관련 장비 리피터 네트워크를 연장하기 위한 장비로 신호 세기를 증가시키는 역할을 한다. 요즘에는 모든 네트워크 장비에 공통적으로 들어가는 기능이 되어 별도 장비로 사용하지는 않는다.\n더미 허브 스위치의 예전 형태로 네트워크 구조가 버스 구조를 하고 있다. 허브는 스위치와 사용 방법이 똑같으나 패킷을 보낼 때 데이터가 모든 노드에게 전달된다는 점이 다르다.\n데이터 링크 계층 점대점(point-to-point) 간 신뢰성 있는 전송을 보장하기 위한 계층\n CRC 기반의 오류 제어와 흐름 제어가 필요 네트워크를 구성하는 개체들 간 데이터를 전달 물리 계층에서 발생할 수 있는 오류를 찾아 수정하기 위한 기능적, 절차적 수단을 제공  MAC 주소 데이터 링크 계층을 간단히 설명하면 하드웨어 주소만으로 통신하는 계층이다. 하드웨어 주소인 MAC은 네트워크 카드에 할당되는 고유 주소로 12개의 16진수로 구성된다. 앞 6자리는 제조사 정보(OUI, Organizational Unique Identifier)이며 뒤쪽 자리는 호스트 식별자(Host Identifier)로 제조사에서 임의로 붙이는 일련번호이다.\n네트워크 종류 데이터 링크 계층에는 이더넷 외에도 몇 가지 주요 네트워크가 존재한다.\nX.25 ITU-T에 의해 규격화된 통신 규약으로 단말 장치(DTE, Data Terminal Equipment)와 회선종단장치(DCE, Data Circuit-terminating Equipment) 간의 상호 접속에 대해서만 규정한다.\n 회선종단장치: 네트워크를 통해 데이터를 아날로그나 디지털 신호 형태로 송수신하는 장치\n 프레임 릴레이 디지털 전송 통로 품질의 향상에 따라 불필요한 전송 오류 제어나 흐름 제어 등 복잡한 기능을 최소화하고, 망 종단 장치에서 처리하도록 함으로써 고속 전송을 실현하는 고속 데이터 전송 기술이다. X.25 패킷 교환망의 10배까지 구현 가능\nATM 고속의 데이터를 53Byte 셀로 처리하는 VLSI 기술로, 실시간 영상 전송과 같은 고속 통신에 사용한다.\n관련 장비 브리지 랜과 랜을 연결하는 네트워크 장치로, 데이터 링크 계층에서 통신 선로를 따라 한 네트워크에서 그 다음 네트워크로 프레임을 복사하는 역할을 한다.\n 프레임은 L2(Layer 2, 데이터 링크 계층)에서 사용되는 데이터 전송 단위이다.\n 스위치 기본적으로 L2에서 작동하는 스위치를 말한다. L3, L4 스위치는 L2 스위치에 상위 계층의 네트워킹 기능을 추가한 것이다. L2 스위치는 스타형 네트워크로 더미 허브의 패킷 간 충돌을 해결하는 획기적 방안이었다.\n스위칭 패킷 전송 방식\n 컷스루(cut-through)  수신한 프레임의 목적지 주소를 확인하고 해당 포트로 즉시 전송 지연 시간 최소화 수신 패킷에 오류있을 시, 수신 장치에서 폐기   저장 후 전송(store \u0026 forward)  완저히 프레임을 수신하여 버퍼에 보관 CRC 등 오류를 확인하고 정상 프레임을 전송 전송 지연이 발생하지만 브리지나 라우터보다 신속 속도가 다른 포트가 연결된 경우 반드시 사용해야 함 최근에는 컷스루와 동시지원이 일반적   인텔리전트 스위칭(intelligent switching)  평소에는 컷스루 방식으로 작동 오류 발생시 저장 후 전송 모드로 자동 전환 오류가 0이 되면 다시 컷스루로 전환   전이중(full-duplex)  송신 포트와 수신 포트를 분리 반이중 방식보다 성능이 두배 충돌이 없으므로 전송거리 제한 연장 가능    스위치 테이블 데이터 링크 계층에서 스위치는 시스템 간의 원활한 통신을 위해 주소 테이블을 생성하고 관리\n   포트 MAC주소     1번 포트    2번 포트 서버의 MAC 주소   3번 포트 클라이언트의 MAC 주소   4번 포트      스위치는 IP주소를 기억하지 않으며 MAC 주소만을 포트에 매칭한다.\n 네트워크 계층 여러 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층\n 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 절차적, 기능적 수단을 제공 라우팅, 흐름 제어, 단편화, 오류 제어 등 수행 라우터와 L3 스위치가 여기에 해당  라우터 둘 이상의 네트워크를 연결하거나 분리하는 역할을 수행\n주요 기능\n 네트워크를 서로 연결  각기 독립적으로 구성된 네트워크들을 연결   패킷 스위칭  한 포트로 패킷을 받아서, 다른 포트로 전송   경로 설정  패킷 교환망에서 최적 경로를 찾기 위한 라우팅 테이블을 구성 이에 따라 패킷을 목적지까지 가장 빠르게 전송    라우팅 네트워크상에서 주소를 이용, 목적지까지 경로를 체계적으로 결정하는 경로선택 과정\n 정적 라우팅  관리자 권한으로 특정 경로를 통해서만 패킷이 지날 수 있도록 설정한 것 네트워크 변경사항이 발생할 때 라우팅 테이블을 수동으로 직접 고쳐줘야 함   동적 라우팅  네트워크 연결 상태를 라우터가 스스로 파악, 최적 경로 선택 네트워크 연결 형태가 변경되어도 자동으로 문제 해결    전송 계층 양 끝단(end-to-end)의 사용자들이 신뢰성 있는 데이터를 주고받을 수 있게 함으로, 상위 계층이 데이터 전달의 유효성이나 효율성을 고려하지 않아도 되게 함\n 시퀸스 넘버 기반의 오류 제어 방식을 사용 특정 연결의 유효성 제어 TCP는 연결 지향 프로토콜  패킷 전송이 유효한가 판단, 재전송    port 전송 계층의 대표적인 프로토콜인 TCP는 포트(port)라는 주소를 가진다. IP가 시스템의 논리적 주소라면, 포트는 시스템에 도착한 이후 찾아갈 응용 프로그램의 주소라 할 수 있다.\n 0~65535(2^16)번까지 존재  0~1023번을 잘 알려진 포트라 함(well known port)   출발지 포트는 사용하지 않는 임의의 포트를 할당  1025~65535번 중 할당    세션 계층 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공\n 동시 송수신 방식, 반이중 방식, 전이중 방식의 통신 체크 포인팅과 유휴, 종류, 재시작 과정 등을 수행 TCP/IP 세션을 만들고 없애는 책임  표현 계층 데이터에 대한 구조를 하나의 통일된 형식을 표현\n 응용 프로그램 계층 간의 서로 다른 표현을 상호 인식하기 위한 정보 정의 데이터 압축과 암호화  이에 대한 정보가 헤더에 담김    응용 계층 사용자나 응용 프로그램 사이에 데이터 교환을 가능하게 하는 계층\n HTTP, FTP, 터미널 서비스, 메일 프로그램, 디렉토리 서비스 등  ","excerpt":"1980년대 초 ISO(International Organization for Standardization)는 여러 업체가 만 …","ref":"/til/network/hierarchy/","title":"Hierarchy"},{"body":"영속성  영속적 연결  서버는 연결 이후 클라이언트의 요청을 대기 HTTP 1.1에서 Keep-Alive 옵션이 추가됨  연결 상태 지속시간 설정 기능     비영속적 연결  각 요구/응답에 대해 하나의 TCP 연결 생성    트랜잭션 웹 브라우저가 웹 서버에 요청을 보내고 웹 서버가 이를 처리한 응답을 전송하는 한번의 과정\n요청 메시지 클라이언트가 서버에게 요청을 보낼 때 전송하는 메시지\n요청 라인 요청 메시지의 첫 줄로 공백 문자로 구분된 세가지 필드를 가진다.\n Method URL Version     메소드 역할 설명     GET 리소스 취득 리소스 취득 인수를 URL에 포함시켜 전송, 최소한의 보안도 없음   HEAD 문서 정보 취득 GET과 비슷하나, 실제 문서를 요청하는 것이 아니라, 문서 정보를 요청   POST 데이터 전송 데이터를 HTTP 바디에 담아 웹서버로 전송, 최소한의 보안   PUT 데이터 전송(갱신 용도) POST와 유사하나 리소스 갱신을 위해 사용   DELETE 파일 제거 웹 리소스를 제거   OPTIONS 제공 메소드 옵션 시스템에서 지원되는 메소드 종류를 확인   TRACE 요청 리소스 수신 경로 디버깅에 사용, 서버가 요청을 받고 있는지 여부 확인   CONNECT 프락시 기능 요청 원하는 웹서버와의 중계 연결 요청     TRACE와 CONNECT는 현재는 거의 사용하지 않는다.\n 요청 헤더 바디 본문을 통해 전달하는 데이터(일반 문서) 이외의 정보를 교환하기 위해 사용\n host, User-Agent, Referer, 콘텐츠 길이, 쿠키 정보 등 헤더 이후에는 빈 라인: 헤더의 끝을 의미  바디  PUT, POST일 때 송신될 주석, 웹사이트에 게시될 파일을 담고 있음 GET 방식의 경우 요청 데이터가 없기 때문에 본체(Body)가 없음  응답 메시지 서버가 클라이언트에게 응답을 보낼 때 전송하는 메시지\n상태 코드 세 자리 숫자로 요청의 상태를 정의\n 1xx (조건부 응답): 요청을 받았으며 프로세스를 계속한다 2xx (성공): 요청을 성공적으로 수신하여 처리하였다 3xx (리다이렉션): 요청 완료를 위해 추가 동작을 취해야 한다 4xx (클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다 5xx (서버 오류): 서버가 명백히 유효한 요청에 대한 수행을 실패했다     상태 코드 설명     100(continue) 요청의 첫 부분이 서버 도착했으며 나머지를 기다리고 있는 상태. 요청자는 요청을 계속해야한다.   101(Switching Protocols) 요청자가 서버에 프로토콜 전환을 요청했으며 서버는 이를 승인하는 중이다.   200(Ok) 서버가 요청을 제대로 처리했다.   201(Created) 성공적으로 요청되었으며 서버가 새 리소스를 작성했다.   202(Accepted) 서버가 요청을 접수했지만 아직 처리하지 않았다.   204(No Content) 성공적으로 처리했지만 컨텐츠를 제공하지는 않는다.   301(Moved Permanently) 요청한 페이지를 새 위치로 영구적으로 이동했다.   302(Found) 현재 서버가 다른 위치의 페이지로 요청에 응답하고 있지만 요청자는 향후 요청 시 원래 위치를 계속 사용해야 한다.   304(Not Modified) 마지막 요청 이후 요청한 페이지는 수정되지 않았다. 클라이언트 내 캐시 사용   400(Bad Request) 요청 자체가 잘못되었을때 사용하는 코드이다.   401(Unauthorized) 인증이 필요한 리소스에 인증 없이 접근할 경우 발생한다.   403(Forbidden) 서버가 요청을 거부할 때 발생한다.   404(Not Found) 찾는 리소스가 없다는 뜻이다.   405(Method Not Allowed) 서버에서 허용되지 않은 메소드로 요청시 사용하는 코드이다.   500(Internal Server Error) 서버에 오류가 발생해 작업을 수행할 수 없을 때 사용된다.   501(Not Implemented) 서버가 요청을 수행하는데 필요한 기능을 지원하지 않는 경우 사용된다.   502(Bad Gateway) 게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용된다.   504(Gateway Timeout) 게이트웨이가 연결된 서버로부터 응답을 받을 수 없었을 때 사용된다.    응답 헤더 추가적인 정보를 서버에서 클라이언트로 보냄\n Contents-Type, Contents-Length 등  바디  서버에서 클라이언트로 전송되는 문서를 포함 응답이 오류 메시지가 아니라면 본체가 존재  ","excerpt":"영속성  영속적 연결  서버는 연결 이후 클라이언트의 요청을 대기 HTTP 1.1에서 Keep-Alive …","ref":"/til/security/application/http/","title":"HTTP(Hypertext Transfer Protocol)"},{"body":"가상환경 가상환경(Virtual Environment, venv)은 독립적인 파이썬 개발 환경을 생성하는 것으로, 특정 버전의 파이썬이나 라이브러리를 설치하여 사용한다. 이를 통해 여러 프로젝트를 효과적으로 관리하는 것이 가능하다.\n생성 명령어 $ python -m venv \"가상환경 이름\" # MacOS or Linux의 경우 python3로 진행 실행 명령어 $ source \"가상환경 이름\"/scripts/activate $ source \"가상환경명\"/bin/activate 종료 명령어 $ deactivate 장고 설치 효율적인 프로젝트 관리를 위해 장고는 가상환경 안에 설치해주는 것이 좋다. 장고는 pip(파이썬 패키지 관리 시스템)를 통해 설치한다.\n설치 명령어 $ pip install django 삭제 명령어 $ pip uninstall django ","excerpt":"가상환경 가상환경(Virtual Environment, venv)은 독립적인 파이썬 개발 환경을 생성하는 것으로, …","ref":"/til/django/study/installation/","title":"Installation"},{"body":"구성 여러 개의 프로퍼티와 메소드로 구성\n 프로퍼티: 객체의 고유한 속성(변수) 메소드: 함수  종류 자바스크립트는 객체 기반 언어\n 객체 지향 언어는 아님\n  코어 객체  자바스크립트 언어가 실행되는 어디서나 사용 가능한 기본 객체 기본 객체로 표준 객체 Array, Date, String, Math 타입 등   HTML DOM 객체  HTML 문서에서 작성된 각 HTML 태그들을 객체화 한 것 HTML 문서의 내용과 모양을 제어하기 위한 목적   브라우저 객체  자바스크립트로 브라우저를 제어하기 위해 제공되는 객체 BOM을 따르는 객체    코어 객체 Array, Date, String, Math 등\n생성 var today = new Date(); var msg = new String(\"Hello\"); 객체가 생성되면 객체 내부에 프로퍼티와 메소드들이 존재한다.\n접근 객체와 멤버 사이에 점(.) 연산자 이용\nobj.프로퍼티 = 값; // 객체의 프로퍼티 값 변경 변수 = obj.프로퍼티; // 객체 onh의 프로퍼티 값 가져오기 obj.메소드(매개변수); // 객체 obj의 메소트 호출 종류 Date 객체  시간 정보를 담는 객체 현재 시간 정보 var now = new Date(); // 현재 날짜와 시간(시, 분, 초) var date = now.getDate(); // 오늘 날짜. date = 15 var hour = now.getHours(); // 지금 시간. hour = 20  특정 시간 정보 var startDay = new Date(2017, 2, 1);    월 값은 ‘0’부터 시작\n String 객체 문자열을 담기 위한 객체\nvar hello = new String(\"Hello\"); var res = hello.concat(\"Javascript\"); // concat() 후 hello의 문자열 변화 없음  String 객체는 일단 생성되면 수정 불가능\n 특징\n  문자열 길이\nvar hello = new String(“Hello”); var every = “Boy and Girl”; var m = hello.length; // m은 5 var n = every.length; // n은 12 var n = \"Thank you\".length; // n은 9  String 객체의 length 프로퍼티 : 읽기 전용\n   문자열을 배열처럼 사용\nvar hello = new String(\"Hello\"); var c = hello[0]; // c = \"H\". 문자 H가 아니라 문자열 “H”  [] 연산자를 사용하여 각 문자 접근\n   String 메소드\n   메소드 설명     charAt(index) 인덱스 idx에 있는 문자를 문자열로 만들어 리턴   charCodeAt(index) 인덱스 idx에 있는 문자의 16비트 유니코드 값 리턴   concat(s1, s2, …, sN) 현재 문자열 뒤에 문자열 s1,s2,…sN을 순서대로 연결한 새로운 문자 열 리턴   indexOf(s[,idx]) 인덱스 idx 위치부터 문자열 s가 처음으로 나타나는 인텍스 리턴, idx가 생략되면 처음부터 검색. 발견할 수 없으면 -1 리턴   replace(strA,strB) 문자열 strA를 찾아 strB로 수정한 새로운 문자열 리턴   slice(iidxA[,idxB]) 인덱스 idxA에서 idxB 앞까지 문자열을 복사하여 리턴, idxB가 생략되면 idxA에서 끝까지 리턴   split([separator[,limit]]) Separator 문자열을 구분자로 하여 문자열을 분리하여 문자열 배열을 만들어 리턴. Limit는 리턴하는 배열의 크기를 제한하는 정수   substr(idxA[,len]) 인덱스 idxA에서부터 len 문자 개수만큼 새로운 문자열 리턴. Len이 생략되면 문자열 끝까지 리턴   substring(idxA,idxB) idxA에서 idxB 앞까지 두 인덱스 사이의 문자열 리턴   trim() 문자열의 앞뒤 공백 문자(빈칸, 탭, 엔터키)를 제거한 새로운 문자열 리 턴   toLowerCase() 소문자로 변환된 새로운 문자열 리턴   toUpperCase() 대문자로 변환된 새로운 문자열 리턴   fromCharCode(char) char의 문자를 문자열로 만들어 리턴    Math 객체   수학 계산을 위한 프로퍼티와 메소드 제공\n  new Math()로 객체 생성하지 않고 사용\nvar sq = Math.sqrt(4); // 4의 제곱근을 구하면 2 var area = Math.PI*2*2; // 반지름이 2인 원의 면적   난수 발생\n Math.random() : 0~1사이의 랜덤한 실수 리턴 Math.floor(m)은 m의 소수점 이하를 제거한 정수 리턴  // 0~99까지 랜덤한 정수를 10개 만드는 코드 for(i=0; i\u003c10; i++) { var m = Math.random()*100; // m은 0~99.999... 보다 작은 실수 난수 var n = Math.floor(m); // m에서 소수점 이하를 제거한 정수(0~99사이) document.write(n + \" \"); }   주요 메소드\n   메소드 설명     abs(x) x의 절대값 리턴   sin(x) 싸인 x 값 리턴   exp(y) e^y 값 리턴   pow(x,y) x^y 값 리턴   random() 0~1보다 작은 임의의 실수 리턴   floor(x) x보다 작거나 같은 수 중 가장 큰 정수 리턴   round(x) x를 반올림한 정수 리턴   sqrt(x) x의 제곱근 리턴     x와 y는 정수/실수 가능\n 사용자 객체 생성  직접 객체 만들기  new Object() 이용: 자바스크립트 코어 객체 중 Object타입 이용 리터럴 표기법 이용   객체의 틀(프로토타입)을 만들고 객체 생성하기  new Object()  new Object()로 빈 객체 생성 빈 객체에 프로퍼티 추가  새로운 프로퍼티 추가(프로퍼티 이름과 초기값 지정)   빈 객체에 메소드 추가  메소드로 사용할 함수 미리 작성 새 메소드 추가(메소드 이름에 함수 지정)    //메소드로 사용할 3 개의 함수 작성 function inquiry() { return this.balance; } // 잔금 조회 function deposit(money) { this.balance += money; } // money 만큼 저금 function withdraw(money) { // 예금 인출, money는 인출하고자 하는 액수 // money가 balance보다 작다고 가정  this.balance -= money; return money; } // 사용자 객체 만들기 var account = new Object(); account.owner = \"반정훈\"; // 계좌 주인 프로퍼티 생성 및 초기화 account.code = \"111\"; // 코드 프로퍼티 생성 및 초기화 account.balance = 35000; // 잔액 프로퍼티 생성 및 초기화 account.inquiry = inquiry; // 메소드 작성 account.deposit = deposit; // 메소드 작성 account.withdraw = withdraw; // 메소드 작성 리터럴 표기법 중괄호를 이용하여 객체의 프로퍼티와 메소드를 한 번에 작성 가능\nvar account = { // 프로퍼티 생성 및 초기화  owner : \"반정훈\", // 계좌 주인 프로퍼티 추가  code : \"111\", // 계좌 코드 프로퍼티 추가  balance : 35000, // 잔액 프로퍼티 추가  // 메소드 작성  inquiry : function () { return this.balance; }, // 잔금 조회  deposit : function(money) { this.balance += money; }, // 저금. money 만큼 저금  withdraw : function (money) { // 예금 인출, money는 인출하고자 하는 액수  // money가 balance보다 작다고 가정  this.balance -= money; return money; } }; ","excerpt":"구성 여러 개의 프로퍼티와 메소드로 구성\n 프로퍼티: 객체의 고유한 속성(변수) 메소드: …","ref":"/til/javascript/object/","title":"Object"},{"body":"에러 발생 $ pip3 install mysqlclient Collecting mysqlclient==1.4.4 Using cached https://files.pythonhosted.org/packages/4d/38/c5f8bac9c50f3042c8f05615f84206f77f03db79781db841898fde1bb284/mysqlclient-1.4.4.tar.gz Complete output from command python setup.py egg_info: /bin/sh: 1: mysql_config: not found /bin/sh: 1: mariadb_config: not found /bin/sh: 1: mysql_config: not found Traceback (most recent call last): File \"\u003cstring\u003e\", line 1, in \u003cmodule\u003e File \"/tmp/pip-build-s70o3t7s/mysqlclient/setup.py\", line 16, in \u003cmodule\u003e metadata, options = get_config() File \"/tmp/pip-build-s70o3t7s/mysqlclient/setup_posix.py\", line 61, in get_config libs = mysql_config(\"libs\") File \"/tmp/pip-build-s70o3t7s/mysqlclient/setup_posix.py\", line 29, in mysql_config raise EnvironmentError(\"%s not found\" % (_mysql_config_path,)) OSError: mysql_config not found ---------------------------------------- Command \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-s70o3t7s/mysqlclient/ 에러 해결 sudo apt-get install libmysqlclient-dev -y  추가 패키지 설치를 진행하면 해당 에러가 사라진다.\n ","excerpt":"에러 발생 $ pip3 install mysqlclient Collecting mysqlclient==1.4.4 Using …","ref":"/til/django/oserror-mysqlconfig-not-found/","title":"OSError: mysql_config not found"},{"body":"개요 물리적 디스크를 여러개의 논리적인 디스크 영역으로 분할하는 것을 의미한다. 분할된 파티션은 하나의 독립적인 디스크로 간주된다.\n장점  하나의 디스크에 여러 OS를 설치 및 사용 가능 파티션 단위의 다양한 정책 설정 가능 사용자가 원하는 파일 시스템 구성이 가능 특정 파티션이 손상되어도 다른 파티션의 자료는 보존되기 때문에 안정성을 높일 수 있음 자료 이전 및 관리, 백업이 용이. 분할된 파티션의 경우 마운트 포인트 변경을 통해 쉽게 자료 이전 및 관리 부팅이 빨라지고 파일 시스템 점검 시간 단축  /boot 파티션 분할로 부팅 속도 향상 특정 파티션만 점검해서 시간 단축   특정 영역 데이터 증가에 따른 시스템 및 프로세스 중단을 방지   리눅스는 가상 메모리로 사용하는 swap 파티션을 반드시 설정해야 한다.\n파티션 분할이 필요한 영역: /, swap, /boot, /usr, /var, /home, /tmp\n 종류 주 파티션  부팅 가능한 파티션 하나의 물리디스크에 최대 4개 확장 파티션을 사용할 경우 3개까지  확장 파티션   하나의 물리티스크에 1개만 가능\n  자료 저장은 논리 파티션에 저장\n  논리 파티션   확장 파티션 안에 생성됨\n  5번 이후 번호를 부여\n  장치명 디스크 리눅스는 모든 장치를 파일명으로 관리하므로 어떤 디스크를 사용했는지에 따라 파일 이름이 달라진다. 초기에는 x86 시스템 기반의 IDE가 사용되었다. 당시 4개의 저장장치만 연결이 가능했기 때문에 각 장치에 따라 경로가 미리 지정되어 있다.\n   연결위치 파일명     Primary Master /dev/hda   Primary Slave /dev/hdb   Secondary Master /dev/hdc   Secondary Slave /dev/hdd     S-ATA, USB, SSD는 /dev/sdx에서 관리한다.\n 파티션 분할된 파티션은 디스크 장치 파일명 뒤에 숫자를 붙여서 관리한다. 일반 IDE 방식 디스크에는 /dev/hda1 형식으로 생성되고, SCSI, S-ATA, SSD, USB메모리 등에는 /dev/sdb1과 같은 형식으로 생성된다.\n 디스크 유형에 따라 hd 혹은 sd로 지정 디스크 우선순위에 따라 알파벳 a부터 표기 파티션 번호  파티션 확인 파티션 정보는 fdisk 명령어를 통해서 확인할 수 있다.\n$ fdisk -l  fdisk는 부팅시 새로운 파티션을 인식하기 때문에 최근 생성된 파티션은 /proc/partitions 파일에서 확인해야 한다.\n partprobe 명령어를 이용해서 재부팅 없이 파티션을 재인식 시키는 방법도 존재한다.\n관련기술 LVM 리눅스에서 하드디스크는 파티션으로 분할되어 공간이 할당되는데, 이후 용량을 변경하는 것이 불가능하다. LVM은 이러한 문제를 해결해주는데, 파티션의 크기 변경뿐 아니라 여러 개의 물리적 디스크를 하나처럼 사용하는 것도 가능케 한다.\n구성  물리적 볼륨(PV): 실제 디스크에서 물리적으로 분할한 파티션 볼륨 그룹(VG): 물리적 볼륨의 그룹 논리적 볼륨(LV): 사용자가 필요한 만큼 할당해서 만들어지는 공간 물리적 확장(PE): PV에서 나누어 사용하는 일종의 블록같은 영역  RAID 여러 개의 하드디스크가 있을 때 동일 데이터를 다른 위치에 중복해서 저장하는 방법. OS에서는 하나의 RAID를 하나의 디스크로 인식한다. 데이터를 기록하는 방식과 에러를 체크하는 방법에 따라 다양한 형태로 존재한다.\n이용 목적  백업이 가능하고 안정적인 데이터 보존과 유지기능, 속도 향상 등 구성 방법도 S/W나 H/W로 구현이 가능 비용적 측면에서는 S/W가 우세하나 속도로는 H/W가 뛰어남  사용되는 기술  스트라이핑(Striping)  연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록 읽고 쓰는 속도가 하나의 디스크에서 하는 것보다 빠름   미러링(Mirroring)  디스크에 에러가 발생 시 데이터 손실을 막기 위해 추가적인 장치에 중복 저장하는 기술 그렇기 때문에 미러링 기술을 결함 허용이라고도 함    ","excerpt":"개요 물리적 디스크를 여러개의 논리적인 디스크 영역으로 분할하는 것을 의미한다. 분할된 파티션은 하나의 독립적인 디스크로 간주 …","ref":"/til/linux/linux-master/partition/","title":"Partition"},{"body":"서버 관리자의 업무 시스템 시작/종료 $ shutdown -r now # 지금 즉시 시스템 재부팅 $ shutdown -h now # 지금 즉시 시스템 종료 $ half # 강제 종료 $ reboot # 강제 재부팅 사용자 계정 관리  원격 접근권한 제거  /etc/passwd 파일에서 /bin/bash 와 같은 셸 삭제   계정 사용기간 설정  /etc/shadow 파일에서 사용기간 또는 만료일 설정    자원 관리  프로세스 관리  관련 명령어   메모리 관리  free (메모리 및 swap 메모리 사용 현황)   디스크 관리  관련 명령어    네트워크 관리    명령어 설명     ifconfig 통신 디바이스(NIC) 상태   netstat -an 현 시스템에서 사용되는 통신 서비스의 상태   top 시스템 자원(CPU, memory 등)의 사용현황   ps -elf(-aux) 현 시스템에서 수행 중인 프로그램과 데몬 상태   snoop 패킷을 캡처하여 분석   nslookup 도메인에 대한 IP 정보 및 도메인 네임과 관련된 여러 검색   inetd 네트워크 슈퍼데몬인 inetd를 실행    윈도우 로그  이벤트(Event)라는 중앙 집권화된 로그를 수집하여 저장 관리는 편하나 보안수준이 낮음  이벤트 로그 종류  응용 프로그램 로그(AppEvent.Evt)  응용 프로그램이 기록한 다양한 이벤트 소프트웨어 개발자에 의해 결정   보안 로그(SecEvent.Evt)  로그인 시도, 리소스 사용에 관련된 이벤트 기록   시스템 로그(SysEvent.Evt)  Windows 시스템 구성요소가 기록하는 이벤트 구성요소의 오류를 이벤트에 기록   그 외  디렉터리 서비스 로그, 파일 복제 서비스 로그,DNS 서버 로그 등    이벤트 로그 파일은 %Windows%\\system32\\config 폴더에 위치\n 바이너리 형식이므로 별도의 프로그램 필요\n 감사 정책 어떤 로그를 남길지를 정의한 규칙\n 설정 경로: [제어판]-[관리 도구]-[로컬 보안 정책]-[로컬 정책]-[감사 정책]\n    이벤트 로그 설명     개체 액세스 감사 객체(특정 파일이나 디렉터리, 프린터 등)에 대한 접근 시도, 속성 변경 등 로그   계정 관리 감사 사용자 관련 설정 변경 로그를 탐지   계정 로그인 이벤트 감사 도메인 계정의 로그인에 대한 사항을 로그에 남김   권한 사용 감사 권한 설정 변경이나 관리자 권한이 필요한 작업을 수행할 때 로그에 남김   로그인 이벤트 감사 로컬 계정 접근 시 생성되는 이벤트를 감사   디렉터리 서비스 액세스 감사 액티브 디렉터리 개체에 접근하는 사용자에 대한 감사 로그   정책 변경 감사 사용자 권한 할당 정책, 감사 정책 또는 신뢰 정책의 변경과 관련된 사항을 로그에 남김   프로세스 추적 감사 프로세스를 시작하거나 중지할 때 해당 이벤트 발생   시스템 이벤트 감사 시스템의 시동과 종료, 보안 로그 삭제 등 시스템의 주요한 사항에 대한 이벤트를 남김    유닉스/리눅스 로그  로그를 여러 곳에 저장 모두 파악하고 관리하기 어려움 다양한 로그들의 분석으로 공격자 추적 가능  로그 종류    로그 설명     utmp 현재 시스템에 로그인한 사용자의 상태를 출력   wtmp 사용자의 로그인/로그아웃, 시스템 종료/부팅 정보를 저장   sulog su 명령어(계정 변경)에 대한 로그. 텍스트 형태로 저장   lastlog 각 사용자의 최근(마지막) 로그인 시각   acct/pacct 시스템에 로그인한 모든 사용자가 수행한 프로그램에 대한 정보를 저장   history 사용자별로 실행한 명령을 기록하는 로그. 텍스트 형태로 저장   btmp(Linux) 실패한 로그인 시도에 대한 로그   loginlog(Unix) 5회 이상 실패한 로그인 시도에 대한 로그   dmesg 부팅될 때 출력되는 모든 메시지를 기록   secure 원격 로그인 정보를 기록, TCP_WRAPPER(xinetd)의 접속제어에 관한 로그   messages 시스템 운영에 대한 전반적인 메시지를 저장    시스템 로그  유닉스에서는 syslog에 의해 로그를 생성하고 관리  /etc/syslog.conf   syslogd  OS에 의해 자동 실행 어떤 로그를 어디에 남길지 결정   최근 리눅스는 기존 syslog를 개선한 rsyslog를 사용  설정 파일 facility.priority action(logfile-location) facility에 대하여 priority의 경우에 해당하는 상황이 발생 시 logfile-location 파일에 기록\n   항목 도메인     facility *(모든 서비스), auth, authpriv(xinetd, telnet 등), cron, ftp, kern, lpr, mail, ntp, security, syslog   priority Emergency, Alert, Critical, Error, Warning, Notice, Info, Debug   action 로그를 어디에 남길지 결정   logfile-location 터미널/콘솔(/dev/console), 원격 로그 서버(@호스트주소), user(지정한 사용자 스크린), *(현재 로그인된 사용자)    웹 서버 로그 IIS 웹 서버 로그  기본 W3C 형식 주요 필드  date, time : 사용자가 페이지에 접속한 날짜와 시간 c-ip: 웹 페이지에 접속한 사용자 IP cs-username : 웹 페이지에 접속한 사용자 계정 s-computername : 웹 서버 이름 s-ip,s-port: 웹 서버 IP, 웹 서버 포트 cs-method: HTTP 메소드 cs-url-stem: 요청 페이지 cs-url-query: 요청 파라미터 sc-status : 응답 코드    Apache 웹 서버 로그  access log: 클라이언트의 요청에 의해 웹 서버가 응답한 내용에 대한 로그 error log: 클라이언트의 요청에 의해 웹 서버에 오류가 발생한 내용에 대한 로그  크래킹 S/W 크래킹이란 악의적인 목적을 가지고 시스템에 침임하는 행위이다.\n John the Ripper: 패스워드 점검도구로 유명한 프로그램 pwdump: 윈도우에서 패스워드를 덤프하기 위한 프로그램 L0phtCrack: 패스워드 취약점 점검도구 ipccrack: 패스워드를 원격지에서 추측하여 취약점을 점검하는 프로그램 chntpw: 물리적으로 접근이 가능한 시스템에서 패스워드를 리셋시키는 프로그램 ERD Commander: 윈도우에서 패스워드를 복구하는 프로그램 키로거(Keylogger): 키보드로 입력한 정보를 로그로 남겨 실기간으로/정해진 시간에 공격자에게 전송  서버보안용 S/W  SATAN  시스템 보안상의 약점을 찾아 보완할 수 있는 네트워크 분석용 보안 관리 도구   SARA (UNIX)  SATAN 기반 HTML 형식의 보고서 기능   SAINT (UNIX)  HTML 형식의 보고서 기능 원격에서 취약점을 점검하는 기능 포함   COPS (UNIX)  시스템 내부에 존재하는 취약점 점검 취약한 PW를 점검   Nessus (대부분 OS)  클라이언트-서버 구조 클라이언트의 취약점을 점검하는 기능 GUI 인터페이스 다양한 포맷으로 결과 저장   nmap  포트 스캐닝 도구    무결성 점검 도구 정상적인 상태의 디렉터리 및 파일 정보를 백업해두어 이전 정보와 현재 정보를 비교\n tripwire, MD5, Fcheck, AIDE 등  스캔 탐지 도구  mscan  메인 전체를 스캔하여 최근 많이 이용되는 주요 취약점을 한 번에 스캔   sscan  네트워크를 통해 취약점 점검을 수행할 수 있는 도구   portsentry  실시간으로 포트 스캔을 탐지하고 대응하기 위한 프로그램 공격 호스트를 경유하여 오는 모든 트래픽을 자동 재구성하는 기능    침입탐지 및 방화벽  Snort  실시간 트래픽 분석, IP 네트워크에서의 패킷 처리를 담당하는 IDS 버퍼오버플로우, stelth 포트 스캔, CGI 공격, SMB 프로브, OS 핑거프린팅 등 공격 감지   IPchain / IPtable  패킷 필터링 방화벽 인바운드, 아웃바운드 규칙 설정 가능    ","excerpt":"서버 관리자의 업무 시스템 시작/종료 $ shutdown -r now # 지금 즉시 시스템 재부팅 $ shutdown -h …","ref":"/til/security/system/server/security-management/","title":"Security Management"},{"body":"","excerpt":"","ref":"/til/security/system/server/","title":"Server"},{"body":"한 번의 시스템 인증을 통하여 접근하고자 하는 다양한 시스템에 재인증 절차 없이 접근할 수 있도록 하는 통합 로그인 솔루션\n 장점  각 시스템 별로 개별적인 ID/PW 설정이 필요 없음 패스워드 분실/망각 가능성 감소 관리의 간편함, 보안수준의 향상   단점  SSO서버 침해 시 모든 서버의 보안 침해 가능(단일 실패 지점) 자원별 권한관리 미비    엑스트라넷 접근 관리(EAM, Extranet Access Management) 인트라넷, 엑스트라넷 및 일반 클라이언트/서버 환경에서 자원의 접근 인증과 이를 기반으로 자원에 대한 접근 권한을 부여/관리하는 통합 인증 관리 솔루션\n식별/접근 관리(IAM, Identity and Access Management) ID와 패스워드를 종합적으로 관리해주는 역할 기반의 계정 관리 솔루션. EAM을 확장/보완한 솔루션\n커버로스(Kerberos) 개방된 네트워크 내에서 서비스 요구를 인증하기 위해 대칭키 암호기법에 바탕을 둔 티켓 기반 인증 프로토콜이자 KDC\n 분산 환경을 위한 SSO 기업 접근 통제를 위한 확장성, 투명성, 안정성, 보안을 제공  구성 요소  키 분배 서버(KDC, Key Distribution Center): Kerberos의 핵심 요소 인증 서버(AS, Authentication Server): 실질적으로 인증을 수행 티켓 분배 서버(TGS, Ticket Granting Server): 티켓을 부여/분배 티켓: 사용자에 대해 신원과 인증을 확인하는 토큰  인증 과정  커버로스는 모든 사용자의 패스워드를 알고 있고, 중앙집중식 DB에 그 패스워드를 저장하고 있는 AS를 이용 AS는 각 서버와 유일한 비밀키를 공유 TGS는 AS에게 인증 받은 사용자에게 티켓을 발행 사용자가 새 서비스를 요청할 때마다 자신을 인증하는 티켓을 이용하여 TGS에 접속, TGS가 해당 서비스에 대한 티켓 발행 사용자는 서비스 승인 티켓을 보관하고 필요할 때마다 티켓을 사용하여 서버에 인증 타임스탬프로 위장하는 것을 방지  취약점  단일 실패 지점 비밀키는 사용자의 워크스테이션에 임시저장(공격자에게 탈취 가능성) 패스워드 추측 공격에 취약  V4 vs V5    항목 V4 V5     알고리즘 DES 모든 대칭키 암호   주소 유형 IP 모든 네트워크 주소   티켓 유효기간 한계치 존재 원하는 만큼 지정, 갱신 가능    세사미(SESAME)  커버로스의 기능을 확장하고 약점을 보완하기 위해 개발된 SSO 기술 비대칭키 및 대칭키 암호화 기술에 기반 티켓이 대신 PAC(Privileged Attribute Certificate)를 사용  ","excerpt":"한 번의 시스템 인증을 통하여 접근하고자 하는 다양한 시스템에 재인증 절차 없이 접근할 수 있도록 하는 통합 로그인 솔루션\n  …","ref":"/til/security/access-control/sso/","title":"SSO(Single Sign On)"},{"body":"전형적인 구조  페이지 번호 창 제목 소제목 본문 텍스트 문단 설명 섹션 등등   웹 문서를 만들때 표준화될 수 있다면, 활용 가능성 극대화 가능\n 문서 구조화 기존 HTML의 한계  웹 문서 구조를 표현하는 태그가 없음 div태그나 table태그로 구조화되어 보이게 작성 HTML 페이지 소스를 통해 전체 구조 파악이 불가능  문서 구조화의 이유  검색 엔진이 좋아하는 웹 페이지 작성의 필요성 정보 탐색이 중요해진 시대 사물인터넷으로 IT장치들이 스스로 정보 검색하는 시대 사용자가 만든 웹 페이지 가치 극대화  시멘틱 웹  웹 문서를 구조화하여 의미 있는 내용 탐색이 용이한 웹 기존 태그  p, div, h1, h2 등 태그 사용 문서 구조나 의미 전달 어려움   시멘틱 태그  문서의 구조와 의미를 전달함 header, section, article, main, summary, mark, time 등    구글 검색 엔진 사례  웹 페이지에서 시맨틱 태그 검색 이를 기반으로 리뷰, 사람, 제품, 업체, 이벤트, 음악 등 검색 결과를 제공  ","excerpt":"전형적인 구조  페이지 번호 창 제목 소제목 본문 텍스트 문단 설명 섹션 등등   웹 문서를 만들때 표준화될 수 있다면, …","ref":"/til/html5/structure/","title":"Structure"},{"body":"","excerpt":"","ref":"/til/security/cryptology/symmetric-cryptography/","title":"Symmetric-Cryptography"},{"body":"리스트 꾸미기 리스트는 데이터 나열 이외에도 목차나 메뉴를 만들거나 관련 링크 모음을 만드는 등 여러 용도로 활용\n마커 위치 list-style-position: inside|outside 마커 종류 list-style-type: disc|armenian|circle|cjk-ideographic|decimal|georgian|lower-alpha|lower-roman|square|upper-alpha|upper-roman|none 이미지 마커 사용자가 이미지 마커 지정CSS3 lis-style-image: url(\"이미지 위치\");\n단축 프로퍼티 list-style: list-style-type list-style-position list-style-image 표 꾸미기 테두리 table{ border: 1px solid blue; /* 테두리 두께, 선 스타일, 색상 */ border-collapse: collapse; /* 중복된 테두리 합치기 */ } 셀 크기 th { height: 40px; width: 100px; } td { height: 20px; width: 100px; } 셀 여백 및 정렬 td { padding: 10px; /* 여백 */ text-align: left|center|right } 배경색과 테두리 효과 thead { background : darkgray; color : yellow; } td, tfoot th { border-bottom : 1px solid gray /* 아래쪽테두리만회색*/ } 줄무늬 행에 번갈아 배경색을 주어 줄무늬를 만들어 가도성을 높임\ntbody tr:nth-child(even) { /* 짝수\u003ctr\u003e에적용*/ background : aliceblue; } 폼 꾸미기 input[type=text]:hover { border: 2px solid skyblue; border-radius: 5px; }  마우스가 위에 올라갔을 때 text 속성을 가진 input 태그 스타일이 적용됨\n 동적 변화 애니메이션 HTML 태그의 모양 변화를 시간 단위로 설정\n @keyframes로 HTML 태그의 시간별 모양 변화 그리기  @keyframestextColorAnimation{ 0% { color : blue; } /* 시작시. 0% 대신 from 사용가능*/ 30% { color : green; } /* 30% 경과시까지*/ 100% { color : red; } /* 끝까지. 100% 대신 to 사용가능*/  애니메이션 스타일 시트 작성  span { animation-name : textColorAnimation; /* 애니메이션코드이름*/ animation-duration : 5s; /* 애니메이션1회시간은5초*/ animation-iteration-count : infinite; /* 무한반복*/ } 전환 HTML 태그에 적용된 CSS3 프로퍼티 값의 변화를 서서히 진행시켜 애니메이션 효과 생성, transition 프로퍼티 사용\nspan{ transition : font-size 5s; } span:hover{ font-size : 500%; } 변환 텍스트나 이미지를 회전, 확대 다양한 기하학적인 모양으로 출력\ndiv { transform : rotate(20deg); } ","excerpt":"리스트 꾸미기 리스트는 데이터 나열 이외에도 목차나 메뉴를 만들거나 관련 링크 모음을 만드는 등 여러 용도로 활용\n마커 위치  …","ref":"/til/css/advanced-uses/","title":"Advanced-Uses"},{"body":"생성방법  []로 배열 만들기 Array 객체로 만들기  []로 배열 만들기   [] 안에는 원소들의 초기값 나열\nvar week = [\"월\", \"화\", \"수\", \"목\", \"금\", \"토\", \"일\"] var plots = [-20, -5, 0, 15, 20];   배열 크기는 고정적이지 않으며, 원소 추가시 확장\nplots[5] = 33; // plots 배열에 6번째 원소 추가. 배열 크기 = 6 plots[6] = 22; // plots 배열에 7번째 원소 추가. 배열 크기 = 7   Array 객체로 만들기  초기 값을 가진 배열 생성 var week = new Array(\"월\", \"화\", \"수\", \"목\", \"금\", \"토\", \"일\");  초기화되지 않은 배열 생성 var week = new Array(7); // 7개의 원소를 가진 배열 생성 week[0] = “월”; week[1] = “화”; ... week[6] = “일”;  빈 배열 생성 var week = new Array(); // 빈 배열 생성 week[0] = \"월\"; // 배열 크기 = 1 week[1] = \"화\"; // 배열 크기 = 2  배열에 원소 추가시 크기가 확장된다.\n   length 프로퍼티 원소 개수 배열 크기는 Array 객체의 length 프로퍼티를 사용\nvar plots = [-20, -5, 0, 15, 20]; var week = new Array(\"월\", \"화\", \"수\", \"목\", \"금\", \"토\", \"일\"); var m = plots.length; // m = 5 var n = week.length; // n = 7 배열 크기 변경  length 프로퍼티는 Array 객체에 의해 자동 관리 사용자가 임의로 값 변경 가능  plots.length = 10; // plots의 크기는 5에서 10으로 늘어남 plots.length = 2; // plots의 크기는 2로 줄어 들어, 처음 2개의 원소 외에는 모두 삭제 됨 특징  여러 타입의 데이터 저장 가능 배열은 Array 객체   []로 생성해도 Array 객체로 다루어짐\n 주요 메소드    메소드 설명     concat(arr) 현재 배열에 arr의 원소들을 덧붙여 리턴   join([separator]) 배열의 모든 원소를 연결하여 하나의 문자열로 만들어 리턴   reverse() 원소를 역순으로 재배열하고, 이를 복사한 새로운 배열 리턴   slice(a,[b]) 두 인덱스 a, b 사이 원소들로 구성된 새 배열 리턴   sort() 문자열을 사전 순으로 정렬, 새로운 배열 리턴   toString() 원소들을 모두 연결하여 문자열 리턴. 원소 사이에 “,” 삽입    ","excerpt":"생성방법  []로 배열 만들기 Array 객체로 만들기  []로 배열 만들기   [] 안에는 원소들의 초기값 나열\nvar …","ref":"/til/javascript/array/","title":"Array"},{"body":"개요 컴퓨터 상에 여러 운영체제가 설치되어 있는 경우 선택하여 부팅할 수 있게 하는 프로그램이다. 부트로더(Boot Loader)라고도 하며, 하드디스크의 맨 앞 영역인 MBR(Master Boot Record)에 설치된다.\n MBR은 하드디스크의 첫 번째 섹터인 512바이트 부트섹터로, 부트 매니저와 파티션 정보가 기록되어 있다.\n 운영체제의 부팅과정  바이오스가 컴퓨터에 장착된 하드웨어 점검 CMOS에 설정된 첫 부팅 하드디스크를 확인 부팅디스크의 MBR 영역에 있는 부트 매니저 실행 관련 환경 설정 파일을 참고하여 OS 부팅  종류 LILO LILO(Linux Loader)는 특정 파일 시스템에 구애받지 않으며, 플로피 디스크와 하드디스크를 이용한 부팅을 지원하였다. 하지만 8GB 영역이 넘어가는 곳에 리눅스가 설치되면 부팅이 되지 않는 문제가 있었고, 환경 설정 파일인 /etc/lilo.conf를 수정하면 lilo라는 명령어를 반드시 수행해야 한다는 불편함이 있어서 현재는 잘 사용하지 않는다.\nGRUB GNU프로젝트에서 만든 부트로더로 LILO에 비해 다양한 파일 시스템을 지원하고, 부팅 시 커널 인자를 조정하여 동적인 부팅을 지원한다.\n부트 화면  메뉴 목록 GUI로 표시 상하 방향키와 [ENTER] 사용 [a], [e], [c]를 눌러 커널 인자 조정  부트 모드  [a]: grub.conf에 커널과 관련된 부분의 매개변수 추가 가능 [e]: grub.conf에 등록된 부팅 목록의 모든 항목을 직접 편집 [c]: 상호대화식으로 직접 입력할 수 있는 모드   편집모드에서 지원하는 키 - e: 커서가 위치한 줄 편집 - d: 커서가 위치한 줄 삭제 - o: 명령 줄을 커서가 위치한 줄 아래에 추가 - O: 명령 줄을 커서가 위치한 줄 위에 추가 - b: 부팅 시작\n 환경설정 파일  /boot/grub/grub.conf\n 로그인/로그아웃 실행레벨 컴퓨터 실행시 GRUB은 커널을 로드하고, 파일 시스템을 마운트하고 점검한다. 이후 실행되는 init 프로세스는 시스템 부팅에 필요한 rc.sysinit, rc, rc.local을 실행하고 로그인 창을 호출한다.\n   레벨 설명     0 시스템을 중지할 때 호출   1 단일사용자모드로 로그인 과정 없이 root 사용자로 부팅, root 패스워드를 잊어버렸거나 시스템 점검시 접근   2 네트워크를 사용하지 않는 다중사용자모드   3 다중사용자모드, X윈도를 사용하지 않고 메모리를 효율적으로 이용 가능   4 사용자가 정의하여 사용가능   5 X윈도를 사용하는 다중사용자모드   6 시스템을 재부팅할 때 호출    로그인   실행레벨이 3인 경우\n [CTRL]+[ALT]+[F1~6]로 가상 콘솔 실행 getty라는 프로그램이 콘솔에 로그인 프로그램을 실행함.    실행레벨이 5인 경우\n X-Windows 기반의 그래픽 로그인 창이 나타남    로그아웃  logout 또는 exit 명령어 [CTRL]+[D] X-Windows에서는 메뉴 클릭   일정시간 작업하지 않을 시 강제 로그아웃: /etc/profile에 ‘TMOUT=초’를 설정\n ","excerpt":"개요 컴퓨터 상에 여러 운영체제가 설치되어 있는 경우 선택하여 부팅할 수 있게 하는 프로그램이다. 부트로더(Boot …","ref":"/til/linux/linux-master/boot-manager/","title":"Boot Manager"},{"body":"  Pick a dircolors theme from Github repository\n  Download files in the user’s HOME\n  # Download dircolors.ansi-dark\rcurl https://raw.githubusercontent.com/seebi/dircolors-solarized/master/dircolors.ansi-dark --output ~/.dircolors\rEdit ~/.zshrc  # set dircolors\reval `dircolors ~/.dircolors`\r","excerpt":"  Pick a dircolors theme from Github repository\n  Download files in …","ref":"/til/zsh/change-directory-color/","title":"Changing Directory Color"},{"body":"Project 생성 장고를 이용하여 개발을 진행하기 위해서는 프로젝트를 생성해야만 한다.\n 프로젝트는 장고에서 개발 대상이 되는 프로그램들을 의미한다.\n 준비 프로젝트 생성에 앞서 장고가 설치된 가상환경이 준비되어 있어야 한다. 만약에 준비되어 있지 않다면 해당 링크를 참고해서 가상환경을 만들어 주도록 하자.\n가상환경이 준비되었다면 아래 명령어로 가상환경을 실행한다.\n$ source \"가상환경명\"/scripts/activate $ source \"가상환경명\"/bin/activate  윈도우의 경우 첫번째 명령어를, 맥이나 리눅스의 경우 아래 명령어를 사용한다.\n (env) ~/django_workspace/project master $ 정상적으로 가상환경을 실행했을 시 다음과 같이 쉘 상에 가상환경명이 표기된다.\n명령어 $ django-admin startproject \"프로젝트명\" . 프로젝트를 생성하면 필요한 파일이나 디렉터리가 자동적으로 생성된다.\nworkspace(작업 디렉토리)\r├── venv(가상환경)\r├── manage.py\r└── project\r└── settings.py\rurls.py\rwsgi.py\r__init__.py\r위는 트리 구조로 디렉토리와 파일을 나타낸 것이다.\n프로젝트를 생성하는 명령어에는 점(.)이 포함되는데, 이것의 의미는 현재 디렉토리(경로)에 프로젝트 관련 파일들을 생성하라는 의미다.\n 명령어에서 점(.)은 현재 경로를 의미한다.\n 그렇다면 프로젝트를 생성하는 명령어에서 점(.)을 지정해주지 않는다면 어떻게 될까?\n$ django-admin startproject \"project\" workspace라는 디렉토리에서 venv라는 가상환경을 생성하여 작업 중이라 가정할때, project라는 프로젝트를 점(.) 없이 생성한다면 다음과 같은 일이 벌어질 것이다.\nworkspace(작업 디렉토리) ├── venv(가상환경) └── project* ├── manage.py └── project └── settings.py urls.py wsgi.py __init__.py 점(.)을 붙이고 생성했을 때와는 달리 project라는 이름의 폴더가 하나 더 있다는 것을 알 수 있다. (*로 표기된 것)\n이것이 크게 문제가 되는 것은 아니나, 명령어를 내리거나 프로젝트를 관리하는데 있어서 불편함을 야기하므로 되도록 점(.)을 사용하여 프로젝트를 생성하도록 하자.\nApp 생성 App은 프로젝트의 구성단위로 보통 프로젝트 폴더가 생성된 경로에 동일하게 생성된다.\n명령어 $ python manage.py startapp \"App명\" 서버 작동 정상적으로 장고 프로젝트가 생성되었는지 확인하기 위해서는 서버를 작동시켜야 한다.\n$ python manage.py runserver  MAC OS X와 Linux의 경우 python3 사용\n 위 명령어를 사용하면, 장고 프로젝트가 로컬에서 실행된다.\n 작동중인 로컬 서버는 로컬주소인 127.0.0.1:8000에서 확인할 수 있다.\n 서버 종료는 ctrl+c로 할 수 있다.\n","excerpt":"Project 생성 장고를 이용하여 개발을 진행하기 위해서는 프로젝트를 생성해야만 한다.\n 프로젝트는 장고에서 개발 대상이 되 …","ref":"/til/django/study/create-project-and-app/","title":"Create Project \u0026 App"},{"body":"웹 페이지에서 사용자 입력을 받는 폼으로 로그인, 등록, 검색, 예약, 쇼핑 등에 사용\n작성 방법 form 태그로 둘러쌈\nname 속성 폼의 이름을 지정\naction 속성 폼 데이터를 처리할 웹 서버 응용프로그램 이름\n submit이 눌리면 브라우저는 action에 지정된 웹 서버에 실행 요청  method 속성 폼의 데이터를 웹 서버로 전송하는 형식\n GET/POST  요소  폼을 만드는 다양한 태그 input, textarea, select 등  텍스트 \u003cinput type=\"text\" value=\"일반 텍스트\"\u003e \u003cinput type=\"password\" value=\"비밀번호 형식의 텍스트\"\u003e \u003ctextarea\u003e이곳에 텍스트가 작성됩니다.\u003c/textarea\u003e 목록 datalist 태그\n 목록 리스트를 작성하는 태그 네이버 등에서 추천목록 표시에 사용 option 태그로 항목 하나 표현  Countries: \u003cinput type=\"text\" list=\"countries\"\u003e \u003cbr\u003e \u003cdatalist id =\"countries\"\u003e \u003coption value=\"가나\"\u003e \u003coption value=\"스위스\"\u003e \u003coption value=\"브라질\"\u003e \u003c/datalist\u003e 버튼 input태그나 button태그\n type 속성은 버튼의 기능을 정의  \u003cinput type=\"button\" name=\"버튼\" value\"버튼1\"\u003e \u003cbutton type=\"button\"\u003e버튼2\u003c/button\u003e \u003cinput type=\"button\" name=\"버튼\" src=\"이미지\"\u003e \u003cbutton type=\"button\"\u003e \u003cimg src=\"이미지\" alt=\"이미지버튼\"\u003e \u003c/button\u003e  버튼의 type에는 button, reset, submit이 있음\n 선택형 입력 선택형 입력에서는 checkbox나 radio태그 사용\n\u003cform\u003e 짜장면\u003cinput type=\"checkbox|radio\" name=\"요소 이름\" value=\"1\"\u003e 탕수육\u003cinput type=\"checkbox|radio\" name=\"요소 이름\" value=\"2\" checked\u003e \u003c!-- 체크 --\u003e 짬뽕\u003cinput type=\"checkbox|radio\" name=\"요소 이름\" value=\"3\"\u003e \u003c/form\u003e 콤보 박스 select태그\n 드롭다운 리스트에 목록 출력 목록을 선택하는 입력 방식 option 태그로 항목 하나 표현   선택지 이외에 항목 선택 불가\n \u003cselect name=\"china\"\u003e \u003coption value=\"1\"\u003e짜장면\u003c/option\u003e \u003coption value=\"2\" selected\u003e탕수육\u003c/option\u003e \u003coption value=\"3\"\u003e짬뽕\u003c/option\u003e \u003c/select\u003e 레이블 폼 요소의 캡션을 정의, 두 가지 방법이 존재\n 캡션: 폼 요소를 한 단위로 묶어 이름을 정의\n \u003clabel\u003e아이디: \u003cinput type=\"text\"\u003e\u003c/label\u003e \u003clabel for=\"pass\"\u003e비밀번호: \u003c/label\u003e \u003cinput id=\"pass\" type=\"password\"\u003e 색 입력 \u003cform\u003e \u003cinput type=\"color\" value=\"#00BFFF\" onchange= \"document.body.style.color=this.value\"\u003e \u003c/form\u003e  html에서의 색 표현은 RGB hex값으로 표기\n 시간 정보 \u003cpre\u003e month :\u003cinput type=\"month\" value=\"2016-09\"\u003e\u003cbr\u003e week : \u003cinput type=\"week\" value=\"2016-W36\"\u003e\u003cbr\u003e data : \u003cinput type=\"date\" value=\"2016-09-01\"\u003e\u003cbr\u003e time : \u003cinput type=\"time\" value=\"21:30\"\u003e\u003cbr\u003e local:\u003cinput type=\"datetime-local\" value=\"2016-09-01T21:30:10.32\"\u003e\u003cbr\u003e \u003c/pre\u003e 숫자  스핀버튼: number 슬라이드 바: range  \u003cinput type=\"number\" min=\"0.0\" max=\"10.0\" step=\"0.5\"\u003e \u003cinput type=\"range\" min=\"0\" max=\"100\" list=temperatures\u003e \u003cdatalist id=\"temperatures\"\u003e \u003coption value=\"10\" label=\"Low\"\u003e \u003coption value=\"50\" label=\"Medium\"\u003e \u003coption value=\"90\" label=\"High\"\u003e \u003c/datalist\u003e 입력 정보 힌트 placeholder 속성에 사용자가 입력할 데이터 힌트 작성\nemail: \u003cinput type=\"url\" placeholder=\"id@host\"\u003e webpage: \u003cinput type=\"url\" placeholder=\"http://\"\u003e phone: \u003cinput type=\"url\" placeholder=\"010-1234-5678\"\u003e 그룹핑 fieldset 태그로 폼 요소들을 그룹핑하고 legend로 그룹 제목 표기\n\u003cfieldset\u003e \u003clegend\u003e회원정보\u003c/legend\u003e 이메일: \u003cinput type=\"email\"\u003e\u003cbr\u003e 홈페이지: \u003cinput type=\"url\"\u003e\u003cbr\u003e 전화번호: \u003cinput type=\"tel\"\u003e \u003c/fieldset\u003e ","excerpt":"웹 페이지에서 사용자 입력을 받는 폼으로 로그인, 등록, 검색, 예약, 쇼핑 등에 사용\n작성 방법 form …","ref":"/til/html5/form/","title":"Form"},{"body":"함수(fuction)이란 재사용 가능한 프로그램 코드 블록으로, 자주 수행되는 작업을 매번 새로운 코드로 처리하지 않기 위해서 사용한다.\n 내장 함수 사용자 정의 함수 외장 함수   함수는 크게 위와 같이 분류한다.\n 내장 함수 사전에 파이썬에 정의되어 있는 함수로 바로 호출하여 사용 가능하다. 객체의 자료형을 판단하는 type이나 for문과 함께 사용하는 range가 여기에 해당한다. 내장 함수를 무작정 외우기보다는 프로그래밍을 하면서 자연스럽게 익히도록 하자.\n   내장 함수 설명     abs 특정 숫자 입력 받았을 때 그 숫자의 절대 값을 반환   all 내용이 참이면 참(true) 하나라도거짓이 있으면 거짓(false)을 반환   chr 아스키 코드 값 입력 받아 이에 해당하는 문자 출력   ord 문자를 입력 받아 해당 아스키 코드 값을 리턴   divmod 2개의 숫자를 입력 받아 2개 값을 나눈 몫과 나머지를 튜플 형태로 반환   enumerate 자료형을 입력받아 인덱스 값을 포함하는 해당 객체를 리턴   eval 실행 가능한 문자열을 입력받아 문자열을 실행한 결괏값 반환   id 객체를 입력받아 객체의 고유 주소 값(레퍼런스)을 반환   isinstance 첫 번째 인수로 인스턴스, 두 번째 인수로 클래스 이름을 받는다. 입력받은 클래스의 인스턴스가 맞는지를 판단하여 boolean 반환   len 입력값의 길이(요소의 개수)를 반환   list 반복 가능한 자료형 s를 입력받아 리스트로 만들어 반환   max 반복 가능한 자료형을 입력받아 그 최댓값을 반환   min 반복 가능한 자료형을 입력받아 그 최소값을 반환   oct 정수 형태의 숫자를 8진수 문자열로 반환   pow pow(x, y)는 x의 y 제곱한 결괏값을 반환   range 입력받은 숫자에 해당하는 범위 값을 반복 가능한 객체로 만들어 반환   round 숫자를 입력받아 반올림   sorted 입력값을 정렬한 후 그 결과를 리스트로 반환   sum 입력받은 리스트나 튜플의 모든 요소의 합을 반환   tuple 반복 가능한 자료형을 입력받아 튜플 형태로 바꾸어 반환   type 입력값의 자료형이 무엇인지 반환   zip 동일한 개수로 이루어진 자료형을 묶어 준다    사용자 정의 함수 사용자 정의 함수는 매우 중요하다. 이것은 프로그래머가 자신의 프로그램에서 자주 사용되는 작업을 함수로 직접 정의하는 것으로 코드의 재사용성을 높이고 반복적인 작업을 줄일 수 있게 하기 때문이다.\n기본 구조 \u003e\u003e\u003e def 함수명(인수):\r... 실행할 명령어\r... return 값\r함수는 기본적으로 입력 값을 받아 처리하고 이에 대한 결과값을 돌려주는 형태로 이루어져 있다. (입력 -\u003e 처리 -\u003e 출력 )\n\u003e\u003e\u003e def add(a,b): ... c=a+b ... return c \u003e\u003e\u003e add(1,2) 3 위 코드는 두 수를 입력받아서 더한 값을 돌려주는 간단한 함수이다. 이와 같이 자주 사용하는 작업들은 함수로 정의해서 처리하는 것이 좋다.\n다른 형태 하지만 모든 함수가 입력값이나 출력값이 꼭 있어야 하는 것은 아니다. 만약 입력하는 값이 없다면 인수부분을 비워두면 되고, 출력 값이 없다면 return을 적지 않으면 된다.\n\u003e\u003e\u003e def add(a,b): ... c=a+b ... print(c) # 값을 반환하지 않고 출력 \u003e\u003e\u003e add(1,2) 3 위에서 처리한 함수를 리턴값 없이 만든다면 다음과 같이 할 수 있을 것이다. 보기에는 동일하게 더한 값이 출력되지만 결정적인 차이가 존재한다.\n값을 반환하는 경우에는 이 값을 변수에 담아서 활용하는 것이 가능하지만, 함수 내에서 결과를 출력하는 경우에는 이것이 불가능하다는 점이다.\n","excerpt":"함수(fuction)이란 재사용 가능한 프로그램 코드 블록으로, …","ref":"/til/python/study/function/","title":"Function"},{"body":"임의의 길이를 가지는 메시지를 고정된 길이의 값으로 바꾸어주는 함수\n일방향 해시함수  출력 값 = 해시 값 = 메시지 다이제스트 일방향성  해시값으로부터 메시지 역산 불가   충돌  해시 값 하나에 여러 메시지 존재 충돌을 발견하기란 어려움  이러한 성질을 충돌 내성이라 함 따라서 데이터 변조가 어렵고, 무결성이 확보됨      공격 기법  무차별 공격  약한 충돌 내성을 깨기 위한 공격   일치블록 연쇄공격  사전에 해시 값을 다양하게 생성 후 공격하고자 하는 메시지의 해시 값과 동일한 것을 찾는 공격   중간자 연쇄공격  전체 해시 값이 아닌 해시 중간 결과에 대한 충돌 쌍을 찾음   고정점 연쇄공격  메시지 블록과 연쇄변수 쌍을 얻어 연쇄변수가 발생하는 특정한 점에 임의의 동등한 블록들을 메시지 중간에 삽입해도 전체 해시 값이 변하지 않음   차분 연쇄공격  압축함수의 입출력 차이를 조사하여 0의 충돌쌍을 찾는 공격    보안 요구사항 무결성 점검 암호학적 해시함수를 사용하여 이전 해시값과 새로운 해시값이 동일하다면 메시지가 변경되지 않았음을 확인할 수 있다.\n암호학적 해시함수 기준 암호학에서 사용될 수 있는 안전하다고 여겨지는 해시 함수를 암호학적 해시함수라 한다. 아래는 암호학적 해시함수가 되기 위한 필요조건이다.\n 프리이미지 저항성(역상 저항성)  주어진 해시함수 h와 y=h(M)에 대하여 제 3자가 y=h(M')를 만족하는 M'를 발견하는 것이 매우 힘들어야 한다는 성질 프리이미지(preimage)  해시값 h=H(x)에 대해 x는 h의 프리이미지(선 이미지)라 한다. H가 다대일 대응이므로 특정 해시 값 h에 여러 개의 선 이미지 존재     제2프리이미지 저항성(약한 충돌 내성)  메시지를 쉽게 위조할 수 없게 하는 특성 제 3자가 메시지 M과 그것의 다이제스트 h(M)을 가로챘을 경우, h(M) = h(M')을 만족하는 또 다른 메시지 M'을 생성하기 매우 어려워야 한다는 성질   충돌 저항성(강한 출동 내성)  제3자가 동일한 메시지 다이제스트를 갖는 2개의 메시지 쌍을 구하지 못하게 하는 성질    전자서명에 이용되는 해시함수 특성  해시 값을 고속으로 계산 가능 암호학적 해시함수 기준 3가지 모두 충족  암호학적 해시함수 메시지 다이제스트  MD2 -\u003e MD4 -\u003e MD5 MD5는 메시지를 512bit로 된 블록으로 나누어 128bit 다이제스트를 출력 128bit 메시지 다이제스트는 길이가 짧아 충돌 공격에 내성을 갖기 어려움  SHA(Secure Hash Algorithm) MD4 기반, 안전 해시 알고리즘\n SHA-1  해시값: 160bit 강한 충돌 내성이 깨졌음 안정성 문제로 SHA-2로 마이그레이션 진행   SHA-2  동일한 암호화 결함을 가짐 긴 해시길이로 SHA-1보다 안전 종류  SHA-224 SHA-256 SHA-384 SHA-512 SHA-512/224 SHA-512/256      ","excerpt":"임의의 길이를 가지는 메시지를 고정된 길이의 값으로 바꾸어주는 함수\n일방향 해시함수  출력 값 = 해시 값 = 메시지 다이제스 …","ref":"/til/security/cryptology/hash-function/","title":"Hash Function"},{"body":"사이버 공격을 위한 정보 수집은 풋 프린팅, 스캐닝, 목록화 과정을 거친다.\n풋 프린팅 공격자가 공격 전 다양한 정보 수집을 하는 단계\n 사회공학 기법이 주로 사용 IP블록, 이름 및 계정정보, 전화번호 등 수집  스캐닝 실제 공격방법 결정 또는 공격에 이용될 수 있는 네트워크 구조, 시스템이 제공하는 서비스 정보를 얻음\nSweep  네트워크에 속해 있는 시스템 유무 판단 목표 네트워크의 IP 주소와 네트워크 범위를 알아내는 기법  Open Scan 시스템 활성화 여부 및 서비스의 활성화 여부를 조사\n TCP Full Open Scan(=TCP SYN/ACK Scan)  완전한 TCP 연결을 맺어서 신뢰성 있는 결과를 얻을 수 있음 다만 속도가 느리고 로그를 남김   TCP Half Open Scan(=TCP SYN Scan)  세션을 완전히 연결하지 않고 포트의 활성화 여부를 판단 포트가 열려있는 경우  SYN/ACK 패킷을 받으면 그 즉시 RST 패킷을 보내 연결을 끊음 로그를 남기지는 않지만 세그먼트(SYN) 전송기록은 남음     UDP Scan  아무런 응답이 없으면 해당 포트의 활성화를 의미 ICMP Unreachable 패킷을 받으면 해당 포트의 비활성화를 의미    Stealth Scan TCP 헤더를 조작하여 특수한 패킷을 생성하여 보낸 후 그 응답으로 포트 활성화 파악\n 세션을 완전히 연결하지 않으므로 로그가 남지 않음\n  TCP FIN Scan  TCP 헤더 내에 FIN 플래그를 설정하여 전송   TCP NULL Scan  TCP 헤더 내에 플래그 값을 설정하지 않고 전송   TCP XMAS Scan  TCP 헤더 내에 모든 플래그를 설정하여 전송 포트가 열려있을 경우 응답없음, 포트가 닫힌 경우 RST 수신   TCP ACK-Scan  TCP 헤더 내에 ACK 플래그를 설정하여 전송 방화벽의 필터링 정책을 테스트  Stateful 방화벽인가 대상 포트가 방화벽에 의해 필터링되는가   필터링이 되는 경우 응답이 없거나 ICMP 메시지를 수신 필터링 되지 않으면 RST+ACK를 수신    NMap(Network Mapper) OS의 종류 및 사용 서비스에 대한 정보, FTP 서버의 취약점을 이용한 bounce 공격 수행 가능한 스캔 도구\n 모든 운영체제에서 사용 가능 오픈소스로 사용자가 기능 추가 가능  문법 nmap [scan_type] [port_option] [target]\r   속성 설명     -sS TCP SYN(Half-open) Scan   -sF TCP FIN Scan   -v 자세하게 출력   -O 대상 호스트의 OS 정보를 출력   -T NMap 속도 지정 (0 : 느림 ~ 5 : 빠름)   -f 스캔 시 F/W을 통과할 수 있도록 패킷을 분할    운영체제 탐지 배너 그래빙(banner grabbing)  상대 시스템의 OS를 확인하는 가장 기본적인 방법 banner는 원격지 시스템에 로그인하면 뜨는 안내문과 비슷한 것  TCP/IP  OS마다 TCP/IP에 대한 반응이 다르기 때문에 반응에 따라 OS를 추측 가능 FIN Scan은 모든 OS에 적용되지 않기 때문에 FIN Scan을 이용해 OS를 추측 가능 세션 연결 후 TCP 패킷의 Sequence Number(순서 번호) 생성을 관찰  윈도우 계열은 시간에 따른 순서 번호를 생성 리눅스 계열은 Random으로 생성    목록화 풋 프린팅, 스캐닝 작업을 통해 얻은 정보를 실제 공격에 사용할 수 있도록 목록화\n 공유 자원 목록화 사용자 및 그룹 목록화 응용프로그램 목록화  ","excerpt":"사이버 공격을 위한 정보 수집은 풋 프린팅, 스캐닝, 목록화 과정을 거친다.\n풋 프린팅 공격자가 공격 전 다양한 정보 수집을  …","ref":"/til/security/network/network-scanning/","title":"Network Scanning"},{"body":"강제적 접근통제(MAC, Mandatory Access Control) 자원의 보안 레벨과 사용자의 보안 취급 인가를 비교하여 접근 제어\n 관리자만이 접근제어의 규칙을 설정, 변경(중앙집중형 보안관리) 다중 수준 보안 정책에 기반함(서로 다른 분류 수준의 데이터가 보호되는 방법) 벨라파듈라(BLP), 비바 무결성 모델, 클락-윌슨 모델, 만리장성 모델이 대표적   모든 MAC 모델은 벨라파듈라(BLP) 모델을 근간으로 함\n  장점  매우 엄격한 보안 모든 객체에 대한 관리가 용이   단점  구현, 운영이 복잡 모든 접근에 대해 확인해야 하므로 성능 저하 상업적인 환경에 부적합    벨라파듈라 모델(BLP, Bell-LaPadula Confidentiality Model) 기밀성을 강조하고 수학적 모델에 기반하는 최초의 MAC 모델\n   장점 단점     트로이 목마 공격 불가낮은 단계에서 높은 단계로 가는 기밀성 유지에 강함 낮은 단계에서 높은 단계로 글을 쓸 수 있으므로 무결성 유지 어려움높은 사용자와 낮은 사용자 간 자원 공유 시 기밀성 유지 훼손    보안 규칙     읽기 쓰기 읽기/쓰기     상급 보안 계층 X O X   할당된 보안 계층 O O O   하급 보안 계층 O X X     단순 보안 속성: 상향 읽기 X / 하향 읽기 O 성형 보안 속성: 상향 쓰기 O / 하향 쓰기 X 특수 성형 속성: 동일 레벨에서만 읽기/쓰기 가능  비바 무결성 모델(Biba Integrity Model) BLP를 보완한 무결성 모델(MAC)\n 무결성의 목표 중 비인가자에 의한 부적절한 변조방지만을 목적으로 함  보안 규칙\n    읽기 쓰기 읽기/쓰기     상급 보안 계층 O X X   할당된 보안 계층 O O O   하급 보안 계층 X O O     단순 무결성 속성: 상향 읽기 O / 하향 읽기 X 무결성 제한: 상향 쓰기 X / 하향 쓰기 O 호출 속성: 높은 무결성을 가진 주체에게 서비스 요청 X  클락-윌슨 무결성 모델(Clark-Wilson Integrity Model) 조금 더 정교하고 실제적인 무결성 모델\n 무결성의 3가지 목표 제공  비인가자 수정 방지 내/외부 일치성 유지 인가자의 불법적인 수정 방지   사용자는 프로그램을 통해서만 객체에 접근 상업용  만리장성 모델(Chinese Wall Model) 정보 흐름 모델을 기반으로 주체와 객체 사이에서 이해 충돌을 야기하는 방식으로 정보가 흐르지 않도록 함\n 사용자의 이전 동작에 따라 변화할 수 있는 접근 통제(MAC, DAC) 자유 재량과 강제적 접근 개념 모두 이용 이해 충동을 방지하기 위해 만리장성이라는 벽 사용  임의적 접근통제(DAC, Discretionary Access Control) 주체가 속해있는 그룹의 신원에 근거하여 객체에 대한 접근을 제한하는 방법\n 객체의 소유자가 접근여부를 결정한다. (분산형 보안관리) 하나의 주체마다 객체에 대한 접근 권한을 부여해야 함   대부분 운영시스템은 이를 기반으로 함\n    장점 단점     객체별 세분화된 접근 제어특정 주체가 다른 주체에게 임의적인 접근 제어 가능유연한 접근 제어 서비스 시스템 전체 차원의 일관성 있는 접근제어 부족멀웨어, 바이러스, 웜, 루트 킷, 트로이 목마 등에 취약    접근 제어 행렬(Access Control Matrix) 주체를 행, 객체를 열로 구성하고 해당 셀에 주체가 객체에 수행할 수 있는 접근 권한을 기록하여 관리\n 효과적인 권한 부여 정책을 정의 가능하지만 주체와 객체의 수가 많아질 경우 행렬의 크기가 커져 관리가 어려움 비어 있는 셀이 많아지므로 공간적으로 비효율적  자격 목록(Capability List, Capability Tickets) 한 주체가 갖는 자격들의 리스트\n 콘텐츠의 보안성이 보장받지 못하는 분산환경에서 사용 커버로스가 자격목록의 한 예  접근제어 목록(ACLs, Access Control Lists) 객체의 관점에서 주체에게 권한을 부여\n역할기반 접근통제(RBAC, Role-Based Access Control) 주체와 객체 사이에 역할을 두어 역할에 따라 접근통제\n MAC와 DAC의 단점을 보완한 기법이다. 주체, 객체에 접근권한을 할당하는 것이 아닌 역할에 접근권한을 할당  장점  관리자에게 편리한 관리능력 제공 DAC에 비해 유연성은 떨어지나, 일관성 있는 접근제어가 용이 최소권한의 원칙, 직무분리의 원칙 충족 용이  ","excerpt":"강제적 접근통제(MAC, Mandatory Access Control) …","ref":"/til/security/access-control/security-model/","title":"Security Model"},{"body":" 대칭키 암호, 일방향 해시함수, MAC, 의사난수 생성기, 전자서명을 조합해 안전한 통신 수행 암호 스위트를 변경하여 강력한 알고리즘 사용 (특정 암호기술에 의존 X)   암호 스위트: SSL/TLS 암호화 통신에 사용할 암호 알고리즘\n 보안 서비스  기밀성  대칭키 암호화 알고리즘을 사용하여 제공 비밀키는 Handshake Protocol을 통해 생성   클라이언트와 서버 상호 인증  RSA 같은 비대칭키 암호 알고리즘 DSS와 같은 전자서명 알고리즘 X.509 공개키 인증서   무결성  해시 알고리즘을 사용해 MAC를 만들어 메시지에 포함시켜 제공    절차  지원 가능한 알고리즘 서로 교환 키 교환, 인증 대칭키 암호로 암호화하고 메시지 인증   메시지 인증 코드는 HMAC 해시 함수를 이용\n TLS 프로토콜 SSL 3.0을 기초로 인터넷 표준버전이 되도록 만든 IETF 표준\n TCP에 의존하는 프로토콜 응용계층과 전송계층 사이에서 동작   SSL은 현재 취약점이 발견되어 사용이 권장되지 않음\n TLS 구조 Record Protocol 데이터를 암호화하고 압축하여 안전하게 전송하는 프로토콜\n 데이터를 SSL에서 처리할 수 있는 단위로 단편화, 압축, MAC 계산, 암호화하여 TCP 단편으로 전송  Handshake Protocol  클라이언트-서버간 안전한 연결 수립을 위한 상호 인증 암호화 MAC 알고리즘 및 TLS Recode 내 데이터 보호를 위한 암호키 협상 구성 필드  유형(1byte)    유형 매개변수     hello-request null   client- hello 버전, 랜덤, 세션 id, 암호도구, 압축방법   server-hello 버전, 랜덤, 세션 id, 암호도구, 압축방법   certificate 연속된 X.509v3 인증서   server_key_exchange 매개변수, 서명   certificat_request 유형, 기관   server_hello_done null   certificate_verify 서명   client_key_exchange 매개변수, 서명   finished 해시값     길이(3byte) 내용(0byte 이상)    초기협상 단계 클라이언트와 서버는 SSL 버전, 키교환/메시지인증/암호화를 위한 알고리즘, 압축 방법, 난수 등을 수집\n Hello_Request: 서버가 클라이언트에게 협상의 시작을 요구 Client_Hello: 클라이언트가 서버에 연결을 시작하거나 HelloRequest 메시지에 대해 응답 Server_Hello: Client_Hello 메시지에 대한 응답  서버 인증 단계 서버는 인증서와 키 교환 전송 후 인증서를 요청, hello 메시지 종료 시그널 전송\n Certificate: 선택된 cipher suite의 키 교환 알고리즘에 맞는 서버의 인증서를 보냄 Server_Key_Exchange: 인증서를 보내지 않았거나, 보낸 인증서에 정보가 부족할 때 전송 Certificate_Request: 클라이언트의 인증서를 요청, 상호 인증이 이루어짐(선택 사항) Server_Hello_Done: 서버가 메시지를 다 보냈다고 알리는 메시지  클라이언트 인증 단계 클라이언트는 요청이 있을 시 인증서, 키 교환, 인증서 확인 전송\n Certificate: 서버가 클라이언트의 인증을 요구할 경우 클라이언트가 보내는 메시지 Client_Key_Exchange: 세션키를 생성하기 위해 48bytes의 비밀 정보를 생성, 공개키 알고리즘을 사용하여 pre_master_secret를 서버와 공유 Certificate_Verify: 클라이언트 인증서의 명백한 확인을 위해 handshake 메시지를 전자서명하여 전송  종료 단계 암호 스위트 변경 후 handshake 프로토콜 종료\n Change_Cipher_Spec: 이 메시지 이후에 전송되는 메시지는 새롭게 협상된 알고리즘과 키를 이용할 것임을 나타냄. (Handshake 프로토콜에 포함되지 않음) Finished: 협상된 알고리즘과 키가 처음으로 적용, 이후 데이터 전송이 시작됨  ChangeCipherSpec Protocol  종단 간 협상된 보안 파라미터를 이후부터 적용/변경함을 알리기 위해 사용 1 바이트 메시지  Alert Protocol  통신 과정에서 발생하는 오류를 통보하기 위해 경고 할 때 사용 구성 필드(2바이트)  첫번째 바이트: warning(1), fatal(2) 두번째 바이트: 세부 에러코드    Heartbeat Protocol  정상적으로 동작한다는걸 나타내기 위한 S/W나 S/W가 생성하는 주기적 신호 가용성을 모니터링 할 때 사용함  공격 및 보안대책 OpenSSL의 HeartBleed 취약점 heartbeat 프로토콜의 확장이라는 기능에 요구 데이터 길이에 대한 점검 결여로 인해 메모리상 관계없는 정보까지 상대방에게 넘어가 버리는 공격\n 공격자는 heartbleed 공격으로 서버의 정보를 일정범위까지 훔칠 수 있음\n 보안대책  취약성 대책이 실행된 버전으로 OpenSSL 갱신 heartbeat 확장 사용을 하지 않는 옵션으로 재컴파일  POODLE 공격 공격자가 TLS를 SSL 3.0으로 다운그레이드한 통신을 강요하여 MITM(중간자 공격)을 통해 암호화되어 송ㆍ수신되는 쿠키정보, 데이터를 추출하는 공격\n보안대책  브라우저 상에서 SSL 3.0의 비활성화  FREAK 공격 SSL/TLS 서버가 RSA Export Suites라고 불리는 약한 암호 스위트를 사용하게 만드는 공격\n보안대책  OpenSSL 최신버전 업그레이드 OS 및 브라우저 업그레이드  ","excerpt":" 대칭키 암호, 일방향 해시함수, MAC, 의사난수 생성기, …","ref":"/til/security/application/ssl-and-tsl/","title":"SSL/TLS"},{"body":"","excerpt":"","ref":"/til/security/system/","title":"System"},{"body":"버퍼 오버플로우 공격 버퍼 또는 데이터 저장 공간보다 더 많은 입력이 위치하면 다른 위치의 정보를 변경할 수 있음을 이용한 공격\n스택 버퍼 오버플로우 스택에 정해진 버퍼보다 큰 공격 코드를 삽입해 반환주소를 변경함\n 공격 대상  SetUID가 설정된 루트 권한의 프로그램   공격 절차  공격 쉘 코드를 버퍼에 저장 특정 함수의 스택 반환주소를 공격 쉘 코드가 위치한 버퍼 주소로 변경 해당 함수가 호출되면 쉘 코드가 실행되고 루트 권한을 획득할 수 있음    힙 버퍼 오버플로우 힙에 할당된 공간이 함수에 대한 포인터를 포함하고 있는 경우, 공격자가 이 주소를 변경하여 겹쳐 쓴 버퍼에 있는 셸 코드를 가리키도록 할 수 있다.\n대응 방법 컴파일 시간 방어 컴파일할 때 검사하여 오버 플로우를 방지하거나 발견하는 방어 방법\n 고급 수준의 프로그래밍 언어 사용  Java, ADA, Python 같은 버퍼 오버플로우가 발생하지 않는 언어   안전한 함수 사용  입력 값을 검사하는 함수를 사용   안전한 라이브러리의 사용 스택 보호 메커니즘(Stack Guard)  함수의 진입과 종료 코드를 조사하여 함수의 스택 프레임에 대해 손상이 있는지 검사 프로그램 호출 시 복귀 주소(RET) 앞에 canary값 주입 후 종료 시 변경되었는지 확인   스택 쉴드(Stack Shield)  함수 시작 시 복귀 주소(RET)를 Global RET라는 특수 스택에 저장 함수 종료 시 저장된 값과 스택의 RET 값을 비교해 탐지    실행 시간 방어 재컴파일 없이 기존 프로그램에 대해 방어할 수 있는 방법\n 주소 공간의 임의 추출(ASLR, Address Space Layout Randomization)  스택을 임의적으로 배치하여 공격자가 실행 코드의 주소를 예측할 수 없게 함   실행가능 주소 공간의 보호(Non-Executable Stack)  스택과 힙 영역을 실행 불능으로 만드는 방법 /etc/system파일 설정  set noexec_user_stack=1 set noexec_user_stack_log=1      포맷 스트링 공격 포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격\n위협 요소  프로그램의 파괴  프로세스를 죽게 만들어 다른 공격을 수월하게 만듬   프로세스 메모리 보기  시스템 내의 유용한 정보를 수집   임의의 메모리 덮어쓰기  어떤 프로세스의 명령 통제권을 장악할 수 있다.    대응 방법  데이터 형식에 대한 명확한 정의 취약점 점검 도구 사용  gdb, ltrace, objdump    레이스 컨디션 공격 둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때 접근하는 순서에 따라 비정상적인 결과가 발생하는 조건/상황\n 실행되는 프로세스가 임시파일을 만드는 경우, 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 목적파일로 연결(심볼릭 링크)하여 악의적인 행위를 할 수 있다.\n  레이스 컨디션 공격의 대상  소유자가 root, SetUID 비트 설정, 임시파일을 생성하는 파일   생성되는 임시 파일의 이름을 알고 있어야 함  lsof 명령어로 확인    대응 방법  임시파일에 접근하기 전에 임시파일에 대한 심볼릭 링크 설정 여부와 권한에 대한 검사 과정 추가 가능하면 임시파일을 생성하지 않는다. umask를 최소 022 정도로 유지(755퍼미션)  백도어 OS나 프로그램 등에 접근할 때 정상적인 인증 과정을 거치지 않도록 하는 통로\n 서비스 기술자나 유지보수 프로그래머의 접근 편의를 위해서 시스템 설계자가 고의적으로 만듬 백 오리피스(back orifice) = 악의적인 백도어  사용자 몰래 사용자 정보를 저장, 유출하기 위한 백도어 프로그램    대응 방법  프로세스 목록 확인 H-IDS 사용하여 탐지  시스템 자원 고갈 공격 시스템이 보유하고 있는 자원을 모두 선점하거나 모두 고갈하는 방식으로 수행된다.\n 서비스 거부 공격(DOS)라고도 부름\n 가용 디스크 자원 고갈 공격 #include\u003cunistd.h\u003e#include\u003csys/file.h\u003e void main(){ int fd; char buf[1000]; fd = creat(\"/root/termifile\" ,0777); while(1){ write(fd,buf,sizeof(buf); // tempfile 계속 써서 → 디스크 용량 고갈  } } 가용 메모리 자원 고갈 공격 #include\u003cstdio.h\u003e void main(){ char *m; // 포인터 변수  while(1){ m = malloc(1000); // 동적 할당 → 힙 메모리 고갈  } } 가용 프로세스 자원 고갈 공격 #include\u003cunistd.h\u003e void main(){ while(1){ fork(); // 프로세스 반복 복제 → 가용 프로세스 고갈  return 0; } } 프로세스 죽이기 공격 root 권한을 획득한 상태에서 스크립트를 통해 프로세스를 죽이는 기법\n#!/bin/sh sync kill -15 1 리버스 엔지니어링 공격 리버스 엔지니어링 과정에서 발견한 취약점으로 공격 코드를 생성\n 리버스 엔지니어링(역공학): 장치나 시스템의 구조를 분석하여 원리를 발견하는 과정\n 대응 방법  소스코드 난독화 바이너리 난독화  그 외 루트킷(Rootkit) 공격자가 언제든지 시스템 root 권한으로 접근할 수 있도록 비밀통로를 지속적으로 유지시켜주는 프로그램\n 시스템 변형을 통해서 자신을 숨기므로 탐지하기 어려움  GNU Bash 취약점(ShellShock) 취약한 버전의 bash는 환경변수의 함수 선언문 뒤에 임의의 명령어를 삽입할 경우, 환경변수에 설정된 함수 선언의 끝을 인지하지 못하고 삽입한 명령어까지 실행하는 취약점\n논리폭탄(logic bomb) 특정한 사건이 발생할 때 프로그램이나 일련의 코드를 실행하는 것\n","excerpt":"버퍼 오버플로우 공격 버퍼 또는 데이터 저장 공간보다 더 많은 입력이 위치하면 다른 위치의 정보를 변경할 수 있음을 이용한 공 …","ref":"/til/security/system/system-threats/","title":"System Threats"},{"body":"기존 WSL1의 문제점  WSL(Windows Subsystem for Linux)은 기존 Windows의 단점이던 개발환경을 획기적으로 개선 다만 기존 WSL1은 시스템 콜 에뮬레이션 방식으로 구동되기 때문에 성능저하가 존재   리눅스 시스템 콜을 윈도우 시스템 콜로 번역하여 윈도우NT 커널에서 이를 처리\n WSL2, 무엇이 달라졌나?  WSL2는 기존 WSL1의 문제를 개선하기 위해 리눅스 커널을 그대로 탑재하였다. 이를 통해서 기존에 문제시 되던 I/O성능과 시스템 호출 호환성이 개선이 이루어졌다.   실제 리눅스 커널은 경량화된 하이퍼-V 가상화 기술을 통해 구동된다.\n WSL2 업그레이드 방법 사전 준비  2004 이상 버전의 윈도우 10  설정 \u003e 시스템 \u003e 정보 \u003e 버전   WSL1의 설치  설치가 되어 있지 않다면 해당 페이지를 참고   WSL2 Lunix 커널 업데이트 패키지 설치  1. Virtual Machine Platform 활성화 WSL2는 Virtual Machine Platform을 기반으로 동작하기 때문에 이를 활성화시켜 주어야 한다.\n PowerShell을 우선 관리자권한으로 실행 아래 명령어 실행 Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform    Hyper-V가 Windows 10 Home에는 설치되지 않으므로 Pro버전으로 업그레이드 해야 할 수도 있다.\n 2. 업그레이드 적용 사용중인 리눅스 배포판 목록 조회 wsl -l -v 기존 배포판 WSL2 전환 wsl --set-version \u003cdistro\u003e 2  WSL2로 전환할 리눅스 배포판의 이름을 잘 기억해뒀다가 대신 작성해주면 된다.\n WSL2를 디폴트로 설정 이후 설치하는 리눅스 배포판을 WSL2로 적용하길 원한다면 다음 명령어를 입력하면 된다.\nwsl --set-default-version 2 ","excerpt":"기존 WSL1의 문제점  WSL(Windows Subsystem for Linux)은 기존 Windows …","ref":"/til/wsl/upgrade-to-wsl2/","title":"Upgrade to WSL2"},{"body":"DHCP(Dynamic Host Configuration Protocol) 네임 서버 주소, IP주소, 서브넷 마스크, 게이트웨이 주소 등을 자동으로 할당해주는 프로토콜\n 동적 설정 프로토콜 UDP 기반 프로토콜  이전 프로토콜 RARP 호스트의 MAC주소를 통해 RARP 서버에서 IP 주소를 매핑하여 호스트에게 전달\n 단점  IP 주소만을 제공 서브넷마다 브로드캐스트 방식 필요    BOOTP RARP의 약점 2가지를 극복하기 위해 만든 클라이언트-서버 프로그램\n DHCP와 상호호환  패킷 구조가 거의 동일   정적인 프로토콜  고정된 IP 주소와의 바인딩만 가능    동작 원리  DHCP Discover: DHCP서버가 있는지 확인을 위한 메시지 생성  출발지 IP: 0.0.0.0, 목적지 IP: 255.255.255.255   DHCP Offer: DHCP에서 PC에게 줄 수 있는 IP주소 리스트를 제공 DHCP Request: 리스트중 IP 하나를 선택하여 제공을 요청 DHCP Ack : IP 및 네트워크 정보를 할당해주고 임대 기간 전달  장단점    장점 단점     N/W 설계 변경이 자유로움 DHCP 클라이언트는 부팅시 브로드캐스트 방식으로 트래픽 전송 (N/S 성능저하)   DHCP 서버에서만 N/W 정보 변경하면 되기 때문에 N/W 구성변경 용이 호스트 전원이 켜 있는 것 만으로 IP 할당됨   실제로 호스트가 사용중일 때만 IP 할당하기 때문에 IP 절약 가능 호스트 전원을 꺼도 임대기간까지 해당 IP는 다른 단말에 할당 X (IP주소 낭비)   사용자가 TCP/IP를 따로 설정할 필요가 없음 호스트 수가 많아지면 서버의 과부하 발생    Starvation 공격  공격자가 DHCP 서버의 할당 가능한 IP를 모두 소진하게 하여 IP할당이 불가능하게 하는 공격 공격자는 DHCPDISCOVER msg를 서로다른 MAC주소로 DHCP에 보내고 서버로부터 OFFER가 오면 REQUEST까지만 하고 실제로 주소는 할당하지 않음  DNS(Domain Name Server) 도메인 네임을 IP 주소로 변환해주는 시스템\n zone 파일: 개별 도메인에 대한 DNS 정보가 설정되어 있는 파일  구성 요소  루트 서버  전체 트리 영역을 가지는 서버 도메인에 대한 정보를 갖지 않으며, 다른 서버들에 대한 참조만 함   1차 서버(Primary Server)  자신이 권한을 가지는 zone에 대한 파일을 가짐 파일에 대한 생성/관리/갱신의 책임을 가지며 로컬 디스크에 저장   2차 서버(Secondary Server)  영역파일을 생성하지 않으며 갱신하지도 않음   존 전송(Zone Transfer)  마스터에 있는 원본 존 DATA를 슬레이브가 동기화하는 작업(TCP/53)    동작 방식  재귀적(Recursive) 해석  클라이언트가 네임 서버에게 재귀적 요청 서버는 정보가 있는 경우 해당 정보로 응답 없는 경우 다른 서버(부모 서버)에게 새로운 재귀적 요청을 보내어 응답   반복적(Iterative) 해석  클라이언트가 네임 서버에게 반복적 요청 서버는 정보가 있는 경우 해당 정보로 응답 없는 경우 그 정보에 좀 더 가까운 다른 서버의 네임으로 응답    질의 순서  캐시  주소 해석 속도를 높이기 위해 사용 네거티브 캐싱: 너무 오래동안 캐싱정보를 가지고 있으면 정보가 잘못될 수 있음  이 경우 잘못된 매핑 정보를 보냄     hosts 파일  /etc/hosts 도메인/호스트명과 IP주소 매핑정보를 담고있는 파일 네임 서버에 질의되기 전 참조되는 파일   로컬 DNS 서버  Recursive DNS 서버  동일한 작업을 조건이 만족할 때 까지 반복적으로 처리   Authoritative DNS 서버  권한이 있는 네임서버 특정 도메인에 대한 정보를 관리, 해당 도메인에 대한 질의만 응답      DNS 스푸핑 스니핑 공격 대상이 DNS 질의를 수행하면 공격자가 스니핑을 하고 있다가 정상 응답보다 빠르게 희생자에게 조작된 웹 사이트 정보를 담은 DNS 응답을 보내 조작된 주소로 접속하게 만드는 공격\n UDP의 특징 중 먼저 수신한 응답을 제외한 나머지 응답은 모두 버린다는 특징을 이용  보안대책  스니핑 탐지 및 차단 중요한 사이트 IP주소는 hosts파일을 사용  캐시 포이즈닝 DNS 서버의 캐시정보를 조작하는 공격\n공격 절차  공격 대상 DNS 서버(Recursive DNS Server)에 조작할 도메인 질의를 다수 전송  DNS 서버가 질의에 사용하는 Transaction ID와 출발지 Port 랜덤으로 생성   조작된 응답 중 정상 응답보다 먼저 Transaction ID와 출발지 Port가 일치한 응답이 있으면 조작된 주소 정보가 공격 대상 DNS 서버의 캐시에 저장됨  보안대책  소프트웨어 최신 버전 상태 유지 도메인 관리용 DNS 서버는 재귀적 질의를 허용하지 않음 DNSSEC 기술을 활용  ","excerpt":"DHCP(Dynamic Host Configuration Protocol) 네임 서버 주소, IP주소, 서브넷 마스크, 게이트 …","ref":"/til/security/application/dhcp-and-dns/","title":"DHCP/DNS"},{"body":"자바스트립트 코드는 브라우저로부터 3가지 유형의 객체를 제공받아 활용한다.\n BOM 객체 코어 객체 DOM(Document Object Model) 객체  HTML DOM  웹 페이지에 작성된 HTML 태그 당 객체 생성 목적: HTML 태그가 출력된 모양이나 콘텐츠를 제어하기 위해서  DOM 객체를 통해 각 태그의 CSS3 스타일 시트 접근 및 변경 HTML 태그에 의해 출력된 텍스트나 이미지 변경   DOM 트리  HTML 태그의 포함관계에 따라 DOM 객체의 트리 생성 DOM 트리는 부모 자식 관계   DOM 객체  DOM 트리의 한 노드 HTML 태그 당 하나의 DOM 객체 생성  \u003cp\u003e는 p객체로, \u003cdiv\u003e는 div p객체로 DOM 노드, DOM element로 불림      DOM 트리  브라우저는 HTML 페이지를 로드하면서, HTML 태그의 포함관계에 따라 DOM 객체들을 트리 구조로 만듦  window 객체는 BOM과 DOM을 포함하여 전체 객체의 최상위 document 객체는 window 객체의 자식이면서 DOM 객체의 최상위   자바스크립트 코드는 DOM 트리를 따라 DOM 객체들을 마음대로 접근할 수 있다.  DOM 트리의 특징  DOM 트리의 루트는 document 객체 DOM 객체의 종류는 HTML 태그 종류만큼 HTML 태그 당 DOM 객체가 하나씩 생성 , 이름은 태그와 같음 HTML 태그의 포함관계에 따라 DOM 트리에 부모 자식 관계  브라우저가 HTML 태그를 화면에 그리는 과정  브라우저가 DOM 트리의 틀(document 객체) 생성 브라우저가 HTML 태그를 읽고 DOM 트리에 DOM 객체 생성 브라우저는 DOM 객체를 화면에 출력 HTML 문서 로딩이 완료되면 DOM 트리 완성 DOM 객체 변경 시, 브라우저는 해당 HTML 태그의 출력 모양을 바로 갱신  DOM 객체 구성 요소  프로퍼티(property)  HTML 태그의 속성(attribute) 반영   메소드(method)  DOM 객체의 멤버 함수로서, HTML 태그 제어 가능   컬렉션(collection)  자식 DOM 객체들의 주소를 가지는 등 배열과 비슷한 집합적 정보 예: children 컬렉션 – DOM 객체의 모든 자식 DOM 객체에 대한 주소 가짐   이벤트 리스너(event listener)  HTML 태그에 작성된 이벤트 리스너 반영 약 70여 개의 이벤트 리스너를 가질 수 있음   CSS3 스타일  HTML 태그에 설정된 CSS3 스타일 시트 정보를 반영 DOM 객체의 style 프로퍼티를 통해 HTML 태그의 모양 제어 가능    DOM 객체 프로퍼티 DOM 객체들은 DOM 트리에서 부모, 자식, 형제의 관계로 연결\n parentElement 프로퍼티 – 부모객체 children 프로퍼티 – 직계 자식들의 컬렉션 firstElementChild 프로퍼티 – 첫 번째 직계 자식 lastElementChild 프로퍼티 – 마지막 직계 자식  Sibling이란 DOM 트리에서 동일한 레벨에 있는 모든 사촌 및 형제 DOM 객체를 지칭\n 다른 부모의 자식이어도 같은 레벨이면 sibling\n Sibling 관계에 있는 DOM 객체들은 다음 2개의 프로퍼티로 접근\n previousElementSibling 프로퍼티 – 이전 sibling 객체 nextElementSibling 프로퍼티 – 이후 sibling 객체  DOM 객체 다루기 getElementById document.getElementById()\n DOM 객체 구분 \u003cp id=\"hi\"\u003e안녕하세요\u003c/p\u003e  DOM 객체 찾기 document.getElementById(\"hi\") // id 값이 hi인 DOM 객체 리턴  DOM 객체 스타일 변경  style 객체 사용  var span = document.getElementById(\"mySpan\"); // id가 mySpan인 객체 찾기 span.style.color = \"green\"; // ‘문장입니다’의 글자 색을 green으로 변경 span.style.fontSize = \"30px\"; // ‘문장입니다’의 폰트를 30px 크기로 변경 span.style.border = \"3px dotted magenta\"; // 3픽셀의 magenta 점선 테두리   getElementByTagName document.getElementsByTagName() 태그 이름이 같은 모든 DOM 객체들을 찾아 컬렉션 리턴\nfunction change() { var spanArray = document.getElementsByTagName(\"span\"); for(var i=0; i\u003cspanArray.length; i++) { var span = spanArray[i]; span.style.color = \"orchid\"; span.style.fontSize = \"20px\"; } } getElementByClassName document.getElementsByClassName() class 속성이 같은 모든 DOM 객체들을 찾아 컬렉션 리턴\ninnerHTML 프로퍼티 시작 태그와 종료 태그 사이에 들어 있는 HTML 콘텐츠를 다룸\n innerHTML 프로퍼티 수정 -\u003e HTML 태그의 콘텐츠 변경\n \u003cscript\u003e function change() { var p = document.getElementById(\"firstP\"); p.innerHTML= \"나의 \u003cimg src='puppy.png'\u003e 강아지\"; } \u003c/script\u003e \u003cp id=\"firstP\" style=\"color:blue\" onclick=\"change()\"\u003e 여기에\u003cspan style=\"color:red\"\u003e클릭하세요\u003c/span\u003e \u003c/p\u003e this 객체 자신을 가리키는 자바스크립트 키워드\n DOM 객체에서 객체 자신을 가리키는 용도로 사용\n \u003cdiv onclick=\"this.style.backgroundColor='orange'\"\u003e Document 객체 HTML 문서 전체를 대변하는 객체이자 DOM 객체를 접근하는 경로의 시작점\n HTML 문서 로드 전, Document 객체를 생성하고 DOM 트리 생성\n  프로퍼티: HTML 문서의 전반적인 속성 내포 메소드: DOM 객체 검색, DOM 객체 생성, HTML 문서 전반적 제어 컬렉션: HTML 태그들을 배열처럼 접근할 수 있는 컬렉션을 둠  Document 객체 접근  window.document 또는 document 이름으로 접근 document 객체는 DOM 객체가 아님  write() and writeln()  write()  현재 document 객체에 담긴 HTML 콘텐츠 마지막에 HTML 텍스트를 추가 추가되는 HTML 텍스트는 DOM 객체로 바뀌고 DOM 트리에 추가 삽입된 HTML 텍스트가 브라우저 화면에 출력   writeln()  HTML 텍스트에 \\n을 덧붙여 출력. 한 칸 띄는 효과    open() and close()  open()  현재 브라우저에 출력된 HTML 콘텐츠를 지우고 새로운 HTML 페이지 시작. 즉 document 객체에 담긴 DOM 트리를 지우고 새로 시작   close()  현재 브라우저에 출력된 HTML 페이지 완성 더 이상 document.write() 할 수 없음    // 현재 HTML 페이지의 내용을 지우고 다시 시작 document.open(); document.write(“\u003chtml\u003e\u003chead\u003e...\u003cbody\u003e안녕하세요.”); document.write(“.......”); document.write(“\u003c/body\u003e\u003c/html\u003e”); document.close(); 문서의 동적 구성 DOM 객체 동적 생성 var newDIV = document.createElement(\"div\"); newDIV.innerHTML = \"새로 생성된 DIV입니다.\"; newDIV.setAttribute(\"id\", \"myDiv\"); newDIV.style.backgroundColor = \"yellow\"; DOM 트리에 삽입 var p = document.getElementById(\"p\"); p.appendChild(newDiv); DOM 객체의 삭제 var myDiv = document.getElementById(\"myDiv\"); var parent = myDiv.parentElement; parent.removeChild(myDiv); // 부모에서 myDiv 객체 삭제 ","excerpt":"자바스트립트 코드는 브라우저로부터 3가지 유형의 객체를 제공받아 활용한다.\n BOM 객체 코어 객체 DOM(Document …","ref":"/til/javascript/dom/","title":"Document Obeject Model"},{"body":"권한 및 그룹 소유권과 허가권  소유권: 파일이나 디렉토리를 소유하여 지배하는 권리  사용자 소유권 그룹 소유권   허가권: 파일이나 디렉토리에 접근 권한을 설정하는 권한  사용자(user) 그룹(group) 이외(other)    허가권의 표기    권한 파일 디렉토리     r 파일의 내용 열람 디렉토리 내부 열람   w 파일의 내용 수정 디렉토리 내부 파일 생성 혹은 삭제   x 실행 파일을 실행 디렉토리 내부로 접근    권한 관련 명령어 chmod 파일이나 디렉토리 접근 허가권 설정 (change mode)\n 사용자 지정: u, g, o, a 권한 지정: r(4), w(2), x(1) 설정 기호: +, -, =\n chown 파일이나 디렉토리의 소유권 및 그룹 소유권 변경(change owner)\nchgrp 파일이나 디렉토리의 소유 그룹 변경(change group)\n 본인이 속한 그룹이 여러개인 경우 본인 소유 파일을 자신이 속한 다른 그룹으로 이동할 수 있다.\n $ chmod [option] mode file $ chown [option] owner[:group] file $ chgrp [option] group file 주요 옵션\n   옵션 내용     -R 하위 모든 디렉터리, 파일 접근 권한 변경   -c 변경된 정보 출력   -f 중요한 오류 메시지가 아니면 출력 X   -v 명령 진행 결과에 대한 정보를 자세히 출력   –version 명령어의 버전 정보 출력    chgrp 옵션\n   옵션 내용     -h 심볼릭 링크 파일 자체의 그룹 소유권 변경    umask 파일이나 디렉터리 생성 시 부여되는 기본 허가권 값 지정\n$ umask [option] value 주요 옵션\n   옵션 내용     -S umask 값을 문자로 표기    특수 권한 일반 사용자가 root 권한을 잠시 사용하는 것\n종류  Set-UID  보통 실행파일에 사용됨 실행하는 동안 해당 파일의 소유자 권한을 빌림 소유자 권한 부분의 x자리에 s로 표기됨 만약 실행 권한이 없는 파일에서 사용하면 S로 표기됨   Set GID  해당 파일을 소유한 그룹 권한으로 인식 주로 디렉토리에 설정됨 그룹 소유권 부분에서 x자리에 s로 나타남 실행 권한이 없는 경우 S로 표기됨   Sticky-Bit  공유 디렉터리로 사용 /tmp에 기본 설정 일반 사용자가 자신이 만든 파일만 삭제할 수 있게 함 사용자 권한 부분의 x자리에 t로 표기 실행 권한이 없는 경우 T로 표기    설정  chmod를 사용하여 허가권을 설정 숫자 모드나 문자 모드로 설정 문자모드에서 Set-UID나 Set-GID는 s로 Sticky-Bit은 t로 표기 숫자모드로는 4, 2, 1 값으로 지정  파일 시스템 파일 관련 명령어 mount 보조기억장치나 파일 시스템이 다른 디스크를 /의 하위 디렉토리로 연결하는 명령어\numount 마운트된 파일 시스템을 해제시키는 명령\n$ mount [option] [device] [directory] $ umount [option] [device or directory_name] 주요 옵션\n   옵션 내용     -a /etc/fstab에 명시된 파일 시스템을 (언)마운트할 때   -t fs_type 파일 시스템의 유형 지정, 안할 경우 etc/fstab 파일을 참조   -o 항목 추가 설정    파일 시스템 유형\n   유형 내용     msdos FAT-16   vfat FAT-32   ntfs 윈도우 파일 시스템   ext2, ext3, ext4 리눅스 시스템   iso9660 CD-ROM이나 DVD   nfs 네트워크 파일 시스템    -o 주요 항목\n   유형 내용     ro 읽기 전용   rw 읽기/쓰기(기본값)   remount 리마운트   loop iso를 마운트할 때   acl ext3 접근제어리스트를 사용    eject CD-ROM이나 DVD에서 미디어를 제거할 때 사용\n$ eject [device or directory_name] fdisk 디스크 파티션 확인/추가/삭제\n$ fdisk [option] [device] 주요 옵션\n   옵션 내용     -l 현재 디스크의 파티션 리스트   -s partition 특정 파티션 크기 출력(단위: block)   -v fdisk 버전 출력    주요 명령\n   명령 내용     p 현재 디스크 정보 출력   d 파티션 삭제   n 파티션 생성   t 파티션 속성 변경   w 변경된 파티션 정보 저장하고 종료   q 변경된 파티션 정보 저장하지 않고 종료    mkfs 새로운 파일 시스템 생성하는 명령어 (make filesystem)\n root만 사용 가능, 기본 생성 유형은 ext2\n $ mkfs [-t fs_type] [option] device 주요 옵션\n   옵션 내용     -t fs_type 파일 시스템 유형 지정   -c 배드 블록 체크 후 파일 시스템 구축   -v 결과를 상세히 출력    mke2fs ext2, ext3, ext4 파일 시스템을 만드는 명령으로 최근 리눅스에서 mkfs 명령 시 사용됨.\n 별도 지정 없을 시 ext2로 생성\n $ mke2fs [option] device 주요 옵션\n   옵션 내용     -j 저널링 파일 시스템인 ext3로 생성   -t fs_type 파일 시스템 유형 지정   -b block_size 블록 사이즈 지정   -R raid_options RAID관련 옵션으로 argument=값 형태로 지정    fsck 리눅스 파일 시스템을 검사하고 수리(filesystem check)\n 임시로 /lost+found 디렉토리에서 작업을 수행한다.\n e2fsck ext2, ext3, ext4를 검사하고 수리하는 명령으로, 현재 리눅스 배포판에서 fsck를 사용하면 실행된다.\n$ fsck [option] device $ e2fsck [option] device e2fsck 옵션\n   옵션 내용     -n 특정 상황에 대한 물음에 ‘no’라 인식시켜 처리   -y 특정 상황에 대한 물음에 ‘yes’라 인식시켜 처리   -c 배드 블록을 체크   -f 깨끗한 파일 시스템까지 강제 체크    df disk free 현재 마운트된 디스크 크기, 사용량, 남아 있는 용량 등에 대한 정보 출력\ndu disk usage 파일이나 디렉토리들이 디스크에서 차지하는 크기를 출력\n$ df [option] $ du [option] [file] 주요 옵션\n   옵션 내용     -h 용량의 단위 표시   -k KB단위로 표시   -m MB단위로 표시   -T 파티션 유형 표기(df)   -a 디렉터리 상에 모든 파일 크기 표시(du)   -s 파일들의 전체크기를 합한 값만 표시(du)    fstab  파일 시스템에 대한 다양한 정보를 담고 있는 파일 부팅 시 마운트할 파티션 정보가 기록되어 있음 mount, umount, fsck 등의 명령어가 수행될 때 이 파일의 정보를 참조  필드    필드 내용     1 장치명   2 마운트 디렉토리   3 파일 시스템 유형   4 마운트 옵션   5 dump로 백업 시 레벨덤프 사용주기 결정   6 fsck 명령의 순서를 정함    디스크 쿼터 사용자나 그룹별로 사용할 수 있는 디스크 사용량과 파일 생성 개수(I-node)를 제한할 수 있다.\n디스크 쿼터 명령어 quotacheck 디스크를 사용하는 파일 시스템을 체크, quota 기록 파일을 가장 최근의 상태로 업데이트 시키는 명령어\n$ quotacheck [option] directory_name 주요 옵션\n   옵션 내용     -a 사용자와 그룹에 대한 쿼터를 체크   -m 마운트를 하지 못할 때 강제로 체크   -f 쿼터 파일 초기 생성 후 인식 안되는 경우 강제로 인식   -u 사용자 쿼터 파일 체크   -g 그룹 쿼터 파일 체크   -c 기존 쿼터 관련 파일을 읽지 않고 새롭게 초기화    edquota 사용자나 그룹에 쿼터를 설정할 떄 사용, 기본 단위는 KB\n$ edquota [option] 주요 옵션\n   옵션 내용     -u 사용자에 대한 쿼터 설정   -g 그룹에 대한 쿼터 설정   -t Soft limit을 초과한 후부터 적용되는 시간제한 설정   -p 특정 사용자 쿼터를 다른 사용자에게 동일한 설정으로 적용    quotaon/off 쿼터 설정을 활성화/비활성화\n$ quotaon [option] directory_name $ quotaoff [option] directory_name 주요 옵션\n   옵션 내용     -u 사용자 쿼터 활성화   -g 그룹 쿼터 활성화   -v 메시지 자세히 출력    repquota 파일 시스템 단위로 쿼터 설정 정보를 출력\n$ repquota [option] [directory_name] 주요 옵션\n   옵션 내용     -a 쿼터가 설정되어 있는 모든 파티션 정보 출력   -u 사용자 쿼터 정보 출력   -g 그룹 쿼터 정보 출력    quota 사용자 단위로 쿼터 설정 정보를 출력\n$ quota 주요 옵션\n   옵션 내용     -u 사용자 쿼터 정보 출력   -g 그룹 쿼터 정보 출력    setquota vi편집기를 이용하지 않고 명령행에서 쿼터 설정\n$ setquota [option] user block_soft block_hard inode_soft inode_hard $ setquota -t block_grace inode_grace filesystem 주요 옵션\n   옵션 내용     -u 사용자 쿼터 설정   -g 그룹 쿼터 설정   -t 유예기간을 설정    ","excerpt":"권한 및 그룹 소유권과 허가권  소유권: 파일이나 디렉토리를 소유하여 지배하는 권리  사용자 소유권 그룹 소유권   허가권:  …","ref":"/til/linux/linux-master/file-system-commands/","title":"File System Commands"},{"body":"해시함수는 데이터의 무결성을 보장하지만 발신자의 신원 확인이 불가능하다. 이러한 문제를 해결하기 위해 인증 절차를 추가한 것이 메시지 인증 코드(MAC)이다.\n개념 변경 감지 코드(MDC) 변경 감지 코드(MDC, Modification Detection Code)는 메시지의 무결성을 보장하는 다이제스트이다.\n인증 과정  Alice는 안전하지 않은 채널로 메시지 M을 Bob에게 전송 Hash(M)으로 도출한 해시값 MDC를 안전한 채널로 전송 Bob은 수신한 메시지를 해시 알고리즘을 통해 해시값 MDC' 도출 Bob은 안전한 채널로 수신한 해시값 MDC과 계산한 해시값 MDC'를 비교 동일하다면 전달받은 메시지의 무결성이 입증됨  문제점  안전한 채널이 보장됨이 전제임 만약 해당 채널이 탈취된다면 메시지와 MDC 모두 위조될 수 있음  메시지 인증 코드(MAC) 송ㆍ수신자 간 비밀키를 공유하는 것으로 안전한 채널이 확보되지 않아도 무결성과 전송자의 신원 인증을 가능하게 하는 방법\n인증 과정  원본 메시지 M을 비밀키 K와 병합하여 해시 수행 여기서 만들어진 MAC과 메시지 M을 안전하지 않은 채널로 전송 Bob은 수신한 메시지 M과 비밀키 K로 MAC'을 생성 수신한 MAC과 자신이 생성한 MAC'을 비교 동일하다면 전달받은 메시지의 무결성이 입증됨과 동시에 출원지가 Alice라 판단  문제점  송ㆍ수신자 간 비밀키를 공유해야 함 따라서 키 배송 문제가 발생  종류 Nested MAC MAC의 안전성을 높이기 위해 고안된 방법\n 동일한 해시함수로 두 단계 해시 과정을 거침 따라서 두 개의 키가 존재  HMAC NIST는 Nested MAC에 관한 표준인 FIPS 198을 제정\n Nested MAC에 패딩 요소 추가 SHA1과 같은 일방향 해시함수 사용  생성 과정  메시지를 길이가 b비트인 N개의 블록으로 분리 비밀키 왼쪽에 0으로 된 열을 추가하여 b비트로 길이를 맞춤  이때 패딩 이전의 비밀키 길이는 N비트 이상을 권장   이렇게 생성된 비밀키를 ipad(Input pad) 상수와 XOR 연산 결과값을 N블록들 앞에 위치시켜 N+1개의 블록으로 만듦 블록을 해시함수에 대입하여 얻은 결과를 HMAC이라 한다 n비트의 HMAC 왼쪽에 0을 패딩하여 b비트로 만듦 ipad와는 다른 상수 opad와 b비트로 패딩한 비밀키를 XOR 연산 연산 결과값과 b비트의 HMAC을 병합하여 해시 연산 최종적으로 n비트의 HMAC을 생성  CMAC NIST표준 FIPS 113에 정의된 MAC으로써 대칭키 암호시스템의 CBC모드를 활용하는 방법\n 암호 블록체인과 동일한 알고리즘 이전 블록의 암호문과 입력값를 XOR 연산하는 방식  생성 과정  메시지 M을 m비트의 블록 N개로 나눔  마지막 블록이 m비트가 아닐 시 첫 비트 = 1, 이후 비트 = 0으로 패딩   비밀키 K를 사용하여 첫 블록 M1을 암호화하여 M2와 XOR연산 해당 과정을 반복하여 수행 마지막 블록, 직전 암호문, 새로운 키 k를 XOR 연산 해당 결과값의 왼쪽부터 n비트를 CMAC 값으로 활용  k 생성 알고리즘  0으로 이루어진 m비트의 블록을 비밀키 K로 암호화  패딩이 적용되지 않았을 경우 x를 곱함 패딩이 적용된 경우 x^2를 곱함    활용 사례 IPsec  IP(Internet Protocol)에 보안 기능을 추가한 것 통신 내용의 인증과 무결성 확인을 위해 사용  SSL/TLS  웹 통신 프로토콜 통신 내용의 인증과 무결성 확인을 위해 사용  공격 재전송 공격 도청한 메시지와 MAC 값을 반복 송신하여 비정상적인 서비스 요청\n보안 대책  순서 번호  순서번호가 포함된 MAC을 계산하지 못하도록 하여 방지   타임스탬프  MAC값이 바르더라도 시간이 맞지않다면 오류라고 판단하여 방지   비표(nonce)  일회용 랜덤값을 포함하여 MAC값을 계산하게 하여 재전송 공격을 방지    키 추측에 의한 공격 공격자에 의해 송수신에 사용하는 키를 추측당해서는 안된다.\n보안 대책 메시지 인증 코드에 사용되는 키를 생성할 때는 암호학적으로 안전한 의사 난수 생성기를 사용해야 한다.\n해결할 수 없는 문제 제 3자에 대한 증명  공유키를 이용하므로 MAC값을 계산할 수 있는 것은 송ㆍ수신자뿐임 하지만 누가 MAC값을 계산했는지는 특정 불가 제 3자에게 MAC 값을 계산한 것이 누구인지 증명 불가 전자서명을 사용하면 제 3자에 대한 증명 가능  부인 방지  송신자 Elice는 Bob에게 메시지를 보내지 않았다고 주장 해당 주장이 맞는 지 확인이 불가하므로 부인방지 불가 전자서명을 이용하면 부인방지 가능  ","excerpt":"해시함수는 데이터의 무결성을 보장하지만 발신자의 신원 확인이 불가능하다. …","ref":"/til/security/cryptology/mac/","title":"MAC(Message Authentication Code)"},{"body":"zsh에서는 ~/.zshrc에 필요한 alias를 등록하면 된다.\n# alias zshconfig=\"mate ~/.zshrc\"\r# alias ohmyzsh=\"mate ~/.oh-my-zsh\"\r텍스트에디터로 해당 파일을 열면 하단에 아래와 같이 적혀져 있는데 이후 alias를 작성하면 된다.\nalias python=\"python3.7\"\ralias pip=\"pip3.7\"\r예를 들어 우분투나 맥에서 python으로 명령어를 사용하고 싶을 때 위와 같이 적용한다.\n","excerpt":"zsh에서는 ~/.zshrc에 필요한 alias를 등록하면 된다.\n# alias zshconfig=\"mate ~/.zshrc\" …","ref":"/til/zsh/register-alias/","title":"Register Alias"},{"body":"앞서 프로젝트 및 앱 생성 과정을 알아보았으며, 이를 토대로 Hello Lion을 출력하는 페이지를 만들어 보도록 할 것이다. 이 프로젝트는 장고를 시작하는 가장 쉬운 난이도의 프로젝트이기는 하나 장고를 배우는 것이 처음이라면 구조 자체가 복잡하게 느껴질 수 있다. 하지만 해당 프로젝트를 진행하면 장고의 전체적인 구조를 머리 속에 그리는 것이 가능할 것이다.\n구현 과정 Hello Lion을 출력하는 장고 프로젝트를 구현 과정은 크게 4단계로 나누어 볼 수 있다.\n 앱 - 프로젝트 연결 “Hello Lion” 출력하는 html 생성 사용자 요청에 html파일을 호출하는 함수 작성 url과 views( 함수가 작성된 파일 ) 연결  이러한 구조는 장고 프로젝트의 기본이라 할 수 있는 것이므로 익혀두어야만 한다.\n 장고 구조에 대해서 좀 더 알아보고 싶다면 MTV패턴 글을 참고하자\n 앱 프로젝트 연결 프로젝트를 시작하기 위해서는 프로젝트와 앱을 생성해야 한다. 이 작업에 필요한 명령어는 해당 글에 작성해두었다. 하지만 앱은 생성했다고 해서 프로젝트에서 바로 사용할 수는 없고, 번거롭기는 하지만 앱을 프로젝트에 등록해야 한다.\n앱 등록 settings.py\nINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'hellolion', ] 앱을 등록하는 과정은 간단하다. 단지 프로젝트 디렉토리 안에 있는 settings.py라는 파일에서 INSTALLED_APPS라는 부분에 앱명을 작성해서 추가해주면 된다.\n 주의!! 리스트 요소 마지막에는 콤마(,)를 붙이도록 한다. 안그러면 에러가 발생할 것이다..\n Hello Lion 출력하는 html 생성 장고에서 템플릿(Templates)은 사용자에게 보여지는 화면을 담당하는 부분이다. 보통 템플릿은 html을 말하며 이러한 포맷의 파일을 templates라는 디렉토리에 생성하면 우리가 보여주고 싶은 화면을 사용자에게 띄울 수 있다.\n templates라는 폴더는 자동으로 생성되지 않으며, 앱 폴더 내부에 직접 생성하면 된다.\n home.html\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eHello Lion!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHello Lion\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 사용자 요청에 html파일을 호출하는 함수 작성 뷰(View)는 데이터를 처리하는 함수들을 정의하는 부분이다. 여기서 템플릿(Template)이 사용자에게 어떻게 보여지게 할 지를 결정할 수 있다. 이번 프로젝트에서는 사용자 요청이 오면 html 파일을 특별한 가공없이 보여주기만 하는 함수를 작성해볼 것이다.\nviews.py\nfrom django.shortcuts import render # Create your views here. def home(request): return render(request, 'home.html') home이라는 함수는 요청이 오면 home.html을 render라는 메서드를 통해서 반환시킨다.\n이는 사용자가 home이라는 함수를 호출하는 것으로 home.html을 볼 수 있다는 것과 같은 말이다.\nurl과 views 연결 이쯤되면 사용자가 어떻게 함수를 호출할 수 있는지 궁금해질 것이다. 그 해답은 바로 url이다!!\n장고는 특정 url에 접속하면 특정 함수가 호출되도록 설정할 수 있으며 urls.py 파일에서 해당 설정이 이루어진다.\nfrom django.contrib import admin from django.urls import path import hellolion.views urlpatterns = [ path('admin/', admin.site.urls), path('', hellolion.views.home, name='home'), ] 위 코드에서 urlpatterns는 특정 url에서 어떤 함수를 사용할 것인지를 지정하는 부분이다. home이라는 함수가 최상위 주소('')에서 호출되도록 하기 위해서 path('', hellolion.views.home, name='home'),라고 작성해주었다.\n 주의!! urlpatterns에 요소를 추가할 떄도 마지막에 콜론(,)을 붙여주어야 한다.\n path 위 코드에서 urlpatterns에 특정 url을 지정하기 위해서 path라는 것이 사용되었다. 좀 더 자세히 알아보자.\npath('url', 'app명.views.함수명', name='path명')  path는 세 인자(url, 함수, 이름)를 받는다. 이를 통해서 url과 함수를 맵핑할 수 있으며, 세 번째 인자로 해당 url에 대한 이름을 지정하여 이후 장고 내에서 url 경로를 호출할 수 있다.\n 세 번째 인자는 필수 속성은 아니다. 나중에 url을 간편하게 호출하기 위해서 사용한다.\n 결과 $ python manage.py runserver 서버를 작동하면, 로컬 호스트(http://127.0.0.1:8000/)에서 Hello Lion이라는 문자를 브라우저에서 확인 할 수 있다!\n","excerpt":"앞서 프로젝트 및 앱 생성 과정을 알아보았으며, 이를 토대로 Hello Lion을 출력하는 페이지를 만들어 보도록 할 것이다. …","ref":"/til/django/study/run-server/","title":"Run Server"},{"body":"","excerpt":"","ref":"/til/security/network/","title":"Security"},{"body":"패스워드 크래커  사전 공격(Dictionary Attack)  패스워드 사전 파일을 이용하여 접속 계정을 알아내는 해킹 방법 공격 대상의 개인 정보를 알고 있다면 효율적   무차별 공격(Brute-force Attack)  성공할 때까지 가능한 모든 조합의 경우의 수를 시도해 공격   하이브리드 공격  사전 공격 + 무차별 공격   레인보우 테이블 공격  패스워드를 해시 처리하여 패스워드와 해시로 이루어진 체인을 무수히 만든 테이블을 대입하여 공격 사전 공격, 무차별 공격보다 적은 시간 소요 패스워드에 솔팅 처리를 하여 예방    사회공학 공격 신뢰할 수 있는 개인이나 조직을 사칭하여 공격대상의 민감한 정보를 빼내는 공격 기법\n 피싱(Phishing)  공격 대상에게 E-mail 을 발송하여 위조된 사이트로 이동시킨 후, 개인 정보를 요구   파밍(Pharming)  정상적인 사이트로의 접속 요청을 위조 사이트로 바꾸어 개인정보 탈취   스미싱(SMishing)  SMS+Phishing SMS을 통해 사용자를 속여 악성 소프트웨어 설치를 유도 해당 소프트웨어를 통해 개인정보를 탈취하거나 금전을 요구    은닉채널 엔티티가 허가되지 않은 방식으로 정보를 얻는 방법\n 보안 메커니즘에 의해 통제되지 않는 정보흐름 정보흐름은 은닉채널이 존재하지 않게 설정해야 함 은닉채널의 위험은 대역폭에 따라 변경되기 때문에 대역폭을 제한  대응책  로그분석 HIDS(호스트 기반 IDS)탐지 시스템 자원분석  방사  컴퓨터와 장치로부터 방출되는 전기적 신호를 가로채는 방법  대응책  탬페스트  차폐물질을 통해 방사되는 신호를 억제하는 기술의 표준 차폐물질을 생산하는 업체는 반드시 표준에 대해 인증   백색소음  일정한 범위의 무작위적인 전기 신호를 의도적으로 방출   통제구역  전기적 신호가 새어나지 않게 하기 위해 벽면에 물질을 사용    ","excerpt":"패스워드 크래커  사전 공격(Dictionary Attack) …","ref":"/til/security/access-control/security-threats/","title":"Security-Threats"},{"body":"스니핑 네트워크 상에서 자신이 아닌 다른 상대방의 패킷 교환을 엿듣는 행위\n TCP/IP 프로토콜을 이용한 통신에서 통신매체를 통과하는 패킷이 암호화되어 있지 않으므로 스니핑하여 메시지 내용을 보는 것이 가능하다.\n 허브 환경 허브는 들어오는 패킷에 대해 들어온 포트를 제외한 모든 포트에 패킷을 보내는 장비인데 다른 사람의 패킷 또한 여기를 지나가기 때문에 스니핑이 가능하다.\n 기본적으로 패킷은 필터링을 통해 자신의 것만 볼 수 있음 시스템의 NIC를 promiscuous(무차별 모드)로 동작시키면 다른 패킷도 볼 수 있음  스위치 환경 스위치 재밍 스위치의 MAC 주소 테이블 버퍼를 오버플로우 시켜서 스위치를 허브처럼 동작하게 만드는 기법\n 스위치는 Fail Open을 따르는 장비이므로 문제가 생기면 허브로 동작  Fail Open: Fail Safe 정책, 장애발생시 모든 트래픽 허용(가용성\u003e보안성) Fail Close: Fail Secure 정책, 장애발생시 모든 트래픽 차단(가용성\u003c보안성)    ARP 리다이렉트 공격자가 자신이 라우터인 것처럼 MAC 주소를 위조하여 ARP Reply 패킷을 해당 네트워크에 broadcast 하여 해당 로컬 네트워크의 모든 호스트와 라우터 사이의 트래픽을 스니핑하는 기법\nICMP 리다이렉트 3계층에서 스니핑 시스템을 N/W에 존재하는 또 다른 라우터라고 알려 패킷의 흐름을 바꾸는 공격\n ICMP 리다이렉트: N/W에서 하나의 라우터/게이트웨이로 감당이 되지 않는 경우 2개 이상으로 운영(로드밸런싱)\n 스위치의 SPAN / port Mirroring 스위치 특정 포트에 분석 장비를 접속하여 다른 포트의 트래픽을 분석하는 기술\n 본래는 관리 목적으로 사용 공격자가 물리적 접근시 손쉽게 패킷 스니핑 가능  보안 대책 수동적인 대응 방법 스니핑되더라도 해당 내용이 노출되지 않도록 통신내용을 암호화하는 방법\n능동적인 대응 방법(스니퍼 탐지)  ping을 이용한 방법  네트워크에 존재하지 않는 MAC 주소로 위장하여 ping을 보냄 만약 스니퍼가 존재하면 ICMP Echo Reply를 송신하는데 이를 통해 탐지 스니퍼가 아니면 ICMP Echo Request를 볼 수 없음   ARP watch  초기의 MAC 주소와 IP 주소의 매칭 값을 저장 ARP 트래픽을 모니터링하여 이를 변경하는 패킷이 있으면 관리자에게 알려주는 툴     스니퍼는 패킷 또는 LAN 세그먼트 상을 지나는 트래픽을 분석할 수 있는 S/W나 H/W로 유입 패킷에 대한 IP 주소와 MAC 주소 필터링을 하지 않는 promiscuous 모드에서 작동한다.\n 스푸핑 IP 주소, MAC 주소 등을 속여 정보를 가로채거나 속이는 기법\nARP 스푸핑 공격자는 공격 대상 A, B에게 상대 IP에 해당하는 MAC 주소를 자신의 MAC 주소라고 속여 ARP 패킷을 보내 A,B간에 통신할 때 공격자를 거치도록 하는 공격\n ARP Cache는 자주 폐기되므로 공격자는 캐시를 갱신해주어야 한다. (ARP Cache Poisoning)  보안 대책  ARP -s 명령어를 통해 정적으로 ARP 테이블을 설정  IP 스푸핑 공격자가 자신의 IP 주소가 아닌 신뢰관계를 가진 시스템의 주소로 위장하여 공격대상 서버로부터 정보를 가로채는 공격\n공격 절차  클라이언트에게 DoS 공격 공격자는 클라이언트로 위장하여 서버에 접속  보안 대책  출발지 IP주소에 내부망 IP주소를 가지고 있는 패킷을 차단 트러스트 차단 트러스트된 시스템의 MAC주소를 static 지정 rlogin 대신 ssh를 사용  ","excerpt":"스니핑 네트워크 상에서 자신이 아닌 다른 상대방의 패킷 교환을 엿듣는 행위\n TCP/IP …","ref":"/til/security/network/sniffing-and-spoofing/","title":"Sniffing/Spoofing"},{"body":"","excerpt":"","ref":"/til/security/application/","title":"Application"},{"body":"기본 개념 용어  릴레이션: 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것 속성과 튜플: 릴레이션의 열(속성)과 행(튜플) null: 아직 모르거나 해당되는 사항이 없음을 표현하는 특별한 값 차수: 하나의 릴레이션에서 속성의 전체 개수 카디널리티: 하나의 릴레이션에서 튜플의 전체 개수 도메인: 한 릴레이션에서 특정 속성이 가질 수 있는 데이터 형식을 지닌 모든 가능한 값의 집합 extent: 테이블을 구성하는 물리적으로 연속적인 디스크 공간  키 정의  후보키(Candidate Key): 키의 특성인 유일성과 최소성을 만족하는 키 슈퍼키(Super Key): 유일성을 만족하는 키 기본키(Primary Key): 여러 개의 후보키 중에서 하나를 선정하여 사용하는 키 대체키(Alternate Key): 여러 개의 후보키 중에서 기본키를 제외한 나머지 키 외래키(Foreign Key): 어느 한 릴레이션 속성의 집합이 다른 릴레이션에서 기본키로 이용되는 키  무결성  키 무결성(key integrity): 한 릴레이션에 같은 키값을 가진 튜플이 있어서는 안됨 개체 무결성(entity integrity): 기본키에 속해 있는 전체 또는 일부 속성은 NULL 값을 가질 수 없음 참조 무결성(referential integrity): 릴레이션은 참조할 수 없는 외래키값을 가질 수 없음  트랜잭션  하나의 논리적 기능을 수행하기 위한 작업의 단위 한꺼번에 모두 수행해야 할 일련의 DB 연산 병행 제어 및 회복 작업의 논리적 단위  성질  원자성(Atomictiy)  트랜잭션 내 모든 연산은 반드시 한번에 완료 그렇지 않을 경우 한꺼번에 취소 (all or nothing)   일관성(Consistently)  트랜잭션이 성공적으로 완료되면 일관성 있는 DB 상태로 변환 단 프로그램 실행 중 일관성 위반은 상관없음   격리성(Isolation)  트랜잭션이 실행중에 있는 연산의 중간결과에 다른 연산이 접근하지 X   영속성(Durability)  트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 영속적 따라서 시스템은 어떤 경우라도 완료된 결과의 영속성을 보장해야 함    보안 DB 상의 데이터에 대한 인가되지 않은 접근, 의도적/비의도적 변경, 파괴 등의 일관성 저해하는 사고 등으로부터 DB를 보호하는 것\n 보안 특성: 비밀성, 무결성, 가용성\n 보안 위협 사용자가 데이터에 접근함으로써 발생될 수 있는 정보의 부적절한 유출, 부적절한 처리, 수정으로부터 무결성의 손상 발생 가능\n집성(Aggregation) 개별적인 여러 소스로부터 민감하지 않은 정보(낮은 보안 등급)를 수집/조합하여 민감한 정보(높은 보안 등급)를 알아내는 행위\n추론(Inference) 일반적인 데이터로부터 비밀정보를 추측해내는 행위\n요구사항    보안 요구사항 설명     부적절한 접근 방지 승인된 사용자에게만 접근 권한 부여 및 사용자, 응용 시스템의 접근 요청에 대한 정당성 여부 검사   추론방지 사용자가 통계적인 데이터로 개별적인 데이터 항목에 대한 정보를 추적할 수 없도록 함   무결성 보장 인가되지 않은 접근, 저장 데이터를 손상시킬수 있는 시스템 오류 등으로 DB를 보호   운영적 무결성 보장 트랜잭션의 병행 처리 동안에 데이터에 대한 논리적 일관성을 보장   의미적 무결성 보장 데이터에 대한 허용값을 통제함으로써 데이터의 논리적 일관성을 보장   감사기능 DB에 대한 모든 접근이 감사기록을 생성   사용자 인증 OS서 수행하는 사용자 인증보다 엄격한 인증 필요   기밀성 보장 중요 데이터에 대한 기밀성 보호, 인가된 사용자에게만 접근을 허용해야 함    DB 보안 통제 흐름제어 높은 수준의 보안이 낮은 수준의 객체로 이동하는 것을 검사하여 접근 가능한 객체 간 정보흐름을 조정\n추론제어 간접적인 데이터 노출로부터 데이터를 보호하기 위한 제어\n 비밀정보 은폐 DB 지식 추적  사용자가 가지고 있는 데이터를 고려하여 질의 허용여부를 결정   데이터 위장  일관성 없는 질의결과 제공해 통계적 추론을 방지    접근제어 허가된 범위 내 시스템 정보에 대한 접근을 권한에 따라 인가된 사용자에게만 제공\nOS 접근통제와 비교    OS DB     객체(파일)는 다른 객체와 관련성이 없음 객체(레코드, 필드)는 상호 관련되어 있음   사용자는 하나의 파일을 읽고 다른 파일의 내용을 결정할 수 없음 하나의 데이터 요소를 읽고서 다른 데이터의 내용을 결정할 수 있음    추론 인가된 쿼리 수행과 합법적 응답을 통해 비인가된 정보를 추론\n방지 방법  DB 설계시 추론 탐지  DB 구조변경, 접근 제어 방식 변경으로 추론 채널을 제거해 추론을 방지   쿼리 타임 시 추론탐지  쿼리처리 중 추론 채널 위반을 제거하려는 시도 추론 채널이 탐지되면 쿼리를 거부하거나 변경    DBMS 보안 통제 SQL 기반 통상 DB관리자(DBA)가 권한을 가지므로 DBA권한이라고 함\n SQL은 GRANT와 REVOKE라는 접근 권한 관리 명령어를 제공  GRANT(권한 부여) GRANT privilege_name | role To user_name [WITH ADMIN OPTION]; 만약 user_name 대신 PUBLIC을 기술하면 모든 사용자에게 해당 시스템 권한 부여\nREVOKE(권한 회수) REVOKE privilege_name | ALL on table FROM user_name | role_name | PUBLIC; PUBLIC을 사용하면 모든 사용자의 권한 제거\n뷰 기반  뷰는 하나 이상의 기본 테이블로부터 유도되어 만들어지는 가상 테이블 데이터의 논리적 독립성을 보장하며 접근제어를 통해 보안을 제공 DB의 제한적 접근을 제공하여 사용자가 특정 행과 열에 대한 접근이 가능  보안 취약점 점검    구분 설명     디폴트 계정 패스워드 변경 DBMS가 적용된 디폴트 계정은 해커의 손쉬운 공격수단으로 악용되기에 반드시 비밀번호를 변경하거나 삭제해야함   DB 패스워드 규칙 강화 디폴트 계정이나 일반 계정을 생성할 때 패스워드 규칙을 강화해 손쉽게 크래킹 되지 않도록 해야한다.   DBA 권한의 제한 일반 계정이 DBA 권한을 부여받지 않도록 주의   보안 패치 적용 제품별로 발표된 패치 적용해 취약점 제거   사용하지 않는 계정 삭제 생성한 계정 중 불필요한 계정은 삭제하여 관리의 허점이 없도록 해야함   개발자 IP 접근 제한 필요에 의해 서버로 접근하는 개발자는 접근 IP 제한해 접근제어 강화   제품별 취약점 제거 이미 알려진 보안 취약점에 대해 피치나 제 2의 해결책으로 취약점 제거   데이터 암호화 사용자 패스워드가 일방향 암호화되어 있는지 확인, 기밀 구분에 따라 암호화 적용    암호화 방식 Plug-in 방식 암ㆍ복호화 모듈을 DB 서버 내에 설치하여 암ㆍ복호화를 수행\n 적용성은 뛰어나지만 CPU에 부하 성능에 대한 민감성이 낮은 시스템의 경우 저렴한 비용으로 구축 가능  API 방식 암ㆍ복호화 모듈을 애플리케이션 서버 내에 설치하여 암ㆍ복호화를 수행\nHybrid 방식 Plug-in 방식 + API 방식\n 성능이 우선시 되는 환경에서는 API를 적용 성능 영향이 덜 민감한 환경에는 플러그인 방식을 적용  TDE 방식 DB 내부에서 데이터 파일 저장 시 암호화, 파일에 저장된 내용을 메모리 영역으로 가져올 때 DBMS에 의해 자동으로 복호화\n DBMS 커널 레벨에서 처리되므로 애플리케이션 수정이 없음 DBMS 자체 인덱스 기능과 연동 가능  파일 암호화 방식 OS상에서 확인 가능한 개체인 파일을 암호화하는 방식\n OS대한 의존도 높음 비정형 데이터에 대한 암호화 적용 가능  ","excerpt":"기본 개념 용어  릴레이션: 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것 속성과 튜플: 릴레이션의 열(속성) …","ref":"/til/security/application/database/","title":"Database"},{"body":"HTML 문서 전체를 대변하는 객체이자 DOM 객체를 접근하는 경로의 시작점\n HTML 문서 로드 전, Document 객체를 생성하고 DOM 트리 생성\n  프로퍼티: HTML 문서의 전반적인 속성 내포 메소드: DOM 객체 검색, DOM 객체 생성, HTML 문서 전반적 제어 컬렉션: HTML 태그들을 배열처럼 접근할 수 있는 컬렉션을 둠  Document 객체 접근  window.document 또는 document 이름으로 접근 document 객체는 DOM 객체가 아님  write() and writeln()  write()  현재 document 객체에 담긴 HTML 콘텐츠 마지막에 HTML 텍스트를 추가 추가되는 HTML 텍스트는 DOM 객체로 바뀌고 DOM 트리에 추가 삽입된 HTML 텍스트가 브라우저 화면에 출력   writeln()  HTML 텍스트에 \\n을 덧붙여 출력. 한 칸 띄는 효과    open() and close()  open()  현재 브라우저에 출력된 HTML 콘텐츠를 지우고 새로운 HTML 페이지 시작. 즉 document 객체에 담긴 DOM 트리를 지우고 새로 시작   close()  현재 브라우저에 출력된 HTML 페이지 완성 더 이상 document.write() 할 수 없음    // 현재 HTML 페이지의 내용을 지우고 다시 시작 document.open(); document.write(“\u003chtml\u003e\u003chead\u003e...\u003cbody\u003e안녕하세요.”); document.write(“.......”); document.write(“\u003c/body\u003e\u003c/html\u003e”); document.close(); 문서의 동적 구성 DOM 객체 동적 생성 var newDIV = document.createElement(\"div\"); newDIV.innerHTML = \"새로 생성된 DIV입니다.\"; newDIV.setAttribute(\"id\", \"myDiv\"); newDIV.style.backgroundColor = \"yellow\"; DOM 트리에 삽입 var p = document.getElementById(\"p\"); p.appendChild(newDiv); DOM 객체의 삭제 var myDiv = document.getElementById(\"myDiv\"); var parent = myDiv.parentElement; parent.removeChild(myDiv); // 부모에서 myDiv 객체 삭제 ","excerpt":"HTML 문서 전체를 대변하는 객체이자 DOM 객체를 접근하는 경로의 시작점\n HTML 문서 로드 전, Document …","ref":"/til/javascript/document/","title":"Document"},{"body":"메시지에 전자적인 서명을 하는 것으로, 메시지와 메시지를 생성한 사람과의 인증을 의미한다.\n전자서명 개념  송신자(서명자)는 서명 알고리즘을 이용하여 메시지에 서명 수신자(검증자)의 검증 알고리즘으로 서명자의 서명을 검증  형식  공개키 서명 방식  서명자의 검증 정보를 공개하여 누구나 검증 가능 서명 생성 및 검증 간편   중재 서명방식  서명 생성과 검증을 제 3자가 중재 제 3자의 참여 필요    제공 서비스  메시지 인증: 수신자는 메시지가 원하는 송신자로부터 왔다는 것을 확신할 수 있음 메시지 무결성: 메시지가 해시함수와 서명을 통해 전송되므로 변조되지 않음을 알 수 있음 부인방지: 신뢰받는 제 3자로부터 검증받을 수 있음   기밀성은 제공되지 않으므로 비밀키/공개키 암호화를 해야함\n 주요 기능  위조 불가: 합법적인 서명자만이 전자서명을 생성할 수 있음 서명자 인증: 전자서명의 서명자를 누구든지 검증할 수 있음 부인방지: 서명자는 서명행위 이후에 서명한 사실을 부인할 수 없음 변경 불가: 서명한 문서의 내용을 변경할 수 없음 재사용 불가: 전자문서의 서명을 다른 전자문서의 서명으로 사용할 수 없음  종류 RSA  전자 서명 구조에서는 개인키와 공개키의 역할이 비대칭 암호화 과정과 반대 송신자의 개인키로 암호화하고 수신자가 송신자의 공개키를 이용하여 복호화   비대칭키 암호화: 수신자의 공개키로 암호화하고 수신자의 개인키로 복호화\n ElGamal  이산대수 문제를 이용한 최조 서명방식 ElGmal 암호시스템과 동일한 키를 사용하나 알고리즘은 다름 RSA보다 서명 길이가 2배, 계산량은 거의 4배  Schnorr  ElGamal 기반이지만 서명의 크기를 줄인 새로운 구조  DSS(Digital Signature Standard)  ElGamal 전자서명을 개량(이산대수 문제) 오직 전자서명 기능만을 제공하도록 설계 서명과 검증에 소요되는 계산량을 줄임  타원곡선 전자서명 구조(ECDSA)  타원곡선에 기반을 둔 DSA 짧은 비트 길이로 인해 짧은 처리 시간에 짧은 서명 생성 가능  전자서명 방식 복원형 전자서명  기존 공개키 암호방식을 이용하여 별도의 전자서명 프로토콜 필요 X 메시지를 일정 블록 크기로 나누어, 각 블록에 서명하므로 시간이 소요 실제로는 사용되지 않음  부가형 전자서명  메시지를 해시해서 나온 다이제스트에 한 번의 서명 생성하므로 효율적 전송량이 조금 늘어나나 실제로 많이 사용됨  특수 전자서명 공개키 방식을 이용한 전자 서명은 검증하는 키가 공개되므로 검증을 누구나 할 수 있다는 문제점이 있다.\n 부인방지 전자서명: 자체 인증 방식을 배제시키고 서명 검증할 때, 서명자의 도움이 있어야 검증 의뢰 부인방지 서명: 신뢰하는 제 3자가 서명을 검증 수신자 지정 서명: 지정한 검증자만이 서명을 검증할 수 있음  필요시 제 3자에게 그 서명이 서명자에 의해 자신에게 발행된 서명임을 증명 가능   위임 서명: 부재 중 자신을 대리해서 서명 은닉 서명: 서명문의 내용을 숨기는 방식(익명성) 다중 서명: 동일 전자문서에 여러 명이 서명  전자서명의 응용 전자투표 시스템 선거인 명부를 구축한 중앙 시스템과 직접 연결된 단말에 자신이 정당한 투표자임을 증명하면 어디서나 무기명 투표를 할 수 있는 방식\n요구사항  완전성: 모든 투표가 정확히 집계 익명성: 투표 결과로부터 투표자 구별 불가 건전성: 부정 투표자에 의한 선거 방해 없어야 함 이중투표방지: 정당한 투표자는 단 1회만 투표 허용 정당성: 투표에 영향을 미치는 것이 없어야 함 적임성: 투표 권한을 가진 자만이 투표 가능 검증 가능: 투표 결과를 누구나 확인하여 검증 가능  방식  PSEV 방식: 기존 선거 방식 + 전자 키오스트(kiosk) 방식: 공공장소에 설치(관리자 없음) REV 방식: 어디서든 투표 가능  비밀투표 침해가능성 높음    전자 입찰 시스템 입찰공고에서 다수의 공급자가 응찰하면 이중에서 가장 싼 가격을 제시한 응찰자와 계약을 받는 입찰방식을 인터넷으로 구현\n요구사항  독립성: 전자입찰 시스템 각 구성요소는 독자적 자율성 보장받아야 함 비밀성: 네트워크상 개별 정보는 각 구성요소 간에 누구에게도 노출 안되야 함 무결성: 입찰 시 입찰자 자신의 정보 확인 가능케 하여 누락 및 변조 여부 확인 가능해야 함 공평성: 입찰이 수행될 때 모든 정보 공개되어야 함 안전성: 각 입찰 참여자 간의 공모 방지되고, 입찰 공고자와 서버의 독단 발생되지 않아야 함  문제점  네트워크상의 메시지 유출 입찰자와 서버 사이의 공모 입찰자간의 공모 입찰자와 입찰 공무자간의 공모  전자 서명으로 해결할 수 없는 문제  서명을 검증할 때 이용하는 공개키가 진짜 송신자의 공개키여야 함 올바른 공개키 입수를 위해 인증서가 고안됨   인증서: 공개키를 메시지로 간주하고 신뢰 가능한 제 3자에게 전자서명을 해서 받은 공개키\n ","excerpt":"메시지에 전자적인 서명을 하는 것으로, 메시지와 메시지를 생성한 사람과의 인증을 의미한다.\n전자서명 개념  송신자(서명자)는  …","ref":"/til/security/cryptology/electronic-signature/","title":"Electronic Signature"},{"body":"장고에서는 템플릿 상에서 중복되는 코드를 줄이게 도와주는 템플릿 상속이라는 기능을 제공한다.\n방법\n 중복되는 부분으로만 구성된 템플릿 생성 해당 템플릿에서 공통되지 않게 하려는 부분만 {% block %} 태그를 활용해서 감싼다.  예를 들어서 템플릿 하나를 재사용하는데 이때 달리하고 싶은 부분이 브라우저 탭 상에 출력되는 title이랑 body에 들어가는 내용이라 해보자\n\u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e{% block title %}\u003c!-- override --\u003e{% endblock %}\u003c/title\u003e \u003c!-- favicon.ico --\u003e \u003clink rel=\"shortcut icon\" href=\"{% static '/page/images/favicon.ico' %}\"\u003e \u003c!-- CSS Styles --\u003e \u003clink rel=\"stylesheet\" href=\"{% static '/page/css/style.css' %}\"\u003e \u003c/head\u003e \u003cbody\u003e {% block content %} \u003c!-- override --\u003e {% endblock %} \u003c/body\u003e 위 템플릿은 이러한 경우에 활용할 수 있는 예시이다. 상속의 개념으로 보았을 때 해당 템플릿은 부모 템플릿이며, 이것을 기반으로 한 새로운 자식 템플릿을 생성하는 것도 가능하다.\n아래 템플릿은 위에서 작성한 base.html을 상속하는 새로운 템플릿이다.\n\u003c!-- base.html을 상속한다는 것을 명시 --\u003e {% extends 'base.html' %} {% block title %} \u003c!-- override --\u003e {% endblock %} {% block content %} \u003c!-- override --\u003e {% endblock %} 이렇게 작성해주기만 하면 부모 템플릿에서 작성한 코드를 작성하지 않더라도 동일하게 적용되며, {% block %} 태그 사이에 코드를 작성하면 부모 템플릿과 공통된 부분을 공유하면서 차이가 있는 템플릿을 생성할 수 있다.\n","excerpt":"장고에서는 템플릿 상에서 중복되는 코드를 줄이게 도와주는 템플릿 상속이라는 기능을 제공한다. …","ref":"/til/django/study/extend-template/","title":"Extend Template"},{"body":"에러 발생 WSL으로 깃 작업을 하던 중 예상치 못한 오류로 컴퓨터 셧다운 이후 해당 오류 발생\nzsh: corrupt history file /home/jeonghun/.zsh_history 에러 해결 cd ~ mv .zsh_history .zsh_history_bad strings .zsh_history_bad \u003e .zsh_history fc -R .zsh_history rm ~/.zsh_history_bad ","excerpt":"에러 발생 WSL으로 깃 작업을 하던 중 예상치 못한 오류로 컴퓨터 셧다운 이후 해당 오류 발생\nzsh: corrupt …","ref":"/til/zsh/how-to-fix-a-corrupt-zsh-history-file/","title":"how to fix a corrupt zsh history"},{"body":"IDS(침입탐지 시스템) 외부 침입에 대한 정보를 수집하고 분석하여 침입 활동을 탐지해 이에 대응하도록 보안 담당자에게 통보하는 기능을 수행하는 네트워크 보안시스템\n   장점 단점     해킹에 대해 방화벽보다 적극적 방어 가능내부 사용자의 오ㆍ남용 탐지 및 방어 가능해킹사고 발생시 어느정도 근원지 추적 가능 대규모 N/W에서 사용 곤란관리 및 운영 어려움새로운 침입기법에 대해 즉각적 대응 곤란보안사고의 근본적 해결책이 되지 못함    실행 단계  데이터 수집  탐지대상(시스템 사용내역, 패킷)으로부터 생성되는 데이터 수집   데이터 가공 및 축약  수집된 데이터를 침입 판정이 가능하도록 의미있는 정보로 전환   침입분석 및 탐지  비정상적 행위 탐지 기법, 오용 탐지 기법, 하이브리드 탐지 기법   보고 및 대응  시스템을 침입했다고 판정된 경우 적절한 대응을 하거나 관리자에게 침입사실 보고    지식기반 침입탐지  규칙기반, 오용 침입탐지라고도 함 기존의 침입방법을 DB에 저장해두었다가 사용자의 행위 패턴이 기존 침입 패턴과 일치하거나 유사한 경우 침입으로 판단 새로운 공격이나 침입 방법 출현시 그에 맞는 공격패턴 생성하여 추가     장점 단점     오탐률(False Positive) 낮음전문가 시스템(추론기반 지식 베이스) 이용트로이 목마, 백도어 탐지 지속적인 공격패턴 갱신 필요속도 문제 때문에 대량의 자료 분석에 부적합    종류  전문가 시스템  침입 또는 오용의 패턴을 실시간으로 입력되는 감사정보와 비교하여 침입을 탐지   상태전이 모델  공격 패턴에 따라 시스템의 상태 변화를 미리 상태전이도로 표현 후 실시간으로 시스템의 상태 변화를 추적하여 침입상태를 감시   패턴 매칭  알려진 공격 패턴을 시나리오 형태로 DB에 저장한 후 발생하는 사건의 패턴을 비교    행위기반 침입탐지  통계적 변형, 비정상행위 침입탐지라고도 함 정상적 행위에 대한 정의들과 비교해 심각한 수준의 일탈행위를 식별하는 방식     장점 단점     인공지능 알고리즘 사용으로 수작업의 패턴 업데이트 불필요오용 탐지 기법보다 DB관리가 용이트로이 목마, 백도어 탐지알려지지 않은 공격(Zero-Day Attack)도 탐지 가능침입 외 시스템 운용상 문제점도 탐지 오탐률(False Positive) 높음정상/비정상 임계치 설정 어려움    종류  통계적 분석  사용자/시스템 행위의 이전 정보를 기반으로 정상행위를 주기적으로 갱신   예측가능한 패턴 생성방법  기존의 정상적인 패턴과 현재 사건 간의 패턴을 비교하여 탐지   신경망 모델  사용자의 행위 정보를 학습하여, 입력된 사건 정보를 사용자의 행위 정보와 비교하여 탐지    대응방법에 따른 분류  능동적 대응  침입에 대해 가장 빨리 실행할 수 있는 행동으로 침입에 의한 손실을 줄일 수 있게 함 하지만 오경보를 많이 발생시켜 시스템의 가용성을 저하시킬 수 있음   수동적 대응  대량의 정보를 수집하는 형태를 취하거나 권한을 가진 사용자에게 엄격한 조치를 취할수 있도록 통보하는 형태    데이터 수집원에 따른 분류 NIDS(Network-based IDS) 네트워크를 통해 전송되는 패킷 정보를 수집/분석하여 침입을 방지\n   장점 단점     초기 구축비용이 저렴OS에게 독립적이어서 구현/관리 쉬움공격자가 흔적을 제거하기 어려움 암호화된 패킷 분석 불가스위칭 환경에서 HIDS보다 비용 높음고속 네트워크 환경에서 패킷 손실이 많아 탐지율이 떨어짐호스트 상에서 수행되는 세부 행위 탐지 불가    HIDS(Host-based IDS) 호스트 시스템으로부터 생성되고 수집된 감사 자료로 침입을 방지\n   장점 단점     정확한 탐지 가능암호화 및 스위칭 환경에 적합추가적인 H/W가 필요하지 않음N-IDS, 방화벽과 달리 외부 침입자와 내부침입자 모두 발견 각각의 시스템에 설치해야 하므로 다양한 OS를 지원해야 함시스템에 추가적인 부하구현이 용이하지 않음로그 변조, 공격에 의한 무력화    탐지 시점에 따른 분류  사후분석 시스템  고전적인 IDS 방식 수집된 데이터를 정해진 시간에만 분석 즉시 대응 불가   실시간 탐지 시스템  실시간 정보수집과 동시에 감사 데이터 발생, 침입 탐지가 이루어짐 대응책을 바로 실행    IDS의 위치 IDS는 목적에 따라 여러 곳에 설치가 가능\n 패킷이 라우터로 들어오기 전  N/W에 실행되는 모든 공격을 탐지 가능 모든 공격을 탐지하는 만큼 많은 패킷을 수신하므로 치명적 공격에 대처 어려움   라우터 뒤  라우터의 패킷 필터링을 거친 후에 들어온 패킷 검사   방화벽 뒤  네트워크에 직접 영향을 주므로 탐지되는 공격에 대한 정책과 방화벽과의 연동성이 가장 중요 만약 NIDS를 한 대만 설치해야할 경우 여기에 설치해야 함   내부 네트워크  방화벽은 외부에서 들어오는 패킷을 탐지하지만 내부는 무방비 내부 N/W의 해킹을 감시하고자 할 때 설치   DMZ  DMZ는 외부인터넷에 서비스를 제공하는 서버가 위치하는 N/W 매우 능력이 뛰어난 외부 공격자와 내부 공격자에 의한 데이터 손실이나 서비스 중지를 막음    IDS의 응용 긍정오류와 부정오류 침입자와 정상적인 사용자와의 행위 패턴이 겹치는 부분이 존재하므로 침입 탐지를 실제로 적용할 때는 절충과 기술의 요소가 적절히 사용되어야 함\n 긍정오류: 합법적인 사용자를 침입자로 판단(침입자의 행동을 넓게 잡았을 경우) 부정오류: 침입자를 합법적인 사용자로 판단(침입자의 행동을 좁게 잡았을 경우)  허니팟 자료를 가진 호스트인 것처럼하고 일부러 취약점을 만들어 해커를 유인하는 시스템\n   장점 단점     해커들의 행동이나 공격기법, 해킹목적을 분석제로데이 공격을 사전에 탐지할 수 있는 예방통제 기술잠재적 공격자에 대한 조기 경보 제공, 보안 전략의 결점 파악 자신에게 오는 패킷만 수집하므로 네트워크 전반에 대한 침입정보를 분석할 수 없음공격자가 알아차릴 경우 허니팟을 우회하거나 마비시키는 공격 가능    목적  중요 시스템에 접근하는 공격자를 다른 방향으로 돌림 공격자의 동작 정보 수집 관리자가 반응할 수 있도록 공격자가 시스템에 충분히 오랜 시간 동안 머무르기를 유도  스노트 일종의 IDS로 다양한 공격과 스캔 탐지 가능\n 실시간 트래픽 분석, 프로토콜 분석, 내용검색/매칭, 침입탐지 Rule에 의거하여 오버플로우, 포트스캔, CGI 공격, OS 확인 시도 등  룰 헤더 처리방식, 프로토콜, IP주소, 포트번호 등 처리할 패킷을 판단하는 기준 명시\n# 룰 헤더 형식 | action | protocol | IP 주소 | port | direction | IP 주소 | port | action\n   옵션 설명     alert alert를 발생시키고 로그를 남긴다   log 패킷을 로그에 남긴다   pass 패킷을 무시한다   active alert 발생, dynamic rule 활성화   dynamic active rule에 의해 활성화되고 log, rule과 동일하게 동작   drop 패킷 차단 후 로그에 남긴다   reject 패킷을 차단하고 로그에 남긴 후 TCP일 경우 TCP Reset 전송, UDP일 경우 ICMP port unreachable 전송   sdrop 패킷을 차단하지만 로그는 남기지 않음    protocol\nTCP, UDP, ICMP, IP 중 선택\nIP Address\n ,: 복수개 표현 !: 부정연산자 any: 모든주소  Port\n :숫자 = 숫자 포트 이하 숫자: 숫자 포트 이상  Direction\n -\u003e \u003c\u003e : 출발지와 목적지를 오가는 모든 패킷  룰 바디 alert 메시지나 패킷 메시지를 조사하기 위한 내용 기술\n   옵션 설명     msg alert 로그 출력시 이벤트 명으로 사용   content 패킷의 payload 내부 검색하는 문자열   offset content로 지정한 문자열의 검색 시작 오프셋   depth offset로부터 검사할 바이트 수 지정, 빠른 검색을 위해서는 사용을 권장   sid 룰 식별자   flow established : 통신이 established 된 패킷만 stateless : 상태 상관없이, 비정상 무작위 공격 대비   rev rule 버전번호로 수정 횟수 표기    IPS(침입방지 시스템) 다양한 보안기술로 침입이 일어나기 전에 실시간으로 침입을 막음\n 트래픽을 차단하기 위한 능동형 보안 솔루션 취약점을 능동적으로 사전에 보완하며 웜이나 버퍼 오버플로우, 비정상적 트래픽, 제로데이 공격까지 차단  필요성  방화벽이나 IDS만으로는 속도 때문에 해킹이나 바이러스, 웜에 대한 공격을 막기 어려움 실시간 침입방지 시스템으로 OS단에서 실시간 방어와 탐지 기능 지원  Firewall, IDS, IPS 비교    구분 Firewall IDS IPS     목적 접근통제 및 인가 침입여부 감지 침입 이전의 방지   특징 수동적 차단내부망 보호 로그ㆍsignature 기반의 패턴 매칭 정책ㆍ규칙기반 비정상 행위 탐지   패킷 차단 O X O   패킷 내용분석 X O O   오용 방지 X O O   오용 차단 X X O   이상 탐지 X O O   이상 차단 X X O   장점 엄격한 접근통제인가된 트래픽만 허용 실시간 탐지사후분석 대응기술 실시간 즉각 대응세션 기반 탐지 가능   단점 내부공격에 취약네트워크 병목현상 변형 패턴에 대해서는 탐지 어려움 오탐 현상 발생 가능장비 고가    ","excerpt":"IDS(침입탐지 시스템) 외부 침입에 대한 정보를 수집하고 분석하여 침입 활동을 탐지해 이에 대응하도록 보안 담당자에게 통보하 …","ref":"/til/security/network/ids-and-ips/","title":"IDS/IPS"},{"body":"개념 셸(Shell)은 커널과 사용자간의 다리역할을 하는 것으로 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행한다. 리눅스에는 sh를 기본으로 ksh와 csh 계열의 장점을 결합한 bash(Bourne Again shell)을 표준으로 한다.\nShell 확인 및 변경 확인 $ echo $SHELL # 사용중인 셸 확인 $ chsh -l # 변경 가능한 셸 확인 $ cat /etc/shells # 위와 동일 변경 $ chsh Password: # 비밀번호 확인 New Shell [/bin/bash]: /bin/zsh # 바꾸고자 하는 셸 입력 셸 환경설정 변수 Shell 변수 특정한 셸(Shell)에서만 적용되는 변수, 변수명=값으로 사용할 수 있으며 변수명 앞에 $를 붙이고 echo 명령으로 변수값을 호출한다.\n환경 변수    변수 설명     HOME 홈 디렉토리   PATH 실행 파일을 찾는 디렉토리   LANG 셸에서 기본으로 지원하는 언어   TERM 로그인한 터미널 종류   PWD 사용자의 현재 작업 디렉토리   SHELL 사용자의 로그인 셸   USER 사용자 이름   DISPLAY X에서 프로그램 실행 시 출력되는 창   PS1 프롬프트 변수   PS2 2차 프롬프트 변수   HOSTNAME 시스템의 호스트명   MAIL 도착한 메일이 저장되는 경로   TMOUT 일정 시간 작업하지 않을 경우 로그아웃시키는 시간   UID 사용자 UID    bash 주요 기능 history 사용자가 입력한 명령어를 확인, !로 대체하여 사용할 수 있다.\n!를 이용한 history 명령\n   명령어 설명     !! 마지막에 사용한 명령 실행   !n n번째로 사용한 명령을 실행   !-n 반대로 n번째 사용한 명령 실행   !문자열 최근 사용한 ‘문자열’로 시작하는 명령   !?문자열? 최근 사용한 ‘문자열’을 포함하는 명령   ^문자열1^문자열2 마지막 명령에서 문자열1을 2로 변경 실행    히스토리 관련 환경변수\n   변수 설명     HISTSIZE 명령의 개수로 이 값 내에서만 검색이 가능   HISTFILESIZE 실질적인 히스토리 파일의 사이즈   HISTFILE 히스토리 파일의 위치를 보여줌   HISTCONTROL 중복되는 명령에 대한 기록 유무   HISTTIMEFORMAT 히스토리 명령 시 출력되는 시간 형식    alias 지정한 명령을 설정해둔 별명을 통해서 호출하는 기능\n$ alias [별명='명령어'] $ unalias 별명 셸 관련 파일 및 디렉토리\n   파일 또는 디렉토리 설명     /etc/profile 시스템 전체에 적용되는 환경변수와 시작관련 프로그램 설정   /etc/bashrc 시스템 전체에 적용되는 alias와 함수 설정   ~/.bash_profile 개인 사용자의 환경 설정과 시작 프로그램 설정 관련 파일   ~/.bashrc 개인 사용자가 정의한 alias와 함수들이 있는 파일   ~/.bash_logout 개인 사용자가 로그아웃할 때 수행하는 설정을 지정   /etc/profile.d 몇몇 응용프로그램들이 시작할 때 필요한 스크립트가 위치    ","excerpt":"개념 셸(Shell)은 커널과 사용자간의 다리역할을 하는 것으로 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행한다. …","ref":"/til/linux/linux-master/shell/","title":"Shell"},{"body":" 광의적 개념  정부, 기업, 개인 간의 전자정보를 통하여 이루어지는 모든 경제활동을 포함한 상거래 전반   협의적 개념  일반 소비자를 대상으로 인터넷이나 통신망을 이용한 상품관련 정보 제공, 협상, 주문 등을 통해 마케팅, 판매활동을 수행하는 것   협의적 개념  일반 소비자를 대상으로 인터넷이나 통신망을 이용한 마케팅, 판매활동을 수행하는 것    정보보호 보안 공격 유형    공격 유형 설명     인증에 대한 공격 N/W를 통해 접근한 사용자가 적절하지 못한 인증을 통해 다른 사용자로 위장하는 것   송ㆍ수신 부인 공격 N/W를 통해 수행한 인증 및 거래 내역 부인   기밀성에 대한 공격 N/W로 전달되는 인증정보 및 주요 거래 정보 유출   무결성에 대한 공격 N/W 도중에 거래 정보등이 변조되는 것    보안 요구사항  전자상거래는 원격의 거래 상대를 신뢰하기 어려우므로 네트워크상에서 상대방 및 자신의 신분 확인 수단이 필요 전자상거래에서 거래 사실의 공증을 보장할 수 있는 신뢰할만한 제 3자의 중재가 필요 전자상거래에서는 전자지불 방식의 안정성을 보장하기 위한 방법이 확보되어야 함  전자화폐 가상공간의 화폐 역할을 수행하는 디지털 데이터로 구성된 화폐\n구성 요소  은행: 전자화폐를 발행하고 결제하는 기관 고객: 전자화폐를 은행으로부터 발급받아 사용하는 주체 상점: 상품을 공급하고 전자화폐를 구매대금으로 받는 자 인증기관: 신분인증, 거래내용 부인방지 등을 위한 기관  거래 단계  구매자와 은행 간에 이루어지는 발행 물건을 사고 상점에 화폐를 지불 전자화폐를 은행에 제출하여 상점의 계좌로 자금을 이체(결제)  요구 조건    요구 조건 설명     디지털 정보화 물리적인 형태에 의존하면 안되며 디지털 데이터 자체로서 완벽한 화폐가치를 가져야 함   재사용 불가능성 복사, 위조 등으로 부정사용 불가능   익명성(추적 불가능성) 이용자의 구매에 관한 익명성이 보호   오프라인성 지불 단계를 오프라인으로 처리 가능   양도성 타인에게 양도가 가능   분할이용 가능성 분할해서 사용 가능   부정 사용자의 익명성 취소 익명성 조절 파라미터에 따라 익명성 취소 가능   이중사용 방지 불법적으로 복사하여 반복적 사용하는 부정한 행위는 검출 가능    보안 요구사항    보안 요구사항 설명     위조불가능 전자화폐는 위조가 불가능해야 함   부인방지 어느 한쪽이 거래사실을 부인하고 있음을 판별할 수 있어야 함   누명면제 전자지불 시스템을 구성하는 구성요소 간에 연합하여 특정 구성요소에게 누명을 씌울 수 없음   무결성 주고받는 메시지가 전송 도중 변경되지 않았음을 확인할 수 있어야 함   인증 송ㆍ수신자가 전자지불 시스템의 합법적인 사용자임을 확인할 수 있어야 함   비밀성/익명성 개인 신상 정보를 보호할 수 있어야 함    SET(Secure Electronic Transaction) 신용카드회사인 비자(VISA)와 마스터카드(MasterCard)가 합동으로 개발\n 신용카드 거래를 네트워크 상에서 안전하게 하기 위한 표준 프로토콜 안전한 대금결제과정 처리를 위해 RSA 암호화와 인증기술을 이용 전자봉투와 이중서명을 통해 민감한 개인금융정보를 안전하게 전송  참여주체  카드소지자: 발행자에 의해서 허가된 지불카드를 사용하는 주체 발행자: 카드소지자의 계정을 만들고 카드를 발급해주는 금융기관  신뢰할만한 거래에 대해 지불을 보장   가맹점: 대금결제를 받는 대가로 상품과 서비스를 제공 지불은행: 상인과 계정을 체결하고 카드결제에 대한 신뢰성과 지불을 담당 지불 게이트웨이: 지불처리 은행 또는 제3자에 의해 운영되는 시스템  상점이 요청한 카드소지자의 지급정보를 이용 해당 금융기관에 승인 및 결제를 요청하는 기존의 카드 지불 N/W 통로   인증기관: SET 참여자에게 공개키 인증서를 발행하는 기관  장단점    장점 단점     전자거래 사기 방지 암호 프로토콜이 너무 복잡함   기존의 신용카드 기반 그대로 활용 RSA는 프로토콜의 속도를 크게 저하   SSL의 단점(상인에게 지불정보 노출) 해결 거래를 위한 별도의 H/W, S/W 필요    이중서명 프로토콜  카드 사용자가 구매정보와 지불정보를 각각 해시 두 해시값을 합한 뒤 다시 해시 이 값을 카드 소유자의 개인키로 암호화하여 이중서명값을 생성  기밀성  지불정보는 은행의 공개키로 암호화하여 상점으로의 기밀성을 보장 주문정보는 상점의 공개키로 암호화하여 은행으로의 기밀성을 보장  ebXML 인터넷 표준 브라우저만으로 장소에 구애 없이 어디서나 전자상거래를 할 수 있으며 구현 비용이 저렴하고, 개방된 네트워크로 전자거래 교환을 위한 국제 표준을 제공\n구성 요소  비즈니스 프로세스: 다양한 비즈니스 거래절차에 대한 내용을 표준화 정의 핵심 컴포넌트: 비즈니스에 교환되는 전자문서의 재사용이 가능하도록 표준화 정의 등록저장소: 거래상대자들에 의해 제출된 정보를 저장하는 안전한 저장소 거래당사자: 비즈니스 거래 당사자에 대한 각종 정보 및 혐업을 위한 프로파일을 통일된 규칙으로 표준화 전송, 교환 및 패키징: ebXML 메시지 서비스를 제공하여 상호운영성과 보안 유지, 메시지를 어떻게 전달할 것인가에 대한 표준 정립  사용 효과  재활용성 비즈니스 프로세스 활용  ","excerpt":" 광의적 개념  정부, 기업, 개인 간의 전자정보를 통하여 이루어지는 모든 경제활동을 포함한 상거래 전반   협의적 개념  일 …","ref":"/til/security/application/e-commerce/","title":"E-Commerce"},{"body":"개요 이벤트 정의 마우스 클릭, 키보드 입력, 이미지나 HTML 문서의 로딩, 타이머의 타임아웃 등 사용자의 입력 행위나 문서나 브라우저의 상태 변화를 자바스크립트 코드에게 알리는 통지\n이벤트 리스너 발생한 이벤트에 대처하기 위해 작성된 자바스크립트 코드\n이벤트 종류  HTML5에서 이벤트는 70여가지 이벤트 리스너의 이름은 이벤트 이름 앞에 on을 붙임  이벤트 리스너 생성 HTML 태그 내에 작성 HTML 태그의 이벤트 리스너 속성에 리스너 코드 직접 작성\n\u003cp onmouseover=\"this.style.backgroundColor='orchid'\" onmouseout=\"this.style.backgroundColor='white'\"\u003e\r마우스 올리면 orchid 색으로 변경\r\u003c/p\u003e\rDOM 객체 프로퍼티에 작성 DOM 객체의 이벤트 리스너 프로퍼티에 이벤트 리스너 코드 작성\nfunction over() { // onmouseover 리스너로 사용할 함수 ... } var p = document.getElementById(\"p\"); p.onmouseover = over; DOM 객체 addEventListener() 메소드  addEventListener() 사용의 차별점  removeEventListener() 이용 제거 가능 동일한 이벤트 리스너에 여러 함수를 중복 등록 가능    var p; function init() { // 문서가 완전히 로드되었을 때 호출 p = document.getElementById(\"p\"); p.addEventListener(\"mouseover\", over); // 이벤트 리스너 등록 p.addEventListener(\"mouseout\", out); // 이벤트 리스너 등록 } function over() { p.style.backgroundColor=\"orchid\"; } function out() { p.style.backgroundColor=\"white\"; } 익명 함수로 이벤트 리스너 작성 p.onmouseover = function () { this.style.backgroundColor = \"orchid\"; }; // 익명 함수 p.addEventListener(\"mouseover\", function () { this.style.backgroundColor = \"orchid\"; } // 익명 함수 );  익명 함수(anonymous function): 함수 이름 없이 함수 바로 작성 코드가 짧거나 한 곳에서만 사용하는 경우, 익명 함수 편리\n 이벤트 객체  발생한 이벤트에 관련된 다양한 정보를 담은 객체 이벤트가 처리되고 나면 이벤트 객체 소멸  이벤트 객체 전달받기 이벤트 객체는 이벤트 리스너 함수의 첫 번째 매개변수에 전달\n이름을 가진 이벤트 리스너 function f(e) { // 매개변수 e에 이벤트 객체 전달받음 ... } obj.onclick = f; // obj 객체의 onclick 리스너로 함수 f 등록 익명 함수의 경우 obj.onclick = function(e) { // 매개변수 e에 이벤트 객체 전달받음 ... } HTML 태그에 이벤트 리스너 event 라는 이름으로 전달\nfunction f(e) { ... } ... \u003cbutton onclick=“f(event)”\u003e버튼\u003c/button\u003e \u003cdiv onclick=“alert(event.type)”\u003e버튼\u003c/div\u003e 이벤트 객체에 들어 있는 정보  현재 발생한 이벤트에 관한 다양한 정보  이벤트 객체의 프로퍼티와 메소드로 알 수 있음   이벤트의 종류마다 조금씩 다름  이벤트 객체의 공통 멤버    멤버 설명     type 현재 발생한 이벤트의 종류를 나타내는 문자 (clickm load 등)   target 이벤트를 발생시킨 객체 (DOM 객체 혹은 HTML 태그)   currentTarget 현재 이벤트 리스너를 실행하고 있는 DOM 객체   defaultPrevented 이벤트의 디폴트 행동이 취소되었는지 나타냄(true/false)   preventDefault() 이벤트의 디폴트 행동을 취소시키는 메소드       target 프로퍼티  이벤트 타겟 객체 가리킴 이벤트 타겟 : 이벤트를 유발시킨 DOM 객체    preventDefault() 이벤트 디폴트 행동 취소\n 이벤트 디폴트 행동: 특정 이벤트에 대한 HTML 태그의 기본 행동\n \u003ca href=\"http://www.naver.com\" onclick=\"event.preventDefault();\"\u003e\r이동 안되는 링크\r\u003c/a\u003e\r이벤트 흐름 이벤트가 발생하면 window 객체에 먼저 도달하고, DOM 트리를 따라 이벤트 타겟에 도착하고, 다시 반대 방향으로 흘러 window 객체에 도달한 다음 사라지는 과정\n이벤트가 흘러가는 과정  캡쳐 단계(capturing phase)  이벤트가 window 객체에서 중간의 모든 DOM 객체를 거쳐 타겟 객체에 전달되는 과정 이벤트가 거쳐가는 모든 DOM 객체(window포함)의 이벤트 리스너 실행   버블 단계(bubbling phase)  이벤트가 타겟에서 중간의 모든 DOM 객체를 거쳐 window 객체에 전달되는 과정 이벤트가 거쳐가는 모든 DOM 객체(window포함)의 이벤트 리스너 실행    캡쳐 리스너와 버블 리스너 등록 addEventListener()의 3 번째 매개 변수 이용\n true이면 캡쳐 리스너, false이면 버블 리스너\n var b = document.getElementById(\"button\"); b.addEventListener(\"click\", capFunc, true); // 캡쳐 단계에서 capFunc() 실행 b.addEventListener(\"click\", bubbleFunc, false); // 버블 단계에서 bubbleFunc() 실행 이벤트 흐름 중단 이벤트 객체의 stopPropagation() 호출\n마우스 핸들링 마우스 이벤트 객체 프로퍼티    프로퍼티 설명     x, y (x, y)는 타겟 객체의 부모 객체 내에서의 마우스 좌표   clientX, clientY (clientX, clientY)는 브라우저 윈도우의 문서출력 영역 내에서의 마우스의 좌표   screenX, screenY (screenX, screenY)는 스크린을 기준으로 한 마우스 좌표   offsetX, offsetY (offsetX, offsetY)는 타겟 객체 내에서의 마우스 좌표   button 0: 아무 버튼도 눌러지지 않았음 1: 왼쪽 버튼이 눌러졌음 2: 오른쪽 버튼이 눌러졌음 3: 왼쪽, 오른쪽 버튼이 모두 눌러졌음 4: 중간 버튼이 눌러졌음   wheelDelta 양수: 위쪽으로 굴린 경우 음수: 아래쪽으로 굴린 경우    마우스 이벤트  onclick  HTML 태그 클릭될 때   ondblclick  HTML 태그가 더블클릭될 때   onmousedown/up  마우스 버튼을 누르는(놓는) 순간   onmouseover/out  마우스가 태그 위로 올라가는(떠나는) 순간 자식 영역 포함   onmouseenter/leave  마우스가 태그 위로 올라가는(떠나는) 순간   onwheel  HTML 태그에 마우스 휠이 구르는 동안 계속 호출    obj.onwheel = function (e) { if(e.wheelDelta \u003c 0) { // 아래쪽으로 휠을 굴린 경우  ... } else { // 위쪽으로 휠을 굴린 경우  ... } }; oncontextmenu document.oncontextmenu = function () { ... return false; // 컨텍스트 메뉴 출력 금지 }  HTML 태그 위에 마우스 오른쪽 버튼 클릭 디폴트로 컨텍스트 메뉴 출력 oncontextmenu 리스너에 false 리턴하면 디폴트 행동 취소  load 문서의 로딩  window 객체에서 onload 발생  웹 페이지 로딩 완료시 호출되는 이벤트 리스너   onload 리스너 작성 방법  window.onload=\"alert('onload');\"; \u003cbody onload=\"alert('onload');\"\u003e\r 같은 표현, \u003cbody\u003e에 onload를 단 window 객체에 load 이벤트가 전달됨 document.onload는 최근에 와서 많은 브라우저에서 작동하지 않음\n 이미지 로딩 Image 객체  \u003cimg\u003e 태그에 의해 생성되는 DOM 객체 new Image(); 자바스크립트 코드에 의해 생성되는 객체  onload  이미지의 로딩이 완료되면 Image객체에 발생하는 이벤트  새로운 이미지 로딩 var myImg = document.getElementById(\"myImg\"); myImg.onload = function () { // 이미지 로딩 완료 시 실행 var width = myImg.width; // 정확한 이미지 폭 읽기 } myImg.src = \"banana.png\"; // 이미지 로딩 지시 이미지 객체 생성 var bananaImg = new Image(); // 이미지 객체 생성 bananaImg.src = \"banana.png\"; // 이미지 로딩 폼과 이벤트 활용  포커스  포커스는 현재 키 입력에 대한 독점권 브라우저는 포커스를 가지고 있는 HTML 태그 요소에 키 공급   onblur  포커스를 잃을 때 발생하는 이벤트 리스너   onfocus  포커스를 잃을 때 발생하는 이벤트 리스너    라디오버튼과 체크박스 라디오버튼 \u003cinput type=\"radio\"\u003e로 만들어진 라디오 버튼 DOM 객체\n\u003cform\u003e \u003cinput type=\"radio\" name=\"city\" value=\"seoul\"\u003e서울 \u003cinput type=\"radio\" name=\"city\" value=\"busan\"\u003e부산 \u003cinput type=\"radio\" name=\"city\" value=\"chunchen\"\u003e춘천 \u003c/form\u003e  라디오 버튼 객체들 알아내기 –\u003e 그 그룹의 Name으로\n 체크박스 \u003cinput type=\"checkbox\"\u003e로 만들어진 체크박스 DOM 객체\nselect 객체와 onchange  select 객체는 select 태그로 만들어진 콤보박스 option 객체는 option 태그로 표현되는 옵션 아이템  \u003cselect id=\"fruits\"\u003e \u003coption value=\"1\"\u003e딸기\u003c/option\u003e \u003coption value=\"2\" selected\u003e바나나\u003c/option\u003e \u003coption value=\"3\"\u003e사과\u003c/option\u003e \u003c/select\u003e 선택된 옵션 알아내기\nvar sel = document.getElementById(\"fruits\"); var index = sel.selectedIndex; // index는 선택 상태의 옵션 인덱스 옵션 선택\nsel.selectedIndex = 2; // 3번째 옵션 “사과” 선택 sel.options[2].selected = true; // 3번째 옵션 “사과” 선택 select와 onchange 리스너 선택된 옵션이 변경되면 select 객체의 onchange 리스너 호출\n\u003cselect id=\"fruits\" onchange=\"drawImage()\"\u003e...\u003c/select\u003e 키 이벤트 onkeydown, onkeypress, onkeyup   onkeydown\n 키가 눌러지는 순간 호출. 모든 키에 대해 작동    onkeypress\n 문자 키와 Enter, Space, Esc 키에 대해서만 눌러지는 순간에 추가 호출 문자 키가 아닌 경우(F1, Shift, PgDn, Del, Ins 등) 호출되지 않음    onkeyup\n 눌러진 키가 떼어지는 순간 호출    onreset과 onsubmit   onreset\n reset 버튼(\u003cinput type=\"reset\"\u003e) 클릭 시 false를 리턴하면 폼이 초기화되지 않음    onsubmit\n submit(\u003cinput type=\"submit\"\u003e) 버튼 클릭 시 false를 리턴하면 폼 전송하지 않음    리스너 작성\n onreset과 onsubmit 리스너는 form 태그에 달아야 한다    \u003cform onreset=\"...\" onsubmit=\"...\"\u003e    프로퍼티 설명 r/w     keyCode 입력된 키의 유니코드 값 r   altKey Alt 키가 눌러진 상태이면 true r   altLeft 왼쪽 Alt 키가 눌러진 상태이면 true r   ctrlKey ctrl 키가 눌러진 상태이면 true r   ctrlLeft 왼쪽 ctrl 키가 눌러진 상태이면 true r   shiftKey shift 키가 눌러진 상태이면 true r   shiftLeft 왼쪽 shift 키가 눌러진 상태이면 true r    ","excerpt":"개요 이벤트 정의 마우스 클릭, 키보드 입력, 이미지나 HTML 문서의 로딩, 타이머의 타임아웃 등 사용자의 입력 행위나 문서 …","ref":"/til/javascript/event/","title":"Event"},{"body":"사설 네트워크를 외부로부터 보호하기 위해 공중 네트워크와 사설 네트워크 사이에 설치된 일종의 벽\n 보안정책에 따라 인가된 N/W 서비스에 대한 접근 허용, 인가되지 않은 트래픽 차단  Deny All: 모든 트래픽을 차단하고 허용해야 할 트래픽만 선별적 허용(가용성\u003c보안성) Permit All: 모든 트래픽을 허용하고 차단해야 할 트래픽만 선별적 차단(가용성\u003e보안성)   접근통제목록(ACL, Access Control List)에 따라 보안정책 설정 서비스 제어, 방향 제어, 사용자 제어, 행위 제어 수행     장점 단점     취약한 서비스 보호호스트 시스템 접근제어 기능로그와 통계자료 유지내부 네트워크에 대한 일괄적인 보안 정책 적용 가능 제한된 서비스 우회 트래픽 제어 불가내부 사용자의 공격 방어 어려움제로데이 공격에 취약    유형 패킷 필터링 수신된 패킷의 TCP/IP 헤더 부분만을 이용해서 침입 차단 기능을 수행하는 수동적인 침입차단 프로그램\n 일반적인 라우터에 패킷 필터링 기능을 구현한 것을 스크리닝 라우터(또는 패킷 필터링 라우터)라고 부른다.\n    장점 단점     확장 가능높은 효율성응용 프로그램에 독립적 패킷에서 헤더정보 외에는 조사 X상대적으로 낮은 보안연결 상태 추적 X    NAT(Network Address Translation) 사설 주소와 범용주소의 매핑 제공하며 동시에 가상 사설 네트워크를 지원하는 기술\n 적은 수의 공인 IP주소로 많은 시스템이 인터넷에 접속 가능하게 함 외부 네트워크에서 내부 네트워크 IP주소를 알 수 없으므로 보안성 효과 구분  Static NAT  내부 IP 주소와 외부 IP 주소의 1:1 매핑   Dynamic NAT  여러 개의 내부 IP 주소와 여러 개의 외부 IP 주소의 동적 매핑   PAT(Port Address Translation)  변환 테이블에 송/수신 포트번호와 프로토콜을 포함      스테이트풀 패킷 검사 패킷 필터링과 동일한 패킷 정보를 조사하지만 TCP 연결에 관한 정보를 기록\n TCP 시퀀스넘버를 추적해서 시퀀스넘버를 이용한 세션하이재킹 같은 공격을 방어 통신 채널을 추적하는 상태 테이블을 관리     장점 단점     패킷 상태에 대한 보안성 높임전체 계층에 대해 상태 조사, 사용자 설정없이 투명성 제공 연결요청의 첫 헤더 공격에 잘못된 상태테이블 구성 가능    작동 원리  데이터 링크 계층에서 SYN 패킷을 전송받으면 접근제어 정책에 의해 상태 테이블에 남겨 접근 허용여부를 결정 접근이 금지된 패킷일 경우 로그를 저장하고 전송을 수행하지 않고, 접근이 허용된 패킷은 네트워크 계층으로 전송 SYN 패킷이 아닐 경우 상태 테이블의 패킷 정보 여부를 검사하고 존재하면 전송, 존재하지 않으면 접근제어 정책에 따라 전송여부를 결정  프록시 침입차단 시스템 호스트에서 실행되는 전문화된 애플리케이션이나 서버 프로그램으로서 배스천 호스트에 설치되어 운영\n침입차단 S/W가 설치되어 내ㆍ외부 네트워크 사이에서 게이트웨이 역할을 수행하며 철저한 보안 방어 기능이 구축되어 있는 시스템\n 설계 및 구축  가능한 한 단순하게 구성하여 호스트 보안 정책을 쉽게 구성 배스천 호스트의 손상에 대비한 대비책을 강구 시스템 로그에 대한 백업 방법을 강구   장점  스크리닝 라우터 방식보다 안전 각종 기록 정보 생성 및 관리가 쉬움   단점  배스천 호스트가 손상되면 내부 네트워크를 보호할 수 없음 로그인 정보가 유출되면 내부 네트워크를 보호할 수 없음    응용 계층 게이트웨이(Application-Level Proxy) 응용 서비스마다 각기 다른 응용 게이트웨이를 구현하여 패킷을 응용프로그램 계층까지 검사\n   장점 단점     응용 서비스 사용에 따른 기록 및 감사 추적이 가능하고 강력한 인증 서비스 제공 높은 대역폭 혹은 실시간 응용프로그램에 일반적으로 적합하지 않음새로운 네트워크 응용 프로그램과 프로토콜 지원에 제한적응용서비스별 별도의 프락시 서버가 필요    회선 레벨 게이트웨이(Circuit-Level gateway) 외부와 내부 네트워크 사이에 안전한 프록시 데이터 채널을 설정하기 위해서 매커니즘을 구축\n SOCKS 프로토콜을 사용  SOCKS: 클라이언트-서버 환경에서 이용되는 프락시 접속 프로토콜   내부 네트워크의 호스트 보호를 목적 응용 트래픽 조사 X  응용 게이트웨이 방화벽보다 처리속도 빠름 응용 서비스를 사용하는 공격에 취약    종류 스크리닝 라우터 구조 라우터를 이용해 인터페이스에 들어오고 나가는 패킷 필터링\n   장점 단점     구조간단, 장비 추가비용 없음네트워크 계층에서 동작, 클라이언트-서버 변화 없음보호하고자 하는 전체 N/W에 동일한 보호가 가능 세부적인 규칙 적용이 어려움인증기능 수행 불가. 내부구조를 숨기기 어려움실패한 접속에 대한 로깅지원 X, 패킷필터링 규칙검증 어려움    이중 네트워크 호스트 구조  2개의 인터페이스를 가지는 장비로 하나는 외부 N/W, 하나는 내부 N/W와 연결 N/W의 모든 패킷을 검사하기 때문에 상당히 높은 성능의 시스템이 요구되며 소규모 N/W에 적합     장점 단점     스크리닝 라우터보다 안전관리, 설치, 유지보수 용이내부 네트워크를 숨길 수 있음 서비스 증가 시 프록시 S/W 가격 상승사용자 정보 입력 필요배스천호스트 손상, 로그인 정보 유출 시 네트워크 보호 불가    스크린드 호스트 게이트웨이 구조  이중 네트워크 호스트 + 스크리닝 라우터 내부 네트워크에 놓여 있는 배스천호스트와 외부 네트워크 사이에 스크리닝 라우터로 구성     장점 단점     다른 방화벽에 있는 모든 장점 + 융통성네트워크 계층과 응용 계층에서 방어(2단계 방어) 느린 서버 속도배스천호스트 침해 시 내부 네트워크를 보호할 수 없음스크리닝 라우터의 라우팅 테이블 변경 시 내부 네트워크 방어 불가     스크리닝 라우터의 라우팅 테이블이 변경되면 외부 트래픽이 배스천호스트로 입력되지 않고 곧바로 내부 네트워크로 진입되므로 내부자 공격에 취약하다.\n 스크린드 서브넷 구조  스크리닝 라우터 + 이중 네트워크 호스트 + 스크리닝 라우터 인터넷과 내부 네트워크 사이에 DMZ(Demilitarized Zone)라는 서브넷을 운영 외부에서 접속할 수 있어야 하며 보호되어야 할 시스템은 주로 DMZ 네트워크에 배치     장점 단점     DMZ와 같은 보안층을 가지고 있어 매우 안전다른 방화벽에 있는 모든 장점을 포함, 융통성 또한 뛰어남 낮은 서비스 속도다른 방화벽에 있는 모든 장점을 포함, 융통성 또한 뛰어남    iptables 리눅스 커널에 내장된 rule 기반의 패킷 필터링 기능\n 상태 추적 NAT 기능 패킷 레벨에서의 로깅 기능 확장 모듈을 통한 다양한 기능  $ iptables [table] [chain] [rule] [target] 테이블 지정\n   옵션 설명     -t filter(default값), nat    룰을 설정할 체인 지정\n   옵션 설명     -A append 모드. 해당 체인의 제일 마지막에 룰을 추가   -I insert 모드. 해당 체인의 첫 행에 룰을 추가. 행 번호 지정 시 특정 행에 룰을 추가   -D delete 모드. 행 번호를 지정하여 특정 위치의 룰을 삭제   -F flush 모드. 해당 체인의 모든 룰을 삭제   -P 해당 체인의 default 정책 설정     filter 테이블의 체인에는 INPUT, OUTPUT, FORWARD 체인이 있다.\n 룰 설정\n   옵션 설명     -p 프로토콜 지정   -s 출발지 IP 지정   -d 목적지 IP 지정   –sport 출발지 Port 지정   –dport 목적지 Port 지정   -i 패킷이 들어오는 인터페이스 지정   -o 패킷이 나가는 인터페이스 지정    타겟 지정\n   옵션 설명     -j 룰에 매칭될 때 적용할 정책 또는 타겟 체인을 지정     정책에는 ACCEPT(허용), DROP(차단, 응답 없음), REJECT(차단, 응답), LOG(로깅)이 있다.\n ","excerpt":"사설 네트워크를 외부로부터 보호하기 위해 공중 네트워크와 사설 네트워크 사이에 설치된 일종의 벽\n 보안정책에 따라 인가된 N/ …","ref":"/til/security/network/firewall/","title":"Firewall"},{"body":"공개키 암호 및 전자서명의 기술을 사회적인 기반구조로 만들어 가는 것\n 공개키 알고리즘을 위한 키 관리 구조 제공 서비스  기밀성, 무결성, 인증, 부인방지, 접근제어    구성요소 크게 인증기관, 검증기관, 등록기관, 저장소, 사용자로 구성\n인증기관(CA, Certification Authority) 정책승인기관(PAA, Policy Approving Authority)  루트 인증기관으로, PKI 전반의 정책을 생성 및 수립 하위 기관들의 정책 준수 상태 및 적정성 감사  정책인증기관(PCA, Policy Certification Authority)  PAA 하위 계층 도메인 내의 사용자와 CA의 정책 수립 인증서, 인증서 폐지 목록 등 관리  인증기관(CA)  PCA 아래 계층으로 인증 정책 수립 사용자/등록기관의 요청에 공개키 인증서 발행 및 폐지 사용자에게 자신의 공개키와 상위 기관을 공개키 전달 PA요청에 의해 인증서 발급  검증기관(VA, Validation Authority)  인증서의 유효성 여부, 관련 거래의 유효성 여부 등 확인 VA가 없다면 안정성이 떨어짐 CA에서 직접 운영 가능  등록기관(RA, Registration Authority)  사용자와 CA가 원거리에 있는 경우 CA 대신 사용자의 신분/소속 등 확인 선택적 요소  형태 계층 구조  최상위에 루트 CA가 존재하고 그 밑으로 하위 CA가 계층적으로 존재 상위 CA가 하위 CA에 인증서를 발행하고, 하위 CA는 상위 CA의 인증정책에 영향 루트 CA 간에 상호인증은 허용, 하위 CA 간에 상호인증은 불가능 인증경로 탐색이 용이하고, 모든 사용자가 최상위 CA의 공개키를 알고 있어서 검증이 용이 최상위 CA에 집중되는 오버헤드가 발생 최상위 CA의 비밀키 노출이 되면 피해 막대  네트워크 구조  각각의 CA들이 자신의 인증정책에 따라 독립적으로 존재 모든 상호인증이 허용되면 상호인증 수 대폭 증가 유연하고 인증경로가 단순하여 실직적인 업무관계에 적합 CA의 비밀키가 노출되어도 피해가 적음 인증경로 탐색이 복잡 정책 수립과 적용이 어려움  공개키 인증서 해당 키가 특정인의 것임을 보증해주는 것\n 표준화된 양식으로 믿을 수 있는 제 3자가 발행하며 PKI의 근간 개인정보와 그 사람의 공개키가 기재되며 CA의 개인키로 서명됨  인증서 표준 규격(X.509)  인증서 표준 규격 IP Security, SSL, 안전한 전자거래(SET)와 S/MIME 같은 네트워크 보안 응용에 사용     요소 구분 설명     버전 (Version) 필수 X.509의 버전   일렬번호 (Serial Number) 필수 CA에 의해 인증서에 부여되는 유일한 번호. (발행자이름과 일렬번호로 인증서를 유일하게 구분할 수 있어야 한다.)   서명 알고리즘 식별자 (Signature Algorithm ID) 필수 CA가 인증서를 서명하기 위한 알고리즘과 알고리즘 식별자를 포함. 이 정보는 끝부분 서명 필드에도 포함되어 있다.   발행자 이름 (Issuer name) 필수 인증서 발행자(보통 CA)의 이름   유효기간 (Validity period) 필수 인증서 유효기간의 시작날짜와 종료날짜   주체 이름 (Subject name) 필수 사용자(피발급자)의 이름 상위 CA가 하위 CA에게 인증서를 발행하는 경우 이 필드에는 CA의 이름이 된다.   주체의 공개키 정보 (Subject Public Key) 필수 사용자의 공개키, 관련 알고리즘   발행자 유일 식별자 (Issuer Unique ID) 선택(v2) 발행자나 사용자의 이름이 중복되는 경우 이를 구별하기 위한 수단   주체 유일 식별자 (Subject Unique ID) 선택(v2) 주체를 유일하게 구별하는 데 사용   확장 (Extensions) 선택(v3) 발행자가 인증서에 추가적으로 사적인 정보를 넣을 수 있는 필드   서명 (Signature) 필수 인증서에 대한 서명 값이 들어있는 필드 나머지 전체 필드를 보호하는 역할을 한다. 다른 필드 전체를 해시해서 나온 해시 값을 CA의 개인키로 암호화한 값이 들어간다.     확장 영역에는 키와 정책 정보, 사용자와 발행자 속성, 인증 경로 제약조건이 들어간다.\n X.509 인증서 폐지 목록 프로파일 페지 사유  사용자의 개인키가 노출되거나 훼손된 것으로 판단될 때 CA가 사용자를 더 이상 인증해줄 수 없을 때 CA의 개인키가 노출되었거나 훼손된 것으로 판단될 때  폐지 목록(CRL, Certificate Revocation List)  신뢰 당사자가 언제든지 이 목록을 검색할 수 있어야 함 폐기된 인증서들은 일련번호에 의해서 확인 가능  운영 프로토콜 온라인 인증서 상태 검증 프로토콜(OCSP, Online Certificate Status Protocol)  실시간으로 인증서 상태 확인 가능 백그라운드에서 자동 수행 CA에 의해 관리되는 CRL을 검사  인증서 관리 프로토콜(CMP, Certificate Management Protocol)  PKI 환경에서 인증서 관리 서비스를 제공하기 위한 PKI 실체들 간 통신 프로토콜  PKI 실체: 이용자, 인증기관, 등록기관, 인증서 저장소 등    ","excerpt":"공개키 암호 및 전자서명의 기술을 사회적인 기반구조로 만들어 가는 것\n 공개키 알고리즘을 위한 키 관리 구조 제공 서비스  기 …","ref":"/til/security/cryptology/pki/","title":"PKI(Public Key Infrastructure)"},{"body":"프로세스 하드디스크에 설치된 프로그램을 실행하면 메모리에 상주한다. 이렇게 실행중인 프로그램을 프로세스(Process)라 하는데, 실행 시 PID(Process Identity)가 부여된다.\n생성 하나의 프로세스에서 다른 프로세스를 실행하기 위한 시스템 호출방법에는 fork와 exec가 있다.\n fork: 새로운 메모리를 할당받아 기존 프로세스를 복사한 코드를 기반으로 실행 exec: 기존 프로세스 메모리에 새로운 프로세스 코드를 덮어씌워서 실행   모든 프로세스는 리눅스 부팅 시 실행되는 init을 fork한 것이다.\n 종류 Foreground 보통 셸에서 명령을 실행하면 해당 프로세스가 종료될 때까지 기다려야 한다. 이러한 방식의 프로세스를 포어그라운드(Foreground)라 한다.\nBackground 셸에서 보이지 않는 작업으로 다중 작업에 적합하다.\n멀티태스킹 백그라운드 프로세스로 전환  [CTRL]+[z]를 눌러서 포어그라운드 프로세스를 대기 상태로 bg 명령을 통해서 백그라운드 프로세스로 전환  포어그라운드 프로세스로 전환  jobs 명령어로 현재 백그라운상의 프로세스들을 확인 fg %작업번호 혹은 fg 작업번호로 원하는 작업을 전환 작업번호를 지정하지 않을 시 주로 처리되고 있는 프로세스를 포어그라운드로 전환   주로 처리되는 작업은 jobs 실행시 +로 표기된다.\n 통신 시그널  프로세스 간의 통신에 사용 사용자가 인터럽트 키를 통한 발생하는 시그널, 프로세스가 발생하는 시그널, 하드웨어가 발생하는 시그널 등이 있다. kill -l로 시그널의 목록을 확인할 수 있다.  일반적으로 사용하는 시그널\n   번호 이름 설명     1 SIGHUP(HUP) 터미널에서 접속이 끊겼을 때 보내짐   2 SIGINT(INT) 키보드에서 오는 인터럽트 시그널로 실행 중지, [CTRL]+[C]   3 SIGQUIT(QUIT) 키보드에서 오는 실행 중지 시그널, [CTRL]+[￦]   9 SIGKILL(KILL) 프로세스 강제 종료   15 SIGTERM(TERM) 정상 종료, kill명령의 기본 시그널   18 SIGCONT(CONT) 정지된 프로세스를 Continue   19 SIGSTOP(STOP) 터미널에서 입력된 정지 시그널   20 SIGTSTP(TSTP) 실행 정지 후 다시 실행하기 위해 대기시키는 시그널, [CTRL]+[Z]    데몬 주기적으로 지속적인 서비스 요청을 처리하기 위해서 계속 실행되는 프로세스로 백그라운드에서 처리된다.\n 보통 데몬 방식의 서버 프로그램에는 뒤에 d를 붙인다\n standalone 부팅 시에 실행되어 해당 프로세스가 메모리에 계속 상주하면서 클라이언트의 서비스 요청을 처리\ninet 클라이언트의 서비스 요청이 들어왔을 때 관련 프로세스를 실행하고 접속이 종료되면 자동으로 프로세스가 종료됨\n inetd 혹은 xinetd가 이러한 서비스를 관리함\n 유틸리티 관련 명령어 ps 동작 중인 프로세스의 상태를 출력한다. ps의 옵션은 운영체제 계열에 따라 나뉜다.\n 보통 System-V에서는 -를 옵션에 붙여쓰지 않고, BSD 계열은 사용한다.\n $ ps [option] $ ps aux # 시스템에 동작 중인 모든 프로세스를 소유자 정보와 함께 출력 주요 옵션\n   옵션 설명     a 터미널과 연관된 프로세스를 출력(BSD)   u 프로세스 소유자를 기준으로 출력(BSD)   x 터미널에 종속되지 않는 프로세스를 출력(BSD)   l 프로세스 정보를 길게 출력   e 해당 프로세스에 관련된 환경변수 정보 출력   f 프로세스간의 상속관계를 트리구조로 표현   p 특정 PID를 지정할 때 사용(BSD)   -A 모든 프로세스를 출력(System-V)   -e 모든 프로세스를 출력   -a 터미널에 종속되지 않은 프로세스 출력(세션 리더 제외)   -f 유닉스 스타일로 출력(UID, PID, PPID 등 표시)   -C process 지정한 프로세스만   -o value 출력 포맷을 지정   -p 특정 PID를 지정(System-V)   -u 특정 사용자 프로세스 정보 확인    - 프로세스 상태코드\n   값 설명     R 실행 중이거나 실행가능   S 인터럽트에 의한 sleep 상태, 특정 이벤트가 끝나길 기다림   D 디스크 I/O에 의해 대기중   T 정지 상태(suspend)   W 페이징 상태(2.6 이후로 사용X)   Z 좀비 상태, 사용 종료되었으나 부모 프로세스로부터 회수X   X 죽어있는 상태   \u003c 우선순위가 인위적으로 높아진 상태   N 다른 사용자에 의해 인위적으로 우선순위가 낮아짐   L 메모리 안에서 페이지가 잠금된 상태    pstree 프로세스 상태를 트리 구조로 출력해준다.\n$ pstree [option] 주요 옵션\n   옵션 설명     -a 각 프로세스의 명령행 인자까지 표시   -h 현재 프로세스와 이것의 조상을 하이라이트로 강조   -n PID 값으로 정렬   -p PID 값을 같이 표시    top 동작 중인 프로세스의 상태를 실시간으로 화면에 출력해준다. 프로세스의 상태뿐만 아니라 CPU, 메모리, 부하 상태도 확인이 가능하다\n$ top [option] 주요 옵션\n   옵션 설명     -d 갱신시간 갱신 시간을 설정(단위:s)   -p 특정 PID의 프로세스를 모니터링하기 위해 사용    kill 프로세스에 특정한 시그널을 보내는 명령으로 옵션 없이 실행하면 프로세스 종료 신호를 보낸다.\nkillall 같은 데몬의 여러 프로세스를 한 번에 종료\n$ kill [option] [signal] [PID or %Job_number] $ kill -9 765 # PID가 765인 프로세스를 강제 종료 $ killall [option] [process_name] $ killall -HUP httpd # httpd 프로세스 재시작  시그널 종류 참조\n 주요 옵션\n   옵션 설명     -l 시그널의 종류를 출력   -s signal 시그널의 이름을 지정    jobs 백그라운드로 실행 중인 프로세스나 현재 중지된 프로세스 목록을 출력\n$ jobs -l # PID를 추가로 출력 fg 백그라운드 프로세스를 포어그라운드 프로세스로 전환하는 명령\nbg 포어그라운드 프로세스를 백그라운드 프로세스로 전환하는 명령 \u003e 포어그라운드 프로세스를 [CTRL]+[Z]로 일시 중지시킨 뒤 bg명령을 사용\n$ fg [(%)Job_number] $ bg nice 프로세스 우선순위를 변경하는 명령\n NI값을 설정하여 사용한다 기본 값 = 0 지정 가능 범위(-20~19)  $ nice [option] process_name $ nice --10 bash # bash의 NI값을 10만큼 감소시켜서 우선순위를 높인다. renice nice와 동일하게 프로세스 우선순위를 변경한다.\n PID를 사용 NI값을 지정할 수 있음  $ renice [option] NI값 PID 주요 옵션\n   옵션 설명     -u 사용자 이름을 지정   -g 프로세스의 그룹 ID를 지정    nohup 사용자가 로그아웃하거나 작업 중인 터미널 창이 닫혀도 실행 중인 프로세스를 백그라운드에서 실행할 수 있도록 한다.\n$ nohup 명령 스케줄링 특정한 시간에 특정한 작업을 수행하게 하는 것으로 리눅스에서는 at과 cron을 사용한다. at은 주로 한 번만 실행할 때 사용하고, cron은 주기적으로 실행할 때 사용한다.\ncron root권한으로 /etc/crontab에 등록\n 시스템 운영에 필요한 작업에 사용\n crontab 파일 필드\n   필드 설명     minute 분 설정(0~59)   hour 시간 설정(0~23)   day of month 날 설정(1~31)   month 월 설정(1~12)   day of week 요일 설정(0~7)   user-name 사용자 이름(생략가능)   command 실행할 명령어 기입    필드 값으로 사용가능한 기호\n *: 모든(all) -: 연결된 설정 값 지정 ,: 연결되지 않은 설정 값 지정 /: 주기 설정  $ crontab [option] file  사용자의 필요에 의한 작업일 때 사용\n 주요 옵션\n   옵션 설명     -l crontab에 설정된 내용 출력   -e crontab 내용을 작성하거나 수정   -r crontab 내용 삭제   -u root 사용자가 다른 사용자의 crontab 접근    ","excerpt":"프로세스 하드디스크에 설치된 프로그램을 실행하면 메모리에 상주한다. 이렇게 실행중인 프로그램을 프로세스(Process)라 하는 …","ref":"/til/linux/linux-master/process-management/","title":"Process Management"},{"body":"정적 파일이란? 웹 사이트를 구성하는 html, css, script, image 파일 등을 의미하는데 보통 장고에서는 정적 파일은 html을 제외한 css, js, image 파일을 말한다.\ndjango 정적 파일 유형 장고에서 정적파일을 사용하는 방법에는 두 가지가 존재한다.\n static - 페이지에서 사용하는 기본적인 파일 media - 유저가 서비스를 이용하는 중에 발생하는 파일  풀어서 설명하면 개발단계에서부터 정의되는 파일들이 static이고, 개발자가 아닌 이용자가 서비스를 이용하는 과정에서 발생하는 데이터(업로드 등)를 바로 media이다.\n정적 파일 사용법 static  STATICFILES_DIRS : 개발 단게에서 사용하는 정적 파일 위치를 나타냄 STATIC_URL : Static 파일에 접근하기 위한 url STATIC_ROOT : 실제 서비스 운영 중에 사용되는 정적 파일 위치를 나타냄  # settings.py STATIC_URL = '/static/' STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'app_name', 'static'), ] STATIC_ROOT = os.path.join(BASE_DIR, 'static') Shell에서 python manage.py collectstatic 명령어 실행\n staticfiles_dirs에서 static_root 경로로 옮김\n media  MEDIA_URL : Media 파일에 접근하기 위한 url MEDIA_ROOT : 업로드되는 파일이 저장되는 위치  # settings.py MEDIA_URL = '/media/' MEDIA_ROOT= os.path.join(BASE_DIR, 'media') # urls.py from django.conf import settings from django.conf.urls.static import static urlpatterns += static('/media/', document_root=settings.MEDIA_ROOT) ","excerpt":"정적 파일이란? 웹 사이트를 구성하는 html, css, script, image 파일 등을 의미하는데 보통 장고에서는 정적  …","ref":"/til/django/study/static-and-media/","title":"Static \u0026 Media"},{"body":" window: 브라우저 윈도우 모양 제어, 새 윈도우 열기/닫기 location: 브라우저 윈도우에 로드한 HTML 페이지의 URL 관리 navigator: 브라우저에 대한 다양한 정보 제공 screen: 브라우저가 실행되고 있는 스크린 장치에 대한 정보 제공 history: 브라우저 윈도우에 로드한 URL 리스트와 히스토리  자바스크립트로 브라우저를 제어하기 위해 지원하는 객체들은 위와 같다.\n 국제 표준이 없기 때문에, 브라우저별로 BOM 객체가 상이\n window  열려 있는 브라우저 윈도우나 탭 윈도우의 속성을 나타내는 객체 브라우저 윈도우나 탭 윈도우마다 별도의 window 객체 생성 window 객체의 생성 브라우저가 새로운 웹 페이지를 로드 \u003ciframe\u003e 태그 당 하나의 window 객체 생성 자바스크립트 코드로 윈도우 열기 시 자바스크립트 코드로 window 객체 접근 window 혹은 window.self 혹은 self 다양한 윈도우 객체의 프로퍼티, 메소드, 이벤트 리스너  윈도우 열기 window.open()\n 윈도우를 새로 열고 웹 페이지 출력 3개의 매개변수를 가진 함수  window.open(sURL, sWindowName, sFeature)  sURL: 윈도우에 출력할 웹 페이지 주소 문자열 sWindowName: 새로 여는 윈도우의 이름 문자열로, 생략 가능 sFeature: 윈도우 모양, 크기 등의 속성들을 표현하는 문자열     윈도우 이름: 개발자가 임의로 정하지만, 지정된 윈도우가 존재  sWindowName    이름 설명     _blank 이름 없는 새 윈도우를 열고, 웹 페이지 로드   _parent 현재 윈도우의 부모 윈도우에 웹 페이지 로드, 부모 없으면 현재 윈도우 이용   _self 현재 윈도우에 웹 페이지 로드   _top 브라우저 윈도우에 웹 페이지 로드    sFeature    속성 설명 속성 값의 종류     width 윈도우의 폭, 픽셀 값 정수   height 윈도우의 높이, 픽셀 값 정수   left 스크린 상의 윈도우 x 좌표, 픽셀 값 정수   right 스크린 상의 윈도우 y 좌표, 픽셀 값 정수   resizable 마우스로 윈도우 크기 조절 가능 여부 yes/no/1/0   location URL 입력 창을 출력하도록 지정 yes/no/1/0   menubar 메뉴바를 출력하도록 지정 yes/no/1/0   scrollbars 수직/수평 스크롤바를 출력하도록 지정 yes/no/1/0   status 윈도우 하단에 상태바를 출력하도록 지정 yes/no/1/0   toolbar 툴바를 출력하도록 지정 yes/no/1/0     yes는 속성을 반영하도록 지시 no가 디폴트이며 0과 같은 값\n 윈도우 닫기 var newWin=null; // 새로 연 윈도우 기억 function load(URL) { newWin = window.open(URL, \"myWin\", \"left=300,top=300,width=400,height=300\"); } function closeNewWindow() { if(newWin==null || newWin.closed) // 윈도우가 열리지 않았거나 닫힌 경우 return; // 윈도우가 없는 경우 그냥 리턴 else newWin.close(); // 열어 놓은 윈도우 닫기 } 타이머 활용 window 객체의 타이머 기능 2가지\n 타임아웃 코드 1회 호출  setTimeout()/clearTimeout()   타임아웃 코드 반복 호출  setInterval()/clearInterval()    setTimeout()/clearTimeout() var timerID = setTimeout(\"timeOutCode\", msec); clearTimeout(timerID); setInterval()/clearInterval() var timerID = setInterval(\"timeOutCode\", msec); clearInterval(timerID); 윈도우 위치 및 크기 조절 윈도우를 오른쪽으로 5픽셀, 아래로 10픽셀 이동\nwindow.moveBy(5, 10); moveBy(5, 10); 윈도우를 스크린의 (25, 10) 위치로 이동\nwindow.moveTo(25, 10); self.moveTo(25, 10); 윈도우 크기를 5 픽셀 좁게, 10픽셀 길게 조절\nwindow.resizeBy(-5, 10); resizeTo(self.outerWidth-5, self.outerHeight+10); 윈도우 크기를 200x300으로 조절\nwindow.resizeTo(200, 300); 웹 페이지 스크롤 웹 페이지를 위로 10픽셀 스크롤(마우스 스크롤 다운)\nwindow.scrollBy(0, 10); // 옆으로 0, 위로 10픽셀 웹 페이지를 왼쪽으로 10픽셀, 아래로 15픽셀 스크롤(마우스 스크롤 업)\nwindow.scrollBy(10, -15); 웹 페이지의 (0, 200) 좌표 부분이 현재 윈도우의 왼쪽 상단 모서리에 출력되도록 스크롤\nwindow.scrollTo(0, 200); location  윈도우에 로드된 웹 페이지의 URL 정보를 나타내는 객체 location 객체로 현재 윈도우에 웹 페이지 열기  window.location = \"http://www.naver.com\"; window.location.href = = \"http://www.naver.com\"; window.location.assign(\"http://www.naver.com\"); window.location.replace(\"http://www.naver.com\");  새 윈도우에 웹 페이지 열기  var win=window.open(); // 빈 윈도우 열기 win.location=\"http://www.naver.com\"; // 네이버 페이지 로드 프로퍼티와 메소드    프로퍼티 설명     hash #을 포함하는 앵커 이름 문자열   host 도메인과 포트 번호를 포함하는 웹 서버 주소 문자열   hostname 웹 서버 이름   href URL 전체 문자열   pathname 디렉터리 부분 문자열   port 포트 번호 문자열   protocol 프로토콜 문자열    search URL에서 ?와 그 뒷부분 문자열로서, 주로 웹 서버로 검색을 요청할 때 동반되는 파라미터 문자열       메소드 설명     assign() 새로운 웹 페이지를 로드한다.   reload() 현재 웹 페이지를 다시 로드한다. 페이지가 수정되었으면 반영한다.   replace() 현재 웹 페이지의 URL을 히스토리에서 제거하고, 새로운 페이지를 로드한다.    navigator  현재 작동중인 브라우저에 대한 다양한 정보를 나타내는 객체 window.navigator 또는 navigator     프로퍼티 설명     appCodeName 브라우저의 코드 이름을 가진 문자열   appName 브라우저 이름 문자열   appVersion 브라우저의 플랫폼과 버전에 관한 문자열   platform 운영체제 플랫폼의 이름   product 브라우저 엔진의 이름   userAgent 브라우저가 웹 서버로 데이터를 전송할 때, HTTP 헤더 속의 user-agent 필드에 저장하는 문자열로서 웹 서버가 클라이언트를 인식하기 위한 목적   vendor 브라우저 제작 회사의 이름 문자열   language 브라우저의 언어를 나타내는 문자열   onLine 브라우저가 현재 온라인 작동중이면 true, 아니면 false   plugins 브라우저에 설치된 플러그인에 대한 컬렉션   cookieEnabled 브라우저에 쿠키를 사용할 수 있는 상태면 true, 아니면 false   geolocation 위치 정보를 제공하는 geolocation 객체에 대한 레퍼런스    screen  브라우저가 실행되는 스크린 장치에 관한 정보를 담고 있는 객체 window.screen 혹은 screen     프로퍼티 설명     availHeight 작업 표시줄 등을 제외하고 브라우저가 출력 가능한 영역의 높이   availWidth 작업 표시줄 등을 제외하고 브라우저가 출력 가능한 영역의 폭   pixelDepth 한 픽셀의 색을 나타내기 위해 사용되는 비트 수   colorDepth 한 픽셀의 색을 나타내기 위해 사용되는 비트 수로, pixelDepth와 동일. 대부분 브라우저에서 지원되므로 pixelDepth보다 이것을 사용하는 것이 권장됨   height 스크린의 수직 픽셀 수   width 스크린의 수평 픽셀 수    history  윈도우에서 방문한 웹 페이지 리스트(히스토리)를 나타내는 객체 Window.history 혹은 history     프로퍼티 설명     length 히스토리 리스트에 있는 엔트리 수       메소드 설명     back() 히스토리에 있는 이전 웹 페이지로 이동. 브라우저의 버튼과 동일   forward() 히스토리에 있는 다음 웹 페이지로 이동. 브라우저의 버튼과 동일   go(n) 히스토리에서 현재 웹 페이지에서 n만큼 상태적인 웹 페이지로 이동    ","excerpt":" window: 브라우저 윈도우 모양 제어, 새 윈도우 열기/닫기 location: 브라우저 윈도우에 로드한 HTML …","ref":"/til/javascript/bom/","title":"Browser Object Model"},{"body":"다양한 디지털 장치에서 범인과 연관된 자료를 발견하고 분석하여 법적인 문제를 해결하는 방법\n 포렌식을 통해 증거획득하고 이 증거가 법적인 효력을 가지려면 그 증거를 발견, 기록, 획득, 보관하는 절차가 필요\n 기본 원리  정당성의 원칙  모든 증거는 적법한 절차를 거쳐서 획득한 것이어야 함   재현의 원칙  똑같은 환경에서 같은 결과가 나오도록 재현할 수 있어야 함   신속성의 원칙  휘발성 정보를 취득하기 위해 신속하게 처리해야 함   연계 보관성의 원칙  증거는 획득된 뒤 이송/분석/보관/법정 제출이라는 일련의 과정이 명확해야 함 이러한 과정에 대한 추적이 가능   무결성의 원칙  수집된 정보는 연계 보관성 원칙을 만족시켜야 하고, 위조/변조가 되면 안됨    수행 절차 수사 준비 사이버 포렌식 전문가를 소집하고 각종 장비, S/W, H/W를 준비하고 점검하는 단계\n증거 수집 각종 저장매체로부터 디지털 증거를 획득하는 단계\n 증거의 무결성이 중요 디스크 이미징 = 저장매체에 저장된 데이터를 추출하는 과정  저장된 데이터와 동일한 사본을 만듦    보관 및 이송 획득된 증거는 연계 보관성을 만족시키며 보관 및 이송해야 함\n Evidence sage = 증거의 연계 보안성을 위한 안전한 장소 이송되거나 담당자/책임자가 바뀔 때는 문서에 그 증적을 남김  조사 및 분석 증거를 관리할 때는 최량 증거 원칙(The Best Evidence Rule)을 따름\n 최량 증거 원칙: 복사본이나 2차 증거물이 아닌 원본을 제출하도록 요구하는 영미 증거법상의 원칙\n 디스크 브라우징 수집한 저장매체 또는 디스크 이미지에 존재하는 파일을 GUI 환경에서 쉽고 편리하게 다룰 수 있도록 가독성 있는 형태로 변환하여 출력하는 기술\n데이터 뷰 저장 매체나 디스크 이미지에 저장된 방대한 파일을 열어서 확인할 수 없기 때문에 브라우징 과정에서 파일을 인식하여 텍스트, 그림 형식으로 볼 수 있도록 하는 자동 뷰 기능을 제공하는 기술\n파일 복구 복구 S/W를 이용하여 파일 원본을 복구시키는 기술, 파일이 손상되어도 디스크 내에는 관련 정보가 보존되어 있기에 파일 복구가 가능하다.\n보고서 작성 포렌식의 모든 단계의 내용을 문서화하는 단계로 일련의 과정을 정확히 작성하여 증거자료로서 타당성을 제공해야 한다.\n 따라서 증거자료 획득, 보관 및 이송, 분석 등 모든 과정을 명확하고 객관성 있게 설명하고 불법행위를 입증할 수 있도록 논리적으로 작성해야 한다.\n 기술    기술 설명     디스크 포렌식 물리적 저장장치인 보조 기억장치에서 증거를 수집하고 분석   시스템 포렌식 OS, 응용프로그램 및 프로세스를 분석하여 증거 확보   N/W 포렌식 네트워크 전송되는 데이터, 암호를 가로채어 단서를 찾아내는 기술   인터넷 포렌식 인터넷 응용 프로토콜을 사용하는 분야에서 증거를 수집하는 기술   모바일 포렌식 휴대용 전자기기에서 필요한 정보를 입수하여 분석   DB 포렌식 DB의 데이터를 추출 분석하여 증거를 수집하는 기술   암호 포렌식 문서 또는 시스템에서 암호를 찾아 암호화 문서를 복호화    포렌식 도구  EnCase: 전 세계에서 가장 대표적인 포렌식 도구  디지털 증거 수집, 검증, 검색, 보고, 완전삭제 등 다양한 기술 제공   FTK: 다용도 포렌식도구로 EnCase처럼 다양한 기능 제공  증거 디지털 증거물 분석  TimeLine 분석  파일 생성, 변경, 접근, 삭제 시간   시그니처 분석  의도적으로 파일 확장자를 변경한 파일을 간단히 파악   Hash 분석  시스템 내 파일이 변경되었는지 확인 파일의 해시값을 구한 후 기존 파일 해시값과 비교하여 기존 파일과 같은 파일이 존재하는지 확인   로그 분석  웹 브라우저 로그, 메일로그, FTP 로그 등   프로세스 분석  현재 수행되고 있는 프로세스 메모리 내용 조시, 의심되는 실행파일 조사    휘발성 데이터  시스템의 메모리(RAM, 캐시 메모리, 비디오 카드 메모리 등)에 임시로 저장된 데이터 휘발성이 큰 증거가 사라질 가능성이 크기 때문에, 휘발성이 큰 증거를 먼저 수집해야 한다. live response: 실행 중인 시스템을 대상으로 행해지는 일련의 포렌식 조사 과정  전통적인 방법과 달리 컴퓨터 시스템의 플러그를 제거하지 않음 휘발성 데이터의 유실을 막기 위함    디지털 증거 보존 디지털 증거는 근본적으로 손상되기 쉽기에 완전한 비트스트림 이미지를 즉시 만들어야 한다.\n 비트스트림 이미지: 원본 저장 장치에 기록되었던 모든 데이터의 사본, CRC계산으로 원본과 비교\n    구분 디스크 복사 디스크 이미징     저장방식 Source read \u0026 Destination write Bit Stream Clone(Sector by Sector)   저장대상 파일과 디렉터리 단위 일부 디스크의 모든 물리적 섹터   정보 손실 Source read 과정에서 읽지 못한 정보는 손실이 발생 디스크 이미지는 디스크의 모든 정보를 포함   파일 복구 삭제된 파일은 복사과정에서 제외 디스크 섹터에 삭제파일 정보가 남아있는 경우 복구 가능    ","excerpt":"다양한 디지털 장치에서 범인과 연관된 자료를 발견하고 분석하여 법적인 문제를 해결하는 방법\n 포렌식을 통해 증거획득하고 이 증 …","ref":"/til/security/application/digital-forensic/","title":"Digital Forensic"},{"body":"종류  vi emacs pico vim nano  사용 pico pico 사용하기 $ pico [file] pico 단축키    조합 설명     [Ctrl]+[g] 도움말   [Ctrl]+[x] 프로그램 종료   [Ctrl]+[o] 내용 저장   [Ctrl]+[j] 행 끝 나란히   [Ctrl]+[r] 다른 파일 내용 읽어서 추가   [Ctrl]+[w] 문자열 검색   [Ctrl]+[y] 이전 화면으로 이동   [Ctrl]+[v] 다음 화면으로 이동   [Ctrl]+[k] 현재 줄 삭제(cut)   [Ctrl]+[u] 삭제한 문자열 붙이기(uncut)   [Ctrl]+[c] 현재 커서 위치 표시   [Ctrl]+[t] 철자 점검     [Ctrl]은 ^로 표기된다.\n pico 커서 이동 키보드 방향키를 사용할 수 있지만 단축키를 사용할 수도 있다.\n   조합 설명     [Ctrl]+[a] 현재 커서가 위치한 줄 처음으로 이동   [Ctrl]+[e] 현재 커서가 위치한 줄 끝으로 이동   [Ctrl]+[p] 커서를 윗줄로 이동   [Ctrl]+[n] 커서를 아랫줄로 이동   [Ctrl]+[b] 커서를 뒤로 이동   [Ctrl]+[f] 커서를 앞으로 이동    emacs emacs 사용하기 $ emacs [file] emacs 단축키    조합 설명     [Ctrl]+[x]; [Ctrl]+[c] 종료, 변경사항이 있는 경우 y나 n를 선택해야 함   [Ctrl]+[x]; [Ctrl]+[s] 편집된 내용 저장   [Ctrl]+[x]; [Ctrl]+[f] 새문서 작업을 위해 새로운 파일명 지정하고 편집     [Ctrl]은 C로 표기된다.\n emacs 커서 이동  pico 커서 이동과 동일하다.\n 삭제 및 되돌리기    조합 설명     [BackSpace] 커서의 앞 글자를 삭제   [Delete] 또는 [Ctrl]+[d] 커서가 위치한 글자를 삭제   [Alt]+[p] 커서가 위치한 부분부터 단어 삭제   [Ctrl]+[k] 커서가 위치한 부분부터 줄 전체를 삭제   [Alt]+[k] 커서가 위치한 부분부터 문장 전체를 삭제   [Ctrl]+[x]; [u] 직전에 수행한 명령을 취소    질의 및 치환    조합 설명     [Esc]; [%] 현재 커서가 위치한 이후로 질의를 통한 치환을 시작   [y] 문자열을 치환   [n] 치환하지 않고 다음으로 이동   [.] 치환하고 더 이상의 탐색을 중지   [!] 묻지 않고 남은 문자열 전부 치환   [^] 이전에 탐색했던 위치로 이동    vi vi 모드 다른 편집기와 달리 두 가지 모드가 존재한다. 처음에는 명령모드 상태로 진입하는데 이때 입력 명령(i, I, a, A, o, O)을 실행하면 입력모드로 전환된다. 입력모드에서명령모드로 돌아오려면 [Esc]를 누르면 된다.\n   모드 역할 및 특징     명령모드 커서 이동, 수정, 삭제, 복사, 붙이기, 탐색 등   입력모드 글자를 입력하는 모드로 화면 아래에 -INSERT-가 표기됨   ex명령모드 명령모드에서 :를 입력하고 저장, 종료, 탐색, 치환 등 명령 수행    vi 사용하기 $ vi [option] [file] 주요 옵션\n   옵션 설명     -c vi 시작시 ex명령모드에서 실행되는 명령 지정   -r 손상 파일 복구   -R 파일을 읽기 전용으로 열기   + num 커서를 지정한 줄로 이동     + 값이 지정되지 않을 경우, 마지막 줄로 이동\n vi 커서 이동    명령 설명     h 커서를 왼쪽으로 이동   l 커서를 오른쪽으로 이동   j 커서를 아래로 이동   k 커서를 위로 이동   w 다음 단어의 처음으로 이동   - 앞 줄 첫 문자로 이동   + 다음 줄의 첫 문자로 이동   ^ 줄의 첫 문자로 이동   $ 줄의 맨 끝으로 이동   0 첫 번째 열로 이동    vi 입력 모드 전환    명령 설명     i 현재 커서가 위치한 문자(줄) 앞에 삽입하면서 입력모드로 전환   a 현재 커서가 위치한 문자(줄) 뒤에 삽입하면서 입력모드로 전환   o 현재 커서가 위치한 곳의 아래(위)에 삽입하면서 입력모드로 전환   s 현재 커서가 위치한 문자(줄)를 지우면서 입력모드로 전환   [ESC] 명령모드로 전환     ()안의 내용은 명령어를 대문자로 실행했을 경우\n ex명령모드 명령\n   명령 설명     :w [file] (파일명으로) 저장   :w! 강제 저장   :q 종료   :q! 강제 종료   :e file 지정한 파일명으로 새롭게 편집   :r file 지정한 파일명을 읽어서 커서 위치 다음에 삽입   : num 지정한 정수값의 행으로 이동    특수문자\n   특수문자 설명     % 전체 줄   $ 마지막 줄   . 현재 줄   n+m n번째 줄부터 m을 더한 값까지   n,m n번째 줄부터 m번째 줄까지    문자열치환 ex 명령 모드에서 지정한 문자열을 새로운 문자열로 치환할 수 있다. 커서가 위치한 줄에 있는 해당 문자열만 변경한다.\n   기호 설명     : s/문자열/새문자열 첫 번째 해당 문자열을 새문자열로 치환   : s/문자열/새문자열/g 해당 문자열을 전부 새문자열로 치환   : s/문자열/새문자열/gi 해당 문자열을 전부 새문자열로 치환(대소문자 구분X)   : s/문자열/새문자열/gc 해당 문자열을 전부 새문자열로 치환(하나씩 질의)    ","excerpt":"종류  vi emacs pico vim nano  사용 pico pico 사용하기 $ pico [file] pico …","ref":"/til/linux/linux-master/editor/","title":"Editor"},{"body":"이미지를 업로드할 수 있는 모델을 생성하기 위해서는 우선적으로 media 설정이 필요하다. 만약 진행하지 않았다면 해당 링크를 참고하여 진행하도록 한다.\n# models.py from django.conf import settings class Post(models.Model): image = models.ImageField(upload_to='images/', blank=True) ...  해당 소스코드가 사용된 전체 코드는 다음 주소를 통해서 확인해볼 수 있다.\n Post라는 글을 작성하기 위한 모델에 image라는 필드를 만들었다. 여기에는 models 클래스의 ImageField 메소드가 사용된다.\n upload_to 속성은 이미지 업로드 시 경로를 의미하며, settings.py에서 설정한 media 경로가 기준인 상대 경로를 말한다.\n 만약 모델이 수정되었으면 마이그레이션을 해주어야 한다.\n python manage.py makemigrations python manage.py migrate  이후 이미지를 활용하기 위한 파이썬 패키지를 설치한다.\n pip install pillow  이제 파일 업로드가 가능하게 되었을 것이다. 템플릿 상에서 위 모델로 생성된 글의 이미지를 출력하려 한다면 다음과 같이 사용하면 된다.\n\u003cimg src=\"{{post.image.url}}\" alt=\"...\"\u003e \u003c!-- post는 Post로 생성된 객체 하나를 의미--\u003e ","excerpt":"이미지를 업로드할 수 있는 모델을 생성하기 위해서는 우선적으로 media 설정이 필요하다. …","ref":"/til/django/study/image-field/","title":"Image Field"},{"body":"공중 네트워크를 이용하여 사설 네트워크가 요구하는 서비스를 제공\n 전용 회선처럼 사용할 수 있게 해주는 기술\n 종류  Intranet VPN  기업 내부를 LAN을 통해 연결 넓게는 지사까지 연결   Extranet VPN  자사의 협력업체에게 Intranet 제공 Intranet의 확장   Remote Access VPN  원격으로 NAS(Network Access Server)에 접속 NAS는 사용자의 접속 인증절차와 터널링 관련 기능 수행    구현 기술 터널링 송수신자 사이의 전송로에 외부로부터의 침입을 막기 위해 일종의 파이프를 구성한 것\n 터널링 되는 데이터를 페이로드라고하며 이것의 내용은 변경되지 않음 지원하는 프로토콜은 PPTP, L2TP, L2F, MPLS, IPSEC 등이다.  암호화  정보의 기밀성을 제공하기 위해 대칭키 암호를 사용 대칭키는 공개키 암호방식을 사용하여 키 교환 메시지 인증: MAC, 해시함수 사용자 인증: 보안서버로부터 인증을 받아야 접속 가능  접근제어  인증된 사용자에게만 접근 허용 암호화 되지 않은 패킷만 접근제어 가능  프로토콜 2계층 PPTP  MS 개발 일대일 통신만 가능 IP를 통해 전송 TCP 연결 Client-Server 구조 PPP기초해 연결 확장, 보호  L2F  CISCO 개발 NAS 개시 VPN형  별도의 S/W 필요 없음   다자간 통신 지원 UDP 연결  L2TP  PPTP + L2F 보안성 우수 IP 외 여러 프로토콜 지원 보완을 위해 IPSec과 결합  IPSec IP 계층(3계층)의 보안 프로토콜로 네트워크 계층의 보안을 위해 AH 프로토콜과 ESP 프로토콜을 함께 사용한다.\n 강력한 암호화, 인증방식 IPv4와 IPv6를 모두 지원  IPv6에서 AH와 ESP는 확장 헤더의 한 부분    동작 모드  전송 모드(Transfer Mode): 호스트와 호스트간의 메시지(Payload) 무결성을 제공 터널 모드(Tunnel Mode): IP 패킷 전체를 보호하는 모드  헤더  AH (인증 헤더, Authentication Header)  발신지 인증, 데이터 무결성만을 보장   ESP (캡슐화된 보안 페이로드, Encapsulating Security Payload)  발신지 인증, 데이터 무결성, 기밀성 모두를 보장    서비스 기능  접근제어  보안 정책(SP, Security Policy)과 보안 연관을 통해 송수신 IP 패킷에 대한 시스템 접근을 제어   비연결 무결성  MAC을 통해 각 IP 패킷 별로 무결성을 보장   데이터 송신처 인증  MAC을 통해 제공   재전송 공격 방지  보안연관(SA, Security Association, 보안연계)에 순서번호를 유지하여 방지   기밀성  대칭 암호화를 통해 지원   제한된 트래픽 흐름의 기밀성  ESP/터널모드 적용 시 새로운 IP 헤더를 통해 보안/터널 게이트웨이 구간 정보는 노출 기존 IP 헤더에 있는 최초 출발지/목적지 정보는 암호화되어 노출되지 않음     기밀성, 제한된 트래픽 흐름의 기밀성은 ESP 프로토콜만 지원한다.\n 보안 연관과 보안 정책  SA(보안 연관): 두 기기의 논리적인 연결 상태 동안 적용할 보안 정보  단방향 설정이므로 두 기기 연결에 2개의 SA가 필요   SAD(보안 연관 데이터베이스): 각각의 보안 연관과 관련된 매개 변수 값을 저장하는 데이터베이스 SP(보안 정책): 수신하는 데이터그램을 어떻게 처리할 지에 대한 규칙 SPD(보안 정책 데이터베이스): 보안 정책이 저장되어 있는 데이터베이스  인터넷 키 교환(Internet Key Exchange, IKE)  내부적 및 외부적 SA을 생성하기 위해 설계된 프로토콜(UDP/500) SP들을 생성하고 협상, 관리 ESP, AH에서 사용하게 될 키를 관리  MPLS  다른 VPN 구조에 비해 서비스 도입과 운영관리가 간단 저가의 VPN 서비스 제공 가능 짧고 고정된 길이(4byte)의 레이블을 이용한 스위칭  SSL  전송 계층(5계층)에서 동작 사용자가 쉽게 사용 세분화된 접근 통제 IPSec VPN에 비해 설치 및 관리 편리, 비용 절감  ","excerpt":"공중 네트워크를 이용하여 사설 네트워크가 요구하는 서비스를 제공\n 전용 회선처럼 사용할 수 있게 해주는 기술\n 종류  Intr …","ref":"/til/security/network/vpn/","title":"VPN(Virtual Private Network)"},{"body":"Post Form {% extends 'base.html' %} {% block content %} \u003cbr\u003e \u003cform action=\"{% url 'new' %}\" method=\"POST\" enctype=\"multipart/form-data\"\u003e {% csrf_token %} \u003cinput type=\"file\" name=\"image\"\u003e \u003cbr\u003e \u003ctextarea name=\"content\" cols=\"50\" rows=\"10\" \u003e\u003c/textarea\u003e \u003cbr\u003e \u003cinput type=\"submit\" value=\"글쓰기\"\u003e \u003c/form\u003e {% endblock %} \u003c주요 개념\u003e\n GET/POST csrf-token  Url path urlpatterns = [ path('new', page.views.new, name='new'), ... ] View from django.shortcuts import redirect from django.utils import timezone def new(request): if request.method == 'POST': post = Post() post.author = request.user post.content = request.POST['content'] # image 파일이 있으면 post 객체에 저장 if 'image' in request.FILES: post.image = request.FILES['image'] post.pub_date = timezone.datetime.now() post.save() return redirect('/detail/'+str(post.id)) return render(request, 'new.html') ","excerpt":"Post Form {% extends 'base.html' %} {% block content %} \u003cbr\u003e \u003cform …","ref":"/til/django/study/create-new-post/","title":"Create New Post"},{"body":"설치 개요 리눅스 프로그램은 공개 소프트웨어라는 특징과 유닉스의 영향으로 C언어로 된 소스 파일을 tar로 압축하여 배포한다.\n설치 단계  압축 풀기 디렉토리 이동 configure  소스 프로그램의 환경 설정을 하는 스크립트 대부분 최상위 디렉토리에 존재   make  소프트웨어를 컴파일하는 유틸리티 configure에 의해 변경된 내용 반영 실행 파일 생성   make install  실행 파일을 지정한 속성으로 설치    패키지 설치 RPM 레드햇 사에서 만든 패키지 관리 기법으로 프로그램을 .rpm 형태의 파일로 배포하고, rpm 명령으로 설치 및 갱신, 제거 등의 관리를 가능하게 한다.\n 형식: 패키지이름-버전-릴리즈-아키텍처.rpm\n 데비안 데비안 리눅스는 dpkg(Debian Package)라는 데비안 패키지 관리 도구를 사용하는데, 관련 프로그램을 .deb 형태의 파일로 배포 및 설치, 삭제 등의 관리를 한다.\n 형식: 패키지이름_버전-릴리즈-아키텍처.deb\n 설치 및 삭제 tar 리눅스에서 사용되는 GNU tar는 옵션을 이용해서 파일로 묶거나 풀 때 압축 관련 작업을 동시에 진행할 수 있다.\n$ tar [option] [file] 주요 옵션\n   옵션 내용     -c 지정한 파일/디렉토리로 tar파일 생성   -x 생성한 tar 압축 풀기   -v 명령의 대상 파일을 출력   -f file 작업 대상이 되는 tar 파일명 지정   -r 기존의 tar 파일 뒤에 파일 추가   -t tar 파일 안에 묶여있는 파일 목록 출력   -Z tar.Z   -z tar.gz   -j tar.bz2   -J tar.xz    RPM 사용법 $ rpm [option] [package_file] 설치 및 갱신    옵션 내용     -i 새로운 패키지 설치 시   -U 새로운 버전의 패키지로 업그레이드   -F 이전 버전이 설치된 경우에만 설치   -v 메시지를 자세히 표기   -vv 메시지를 더 자세히 표기   -h 설치 상황을 #기호로 표기   –force 기존 버전이 설치되었을 경우 강제로 설치   –nodeps 의존성 관계를 무시하고 설치   –test 실제로 설치 이전에 테스트    제거    옵션 내용     -e 설치된 패키지를 삭제   –nodeps 의존성을 갖는 패키지가 존재해도 삭제   –allmatches 동일한 이름을 갖는 패키지 중복 설치된 경우 모두 제거   –test 실제로 제거하지 않고 테스트    질의    옵션 내용     -q 질의 시 꼭 사용해야 함, 패키지 이름과 버전 출력   -i 설치된 패키지 정보 출력   -l 패키지에 설치한 모든 파일 정보 출력   -a 시스템에 설치된 모든 패키지 목록 출력   -p package rpm 패키지 파일에 대한 정보 출력   -f file 지정한 파일을 설치한 패키지 이름 출력   -c 해당 패키지의 설정 파일이나 스크립트 파일 출력   -d 해당 패키지의 문서 파일 출력   -R 어떤 패키지에 의존하고 있는지를 표시    검증    옵션 내용     -V 기본 옵션   -a 모든 패키지를 검사    yum 사용법  rpm기반의 시스템에서 패키지를 손쉽게 설치해주고 자동으로 업데이트를 수행하는 명령행 기반의 유틸리티로 의존성 문제를 자동으로 해결해준다.\n $ yum [option] [command] [package_file] 주요 옵션\n   옵션 내용     -y 모든 질의에 yes라 답함   -v 자세한 정보를 출력    Command\n   명령 내용     list [항목] 전체 패키지 정보 출력   info [패키지명] 패키지에 대한 정보 출력   update [패키지명] 패키지 업데이트할 때 사용   install [패키지명] 패키지를 설치할 때 사용   search [문자열] 문자열이 포함된 패키지를 찾음   remove 패키지명 패키지를 삭제할 때 사용    dpkg 사용법 $ dpkg [option] [package] [package_file] 주요 옵션\n   옵션 내용     -i package_file 패키지 설치   -R directory 지정한 디렉토리에 설치   -l [package_file] 설치된 패키지 모두 출력(지정한 패키지)   -c package_file 패키지 파일에 포함된 파일 정보   -L package 패키지가 설치한 파일 목록   -r package 패키지 제거, 환경 설정 파일만 남김   -P package 환경 설정 파일까지 전부 제거   -S file 해당 파일을 설치한 패키지 이름을 출력   -C 완전히 설치되지 않은 패키지에 대한 검사   –unpack package_file 환경 설정 없이 패키지 풀기   –configure package –unpack한 패키지를 환경설정   -s package 패키지에 대한 상태 출력    apt-get 사용법 $ apt-get [option] [command] [package] 주요 옵션\n   옵션 내용     -y 모든 질의에 yes라 답한다   –purge remove 명령을 수행할 때 환경 설정까지 같이 제거    Command\n   명령 내용     update 패키지 목록을 갱신할 때 사용   upgrade 모든 패키지를 최신 버전으로 갱신   install package 패키지 설치   remove package 패키지 삭제   clean /var/cache/apt/archive에 생성된 파일을 삭제    ","excerpt":"설치 개요 리눅스 프로그램은 공개 소프트웨어라는 특징과 유닉스의 영향으로 C언어로 된 소스 파일을 tar로 압축하여 배포한다. …","ref":"/til/linux/linux-master/install-software/","title":"Install Software"},{"body":"역추적 시스템 해킹을 시도하는 해커의 실제위치를 추적하는 기술\n TCP 연결 역추적  우회 공격을 시도하는 해커의 실제위치를 실시간 추적 호스트 기반과 N/W 기반 연결 역추적으로 분류   IP연결 역추적  IP주소가 변경된 패킷의 실제 송신지를 추적하기 위한 기술 변경된 패킷을 전달한 라우터를 표시함으로써 추적이 가능하게함    ESM(Enterprise Security Management) 네트워크 보안제품의 인터페이스를 표준화하여 중앙 통합 관리, 침입 종합 대응, 통합 모니터링 수행\n특징  운영관리 측면  통합관리 운영으로 비용 절감, 인력 축소 보안 정책 통합 관리를 통한 보안 운영 관리의 일관성 제공 보안성 강화보다 운영관리 측면 강화를 통한 보안 관리 효율성 제공   기술적 측면  크로스 플랫폼 기반 오픈 아키텍처로 유연성과 상호 운영성 확보    주요 기능 통합 로그 관리, 이벤트 필터링, 실시간 통합 모니터링/경보/상황전파, 로그 분석 및 의사결정 지원, 긴급대응, 리포팅\n구성 요소  클라이언트(Agent)  개별 보안 장비에 탑재. ESM 서버의 매니저로부터 통제를 받아 이벤트 처리와 개별 보안 장비의 통제 룰 수행 이벤트 발생 시 이벤트 정보와 로그 정보를 수집하여 ESM 매니저에게 전달   서버(ESM 매니저)  통합 보안 정책의 생성/적용 관리 에이전트에게 명령 전달 수집된 정보를 저장/분석하여 보고 -서버(ESM 콘솔) 개별 에이전트에서 이벤트 로그 모니터링 ESM 매니저에서 분석한 위험 및 해킹 분석 결과 확인    NAC(Network Access Control) 내부 네트워크에 접근하기 전에 보안 정책을 준수했는지 여부를 검사해 네트워크 접속을 통제하는 보안 솔루션\n 내부자에 의한 보안사고 증가와 접속 단말의 다양화, 네트워크 통합 보안 관리가 요구되면서 NAC의 필요성이 증가\n 주요 기능  접근제어/인증 PC 및 네트워크 장치 통제(무결성 체크) 해킹, 웜, 유해 트래픽 탐지 및 차단  구성  IP주소에 대응하는 MAC주소를 기반으로 인증 및 접근제어 접속을 원하는 호스트는 MAC 주소를 해당 시스템 관리자에게 알려줘야 함 관리자가 해당 MAC 주소를 NAC에 등록하면 N/W 사용 권한 생김 라우터로 구분된 서브 네트워크마다 에이전트 시스템이 설치되어야 함  기타 보안 솔루션 SIEM(Secure Information Event Management) 수많은 IT 시스템 및 보안 시스템에서 발생하는 로그를 분석하여 이상 징후를 파악하고, 그 결과를 관리자에게 보고할 수 있도록 해주는 시스템\n 빅데이터 기반 로그 분석 데이터 정규화, 데이터 표준화를 통해 분석  PMS(Patch Management System) 시스템이 관리하는 PC에 S/W 업데이트 설치와 OS 패치 등을 강제로 설치하도록 하는 기업용 솔루션\nAPT(Advanced Persistent Threat) 특정 대상을 겨냥해 다양한 공격 기법을 이용하여 장기간 지속적으로 공격\n 제로데이 공격, 기존에 알려지지 않았던 취약점을 이용해 해당 취약점의 패치 전에 공격 공격단계: 침투 - 탐색 - 수집 - 유출  기존 공격과의 차이점  맞춤형 공격 낮고 느리고 지속적인 공격  특정 대상의 내부를 오랜 기간에 걸쳐 관찰/공격   높은 목표의식을 가진 공격 구체적인 공격목표  주요 침투 기법  스피어 피싱(Spear Phishing) 공격  특정 대상(개인, 회사)에게 피싱공격 APT 공격 초기단계에 자주 수행 공격 성공률을 높이기 위해 대상에 대한 정보 수집, 분석   드라이브-바이-다운로드 공격  목표 대상의 구성원이 방문할 가능성이 높은 사이트 침해 해당 구성원의 접속 즉시 악성코드가 다운로드 되도록 하는 공격   워터링 홀(Watering Hole) 공격  목표 대상의 구성원이 주로 방문하는 사이트의 정보를 사전에 파악 제로데이 취약점을 이용해 해당 사이트에 악성코드를 심어 둠 해당 구성원의 접속 시 악성코드에 감염    랜섬웨어(Ransomware) 이용자의 데이터를 암호화하여 복구를 위한 금전을 요구하는 공격\n","excerpt":"역추적 시스템 해킹을 시도하는 해커의 실제위치를 추적하는 기술\n TCP 연결 역추적  우회 공격을 시도하는 해커의 실제위치를  …","ref":"/til/security/network/latest-technology/","title":"Latest Technology"},{"body":"OWASP(Open Web Application Security Project)에서는 3~4년 주기로 10가지 보안이슈를 발표한다.\n인젝션 SQL, OS, XXE, LDAP 인젝션은 신뢰할 수 없는 데이터가 명령어나 쿼리문의 일부분으로써, 인터프리터로 보내질 때 발생한다.\n 공격자의 악의적인 데이터는 예기치 않은 명령을 실행 올바른 권한 없이 데이터에 접근하도록 인터프리터를 속임  SQL 인젝션 DB와 연동되어 있는 애플리케이션 입력값을 조작하여 DBMS가 의도하지 않은 결과를 반환하도록 하는 기법\n 필터링 기능이 없는 애플리케이션의 경우 사용자의 입력값의 적정성의 검사를 하지 않는다.\n 공격 피해  DB 정보 조회/변조/삭제 인증절차 우회 시스템 명령어 실행 주요시스템 파일정보 노출  취약점 판단 입력 폼에 큰따옴표, 작은따옴표, 세미콜론 등을 입력하여 DB 에러를 출력하는지 확인\n대응 방법  개발단계부터 모든 입력값에 대해 적절한 검증절차를 설계 구현 SQL 서버의 에러 메시지를 표시 X 일반 사용자 권한으로 시스템 저장 프로시저 접근을 불허 동적 SQL 완성방식 사용을 지양하고 저장 프로시저를 사용 선처리 질의문을 이용  인증 취약점 인증 및 세션 관리와 관련된 애플리케이션 기능의 잘못된 구현으로 발생한다.\n 공격자에게 암호, 키, 세션 토큰을 위험에 노출시킴 일시적/영구적으로 다른 사용자의 권한을 획득하여 결함을 악용하는 것을 허용  웹 방화벽(WAF, Web Application Firewall) 웹 애플리케이션을 대상으로 시도되는 해킹을 차단하는 솔루션\n기능  사용자 요청 검사  접근제어, Web DoS, 업로드 파일 및 요청 형식 검사, SQL 인젝션 및 XSS 등의 차단   콘텐츠 보호  정보 유출 차단, 웹 변조 방지, 코드 노출 진단   위장  URL 정보 위장, 서버 정보 위장    기존 방화벽과 차이    구분 웹 방화벽 기존 방화벽     목적 유해 HTTP 차단 유해 포트 차단   동작레벨 7계층 3/4계층   동작방식 규칙 + 애플리케이션 로직 일련의 규칙에 의해 동작    민감 데이터 노출 다수의 웹 애플리케이션과 API는 금융 정보, 건강 정보, 개인 식별 정보와 같은 중요한 정보를 제대로 보호하지 않는다.\n 공격자는 신용카드 사기, 신분 도용 또는 다른 범죄를 수행하기 위해 보호가 취약한 데이터를 훔치거나 수정 중요한 데이터는 저장 또는 전송할 때 암호화 같은 추가 보호 조치가 없으면 탈취 가능 브라우저에서 주고 받을 때 각별한 주의가 필요  XML 외부 객체(XXE) XXE는 악의적인 자바스크립트를 막기 위한 필터장치를 우회하는 취약점\n XML 문서에서 동적으로 외부 URI의 리소스를 포함시킬 수 있는 외부 엔티티(Entity)를 사용할 때 발생 오래된 XML 프로세서들은 XML 문서 내에서 외부 개체 참조를 평가 외부 개체는 파일 URI 처리기, 내부 파일 공유, 내부 포트 스캔, 원격 코드 실행과 DoS 공격을 사용하여 내부 파일을 공개하는데 사용 가능  접근제어 취약점 인증된 사용자가 수행할 수 있는 작업에 대한 제한이 제대로 적용되어 있지 않은 경우 발생하는 취약점\n 공격자는 다른 사용자의 계정 접근, 중요 데이터에 접근/수정, 접근 권한 수정 등을 할 수 있음  직접 객체 참조 파일, 디렉터리, DB 키와 같이 내부적으로 구현된 객체에 대한 참조가 노출될 때 발생\n 2013년도 이전에는 OWASP TOP10의 별도 항목이었다가 2017년도부터 접근통제 취약점으로 편입되었음.\n 디렉터리 탐색 공격(파일 다운로드 취약점) 브라우저에서 확인 가능한 경로의 상위로 탐색하여 시스템 파일을 다운로드 하는 방법\n 자료실에 올라간 파일을 다운로드할 때 전용 다운로드 프로그램이 파일을 가져옴 이때 파일 이름을 필터링하지 않아서 발생하는 취약점 ..과 / 문자를 필터링 하도록 해야함  파일 업로드 제한 부재 클라이언트에서 서버 측으로 임의의 파일을 보낼 수 있는 취약점은 웹 서버가 가지는 가장 치명적인 취약점\n 공격자는 웹 서버에 악의적인 파일을 전송 원격지에서 해당 파일을 실행하여 웹 서버를 장악 추가적인 내부 침투 공격을 수행 가능 – 리버스 텔넷과 같은 웹 서버의 통제권을 얻기 위해 반드시 성공해야 하는 공격  리버스 텔넷 웹 해킹을 통해 시스템 권한을 얻은 후 텔넷과 같이 명령 가능한 쉘을 띄우기 위한 공격\n 방화벽이 존재하는 시스템을 공격시 주로 사용 일반적인 웹 서버는 방화벽 내부에 존재하며 TCP/80만을 허용  텔넷이 열려있어도 방화벽으로 인해 공격자가 외부에서 접근 불가   아웃바운드 정책을 설정하지 않은 경우 취약점을 노림  공격자는 서버가 자신에게 텔넷 연결을 요청하도록 유도     아웃바운드 정책: 내부에서 방화벽 외부로 나가는 패킷에 대한 정책 (인바운드는 이와 반대)\n 보안 설정 오류 취약한 기본 설정 사용, 임시 설정, 개방된 클라우드 스토리지, 잘못 구성된 HTTP 헤더 메시지 등의 결과\n 운영체제, 프레임워크, 라이브러리와 애플리케이션을 안전하게 설정 S/W는 시기 적절하게 패치/ 업그레이드를 진행  크로스사이트 스크립팅(XSS) 애플리케이션이 신뢰할 수 없는 데이터를 적절한 검증 없이 웹 브라우저로 전송하는 경우 발생\n 클라이언트의 브라우저에서 공격자의 스크립트 실행 사용자 세션을 탈취, 웹 사이트를 변조, 악성 사이트로 리다이렉션 등의 공격  공격 과정  공격자는 게시판 등에다가 XSS를 심어 둠 클라이언트는 공격자가 작성해 놓은 XSS에 접근 게시판의 글을 통해 XSS코드가 클라이언트에게 전달됨 클라이언트 브라우저에서 XSS 실행  공격 유형 Stored XSS 가장 일반적인 XSS 공격으로 게시판과 같은 곳에 공격자가 정상적인 평문이 아닌 스크립트 코드를 입력하는 기법\n 사용자가 게시판을 열람하는 순간 악성 스크립트가 실행됨 사용자의 쿠키정보가 유출되거나 악성 스크립트가 기획한 공격에 당하게 됨  Reflected XSS 악성 스크립트 코드가 인자 형태로 포함된 URL을 클릭 시 악성 스크립트 코드가 서버 사이트에 의해 HTML 문서로 반사되어 웹 브라우저에서 실행됨\n 공격 스크립트 부분을 주로 인코딩하여 전달해 사용자가 눈치채지 못하게 함 URL의 변수 부분처럼 스크립트 코드를 입력하는 동시에 결과가 바로 전해지는 기법 서버 상에 악성 스크립트 코드를 남지 않는 장점(흔적X)  DOM based XSS 피해자의 브라우저가 HTML 페이지 구분 분석할 때 마다 공격 스크립트가 DOM 생성의 일부로 실행되며 공격\n 페이지 자체는 변경되지 않음 페이지에 포함되어 있는 브라우저측 코드가 DOM 환경에서 악성코드로 변경 DOM 기반 XSS는 서버와 관계없이 브라우저에서 발생하는 것이다.  보안 대책  \u003c, \u003e, \u0026, \"등 문자열은 \u0026lt, \u0026gt, \u0026amp, \u0026quot로 치환한다. 사용자 입력값에 대한 검증은 서버단에서 반드시 해야함 게시판에서 HTML 태그의 리스트를 선정, 해당 태그만 허용하는 방식 이용  CSRF와 비교 사이트 간 요청 위조(CSRF)는 사용자의 의도와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 요청하게 하는 공격기법\n   비교 XSS CSRF     공격 대상 클라이언트 서버   공격 시점 악성 스크립트가 심어진 게시물 등을 열었을 때 이메일 등을 통해 전달된 주소를 열었을 때   공격 방법 클라이언트의 브라우저에서 실행 정상적인 사용자가 서버에 요청(서버에서 실행)   이용 허점 클라이언트가 웹사이트를 신뢰하는 상태 특정 웹사이트가 사용자를 신뢰하는 상태    CSRF 보안대책  폼 전송방식으로 GET 대신 POST 사용 Referrer 검증  요청된 도메인이 어디인지 확인 이메일 등을 통해서 악의적인 스크립트가 담긴 주소를 열면 차단   CSRF 토큰  임의의 난수를 세션에 저장하여 정상적인 사용자의 요청인지 확인    안전하지 않은 역직렬화 원격 코드 실행으로 이어질 수 있으며, 권한 상승 공격, 인젝션 공격과 재생 공격을 포함한 다양한 공격 수행에 사용\n알려진 취약점이 있는 컴포넌트 사용  라이브러리, 프레임워크 및 다른 소프트웨어 모듈 같은 구성요소는 애플리케이션과 같은 권한으로 실행됨 만약에 취약한 구성요소가 악용된 경우 심각한 데이터 손실을 일으키거나 서버가 장악될 수 있음  불충분한 로깅과 모니터링 사고 대응의 비효율적인 통합 또는 누락이 공격자들로부터 시스템을 지속적으로 공격하거나 더 많은 시스템을 공격할 수 있게 하고, 데이터 변조/유출/삭제를 할 수 있게 한다\n","excerpt":"OWASP(Open Web Application Security Project)에서는 3~4년 주기로 10가지 보안이슈를 발표 …","ref":"/til/security/application/owasp-top10/","title":"OWASP TOP10"},{"body":"CSRF란 사이트 간 요청 위조(Closs-site request forgery)라는 웹사이트 취약점 공격 중 하나를 의미한다. 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록)를 특정 웹사이트에 요청하는 것이다.\n옥션의 1800만명 개인 정보 유출 사고는 CSRF 공격의 대표적인 사례이다. 당시 중국 해커는 서버를 공격하는 것이 아니라 옥션 운영진을 대상으로 악성 코드를 첨부한 메일을 전송했는데, 이를 통해서 공격을 감행했다.\n보통 우리는 정보 탈취를 막기 위해서 GET 방식이 아닌 POST 방식의 통신을 사용한다. 하지만 위와 같은 CSRF 공격을 이용하면 POST 방식도 안전하지 않다. 그러므로 POST방식을 더욱 안전히 사용하기 위해서는 CSRF에 대응할 수 있는 방안이 필요한 것이다.\nCSRF 공격 대처방안 = CSRF 토큰\n\u003cform action=\"\" method=\"post\"\u003e {% csrf_token %} ... 장고는 이러한 CSRF 공격을 막기위해서 CSRF 토큰이라는 것을 사용한다. 사용하는 방법은 POST 방식으로 데이터를 전송하는 템플릿 폼에 {% csrf_token %}을 써주기만 하면 된다.\n","excerpt":"CSRF란 사이트 간 요청 위조(Closs-site request forgery)라는 웹사이트 취약점 공격 중 하나를 의미한 …","ref":"/til/django/study/csrf-token/","title":"CSRF Token"},{"body":"프린터 인쇄시스템으로 초기에는 LPRng를 기본으로 사용했으나, 최근에는 CUPS라는 시스템을 추가로 사용하고 있다.\nLPRng  라인 프린터 데몬 프로토콜 사용 프린터 스풀링, 네트워크 프린터 서버 설정 정보는 /etc/printcap 파일에 저장  CUPS  애플이 개발 유닉스 계열 OS를 프린터 서버로 사용가능하게 함 Ipadmin 명령을 통해서 웹상에서 제어  관련파일\n   파일 설명     /etc/cupts/cupsd.conf CUPS 프린터 데몬 환경설정 파일   /etc/cupts/printers.conf 프린터 큐관련 환경 설정 파일   /etc/cupts/classes.conf CUPS 프린터 데몬의 클래스 설정 파일   cupsd CUPS의 프린터 데몬    프린터 명령어  아래부터는 BSD 코드이다.\n lpr 프린트 작업을 요청하는 명령\n$ lpr [option] [file] 주요 옵션\n   옵션 설명     -# num 인쇄매수   -m 작업 완료 정보를 이메일로 전송   -P 프린터명 기본 설정되지 않은 프린터 사용   -T 타이틀 페이지에 들어갈 타이틀명   -r 출력한 뒤에 파일 삭제   -l 필터링 없이 직접 전송    lpq 프린터 큐에 있는 작업 목록 출력\n$ lpq [option] 주요 옵션\n   옵션 설명     -a 설정되어 있는 모든 프린터 작업 정보 출력   -l 출력 결과 자세히   -P 프린터명 특정 프린터 지정    lprm 프린터 큐에 대기 중인 작업을 삭제하는 명령\n$ lprm [option] [file] 주요 옵션\n   옵션 설명     - 프린터 큐에 있는 모든 작업 취소   -U 사용자명 지정한 사용자의 인쇄 작업을 취소   -P 프린터명 특정 프린터를 지정   -h 서버[:port] 지정한 서버의 인쇄 작업 취소    lpc 라인 프린터 컨트롤 프로그램, 프린터나 큐 제어에 사용 lpc 명령 실행 후 지정한 명령어를 사용\n주요 명령\n   명령 설명     disable 새로운 프린트 작업 할 수 없도록 한다   enable 프린트 작업 가능하게 한다   down 지정한 프린터를 사용할 수 없게 한다   up 모든 환경을 활성화, 관련 데몬 새롭게 구동   help, ? 사용 가능한 명령 출력   quit, exit lpc 명령 종료     아래부터는 System-V 계열 명령어\n lp 인쇄 명령으로 lpr과 유사\n$ lp [option] [file] 주요 옵션\n   옵션 설명     -d 다른 프린터 지정   -n 인쇄 매수 지정(~100)    lpstat 프린터 큐 상태 출력\n$ lpstat [option] 주요 옵션\n   옵션 내용     -p 프린터 인쇄 가능 여부   -t 프린터 상태 정보   -a 받아들이는 요청들의 상태    cancel 프린터 작업을 취소하는 명령으로 우선 lpstat로 요청ID를 확인해야 한다\n$ cancel Request-ID 주요 옵션\n   옵션 설명     -a 모든 인쇄 작업 취소    사운드 카드 ALSA 사운드 카드용 장치 드라이버를 제공하기 위한 리눅스 커널의 요소\nOSS 리눅스 및 유닉스계열 운영체제에서 사운드를 만들고 캡처하는 인터페이스\n사운드 카드 명령어 alsactl ALSA 사운드카드를 제어\n$ alsactl [option] [command] 주요 옵션\n   옵션 설명     -d 디버그 모드 사용   -f 환경 설정 파일 선택    command\n   명령 설명     store 사운드카드에 대한 정보를 환경설정 파일 저장   restore 환경설정 파일로부터 선택된 정보 다시 읽기   init 사운드 장치를 초기화    alsamixer 커서 라이브러리 기반의 ALSA 사운드카드 오디오 믹서 프로그램\n$ alsamixer cdparanoia 오디오 CD에서 음악 파일 추출할 때 사용\n$ cdparanoia [option] 주요 옵션\n   옵션 설명     -w wav 파일 추출   -a Apple AIFF-C 포맷으로 추출   -B Cdda2wav 스타일로 추출    스캐너 SANE 이미지 관련 하드웨어를 사용할 수 있도록 해주는 API\nXSANE SANE 스캐너 인터페이스를 이용하여 X-Windows 기반으로 만든 프로그램\n스캐너 명령어 sane find scanner USB 및 SCSI 스캐너와 관련 장치 파일을 찾아주는 명령\n$ sane-find-scanner [option] [device_file] 주요 옵션\n   옵션 설명     -q 스캐너 장치만   -v 자세한 정보   -p 병렬 포트 연결된 스캐너만    scanimage $ scanimage [option] scanadf 자동 문서 공급장치가 장착된 스캐너에서 여러 사진을 스캔\n$ scanadf [option] 주요 옵션\n   옵션 설명     -h 도움말   -d SANE의 장치 파일명 지정   -L 사용 가능한 스캐너 장치 목록 출력   –format 이미지 형식 지정(scanimage)    xcam GUI기반으로 평판 스캐너나 카메라로부터 이미지 스캔\n","excerpt":"프린터 인쇄시스템으로 초기에는 LPRng를 기본으로 사용했으나, 최근에는 CUPS라는 시스템을 추가로 사용하고 있다. …","ref":"/til/linux/linux-master/device-settings/","title":"Device Settings"},{"body":"HTTP 통신 프로토콜을 통해서 정보를 주고받는 방식에는 여러가지가 있지만, 보통 GET과 POST 두가지를 많이 사용한다.\nGET과 POST 차이 GET방식은 데이터를 전송할 때, 주소에 담아서 전송한다. 이전에 로또 프로젝트를 했을 때, 숫자를 전송하는 과정이 있었는데 이때 사용되었던 방식이다. 만약에 1부터 6까지 입력해서 전송하면 아래와 같이 데이터가 전송된다.\n127.0.0.1:8000/?number1=1\u0026number2=2\u0026number3=3\u0026number4=4\u0026number5=5\u0026number6=6\r 이러한 방식으로 인해 어떤 데이터가 전송되는지 알수 있다는 점에서 정보 탈취에 취약하다.\n반면 POST방식은 GET과 달리 주소를 통해서 어떤 정보가 전달되었는지 알 수 없다. 왜냐하면 헤더의 BODY 안에 담겨서 전송이 되기 때문이다.\nPOST 전송 타입 설정 POST는 데이터 전송에 대한 컨텐츠 타입 설정이 존재한다.\n그 종류는 아래와 같이 3가지로 나누어진다.\n1. application/x-www-form-urlencoded\r2. text/plain\r3. multipart/form-data\r 일반적인 경우 1번 방식으로 전송되는데, 이때 전송되는 데이터는 GET과 같은 방식으로 key와 value 쌍으로 구성된다. 그리고 2번은 단순 txt로 전송하는 방법이다.\n3번은 파일 전송을 위해서 사용하는 것으로 바이너리 데이터를 사용한다는 것을 명시해주는 것이다.\n보통 이러한 설정은 파일을 전송하기 위해서 해주는 경우가 많은데, 이럴 때 form태그 속성으로 enctype=\"multipart/form-data\"를 써주면 된다.\n2번은 거의 사용할 일이 없으며, 1번의 경우는 자동적으로 설정되므로 위 설정만 기억해두면 될 것이다.\n적절한 HTTP 프로토콜 사용 예   GET: 데이터를 조회할 때! ex) 게시글 조회\n  POST: 데이터를 전송하는데, 정보가 밖으로 들어나서는 안되는 경우 ex) 회원가입, 로그인, 글 작성/수정\n  ","excerpt":"HTTP 통신 프로토콜을 통해서 정보를 주고받는 방식에는 여러가지가 있지만, 보통 GET과 POST 두가지를 많이 사용한다. …","ref":"/til/django/study/get-and-post/","title":"GET/POST"},{"body":"개념 주로 유닉스 계열 운영체제에서 사용되는 윈도우 시스템이다.\n특징  네트워크 프로토콜에 기반한 GUI환경 디스플레이 장치에 의존적이지 X, 뛰어난 이식성 스크롤바, 아이콘, 색상 등 그래픽 환경에 필요한 자원 특정한 형태로 지원 X 사용자가 원하는 모양의 인터페이스를 만들 수 있음  구조  클라이언트/서버 구조 네트워크 기반의 X Protocol으로 통신 로컬에서도 TCP 포트로 통신 X 클라이언트는 X 서버 위에서 돌아감  X서버 XFree86  IBM시스템을 사용하는 유닉스 계열 운영체제를 위한 X윈도우 프로젝트 현재는 OS X, BSD게열, OS/2를 비롯한 다양한 OS를 지원한다  X.org  X.org 파운데이션에서 관리되는 X서버 패키지 X-org Server라고도 한다. 자유 소프트웨어  X클라이언트 Xlib  C언어로 구현된 클라이언트 라이브러리 X 서버와 대화를 해줌 저수준 인터페이스로 기본 입출력 기능만 가능  XCB  Xlib보다 향상된 쓰레딩 기능 뛰어난 확장성 작은 라이브러리 크기 직접 X 프로토콜 접속 기능  사용방법 설정 X 윈도우를 사용하기 위해서 그래픽 카드 설정은 필수이다. XFree86을 사용하던 초기 리눅스 배포판에서는 X 윈도우를 설정하기 위해서 명령어를 사용해야 했다. 하지만 최근 배포판에서는 자동으로 그래픽 카드를 인식하거나 호환 모드로 설정해주기 때문에 바로 X 윈도우를 사용할 수 있다.\n실행 X 윈도우 실행방법\n 부팅시 X윈도우 실행(Runlevel 5) 텍스트 모드(Runlevel 3)에서 실행  리눅스의 부팅모드는 /etc/inittab에서 설정한다.\n 그래픽 환경 기반 설치 유틸리티인 anaconda를 사용하면 기본 설정이 level5이다.\n 텍스트 모드로 부팅이 되는 경우에는 로그인 이후 startx 명령어를 사용해서 X윈도우를 실행시킬 수 있다.\n$ startx [option] 주요 옵션\n   옵션 설명     – 명령행의 인자값을 xinit에게 넘겨준다    데스크톱 환경 GUI환경을 이용하기 위해 사용자에게 제공되는 인터페이스 스타일\nKDE  Qt라이브러리 기반 yum install konq-plugins으로 패키지를 설치할 수 있다.   Dolphin이라는 파일 관리자를 사용한다.\n GNOME  GNU에서 만든 데스크톱 환경 GPL 라이선스를 해제한 Qt 라이브러리 기반의 KDE의 대안 데스크톱 부분과 라이브러리는 LGPL 준수 응용프로그램은 GPL를 따름   초기버전에서는 nautilus라는 파일 관리자를 이용하였고, v2부터 metacity라는 윈도우 매니저를 v3부터는 Mutter를 사용하고 있다.\n 윈도우 매니저 X 윈도우 환경에서 윈도우의 배치와 표현을 담당하는 시스템 소프트웨어로 도그, 태스크 바, 프로그램 런처, 데스크톱 아이콘, 바탕화면 등을 포함한다.\n GNOME에서 사용된 nautilus, metacity나 KDE에서 사용된 KWin과 같이 X 윈도우 시스템에서 사용되는 윈도우 매니저를 X 윈도우 매니저라 한다.\n X 윈도우 활용 원격지에서 X 클라이언트 이용 X 윈도우는 서버와 클라이언트가 독립적으로 동작하는 네트워크 지향 시스템이므로 원격에서 X클라이언트를 실행할 수 있다.\nxhost X 서버에 접근 가능한 클라이언트를 지정하거나 해제한다.\nxhost [+|-] [IP or domain] display X 클라이언트가 실행될 때 표시되는 창이 설정되어 있는 환경변수로 기본값:0.0\n 첫번째 0는 시스템에서 실행중인 첫번째 X 윈도우를 뜻하고, 두번째 0은 첫번째 모니터를 의미한다.\n xauth X 윈도우 시스템은 호스트 기반의 인증뿐 아니라 사용자 기반 인증도 가능하다.\n 특정 사용자가 startx와 같은 명령으로 X윈도우를 실행하면 $HOME/.Xauthority라는 파일이 생성되고 이 파일에서 MIT-MAGIC-COOKIE-1라는 키 값을 가지고 있다. 이 키 값을 가지고 X 서버에 접속하면 해당 사용자로 인증하여 사용이 가능하다.\n ","excerpt":"개념 주로 유닉스 계열 운영체제에서 사용되는 윈도우 시스템이다.\n특징  네트워크 프로토콜에 기반한 GUI …","ref":"/til/linux/linux-master/x-window/","title":"X Window"},{"body":"네트워크 컴퓨터를 상호 연결하여 정보 교환 및 처리, 자료 및 하드웨어 공유 등을 위해 구성한 통신망이다. 규모에 따라 근거리 통신망(LAN), 도시권 통신망(MAN), 광역 통신망(WAN)으로 구분된다.\nLAN 가까운 지역을 네트워크 매체를 통해 하나로 묶는 근거리 통신망이다. LAN을 구성하는 방법에는 여러가지가 존재하는데, 요즘에는 이더넷(Ethernet)과 무선 랜(Wireless LAN)을 주로 사용한다.\n구현 방식 스타형 중앙 컴퓨터가 각 컴퓨터와 통신하는 방식\n버스형 하나의 통신회선에 여러 컴퓨터를 연결해서 전송\n링형 원형의 통신회선에 컴퓨터와 단말기를 연결\n망형 스타형과 링형의 혼합 형태\n전송 방식 이더넷 각 기기들이 48bit 길이의 고유한 MAC주소를 기반으로 상호간에 데이터를 주고받을 수 있도록 만들어졌다. 이더넷은 CSMA/CS방식을 이용하는데, 단말기가 전송로의 신호유무를 조사하고, 다른 단말기가 신호를 송출하고 있는지 확인한다.\n토큰링 IBM이 개발한 LAN기술로 IEEE 802.5로 표준화되었다. 여러 스테이션을 하나의 링으로 이어서 데이터는 한쪽 방향으로 흐르도록 한다. 네트워크 채널을 사용하려면 토큰(Token)이라는 일종의 사용권을 획득해야 한다.\nFDDI 전송 매체를 광성유 케이블을 사용해서 설계된 링 구조의 통신망으로 광대한 지역의 LAN이나 고속 백본(Backbone) LAN 구성에 주로 사용된다.\nWAN 국가, 대륙과 같은 넓은 지역을 연결하는 네트워크\n전용 회선 회선을 제공하는 통신사업자가 계약 체결한 송수신 사용자끼리만 전용 통신 선로를 연결해서 데이터 교환하는 방식\n교환 회선 공중교환전화망이나 공중교환데이터망과 같은 공중망을 이용해 전송하는 방식\n회선 교환 송신 호스트와 수신 호스트가 데이터를 전송하기 전에 연결 경로를 설정하여 물리적 전용선을 연결한다.\n패킷 교환 패킷이라 불리는 정보 블록을 이용해서 전송하는 방식으로 정보를 일정 크기로 분할하여 송수신 주소를 비롯한 정보를 추가한다. 전송 대역폭을 동적인 방식으로 공유하여 전송 선로의 이용 효율을 극대화할 수 있다.\n","excerpt":"네트워크 컴퓨터를 상호 연결하여 정보 교환 및 처리, 자료 및 하드웨어 공유 등을 위해 구성한 통신망이다. …","ref":"/til/linux/linux-master/internet/","title":"Internet"},{"body":"Delete # urls.py urlpatterns = [ path('delete/\u003cint:post_id\u003e', views.post_delete, name='post_delete'), ... ] # views.py def post_delete(request, post_id): post = get_object_or_404(Post, pk=post_id) if post.author == request.user: post.delete() return redirect('home') else: return redirect('post_detail', post_id) Update # urls.py urlpatterns = [ path('edit/\u003cint:post_id\u003e', views.post_edit, name='post_edit'), ... ] # views.py def post_edit(request, post_id): post = get_object_or_404(Post, pk=post_id) # 수정 폼 제출 if request.method == 'POST': post.content = request.POST['content'] # image 파일이 있으면 post 객체에 저장 if 'image' in request.FILES: post.image = request.FILES['image'] post.save() return redirect('/post/'+str(post.id)) else: # 수정 폼 if post.author == request.user: return render(request, 'post_edit.html', {'post': post}) else: return redirect('home') ","excerpt":"Delete # urls.py urlpatterns = [ path('delete/\u003cint:post_id\u003e', …","ref":"/til/django/study/update-and-delete-post/","title":"Update \u0026 Delete Post"},{"body":"","excerpt":"","ref":"/til/algorithm/","title":"Algorithm"},{"body":"Git은 일반적인 파일명 변경으로는 대소문자를 변경이 적용되지 않는다.\n해결 이러한 경우 대소문자 적용은 파일 이동 명령어인 mv의 --force 옵션을 사용하면 된다.\ngit mv --force pre_file new_file git commit -m \"message\" git push ","excerpt":"Git은 일반적인 파일명 변경으로는 대소문자를 변경이 적용되지 않는다. …","ref":"/til/git/troubleshooting/apply-case-change/","title":"Apply Case Change"},{"body":"우분투의 경우 apt 패키지를  http://archive.ubuntu.com/ubuntu에서 가져오도록 설정되어 있는데, 해당 주소에서 다운 속도가 느리기 때문에 한국 서버로 변경하면 편리하다.\n다음카카오에서 apt 패키지를 다운받을 수 있는 ftp서버를 제공하고 있으므로 이것을 이용하도록 하자.\n설정 $ sudo vi /etc/apt/sources.list vi 편집모드에서 :%s/archive.ubuntu.com/ftp.daumkakao.com/g를 입력하면 기존 주소들을 모두 다음카카오 서버주소로 변경시킬 수 있다.\n이후 apt 패키지를 다운받으면 정상적으로 카카오서버에서 받아오는 것을 확인할 수 있다.\n","excerpt":"우분투의 경우 apt 패키지를  http://archive.ubuntu.com/ubuntu에서 가져오도록 설정되어 있는데, 해 …","ref":"/til/linux/change-ftp-server/","title":"Change FTP Server"},{"body":"git을 통해서 윈도우와 맥이나 리눅스 개발자가 협업을 할 때 개행문자의 차이로 인해 whitespace 에러가 발생한다.\n$ git add README.md warning: LF will be replaced by CRLF in README.md. The file will have its original line endings in your working directory  운영체제에 맞춰서 개행 문자를 바꾸게 된다는 것을 매번 에러 메시지로 알려준다.\n 이러한 문제를 해결하는 가장 간단한 방법은 개행 문자를 LF로 통일하는 것이다. 이를 가능하게 해주는 기능이 git에 이미 존재하는데 그것이 바로 core.autocrlf이다.\n윈도우 사용자 git config --global core.autocrlf true 윈도우에서 사용되는 파일은 CRLF이기 때문에 커밋할 때 LF로 바꿔주고, checkout할 때는 LF를 CRLF로 바꿔주는 과정이 필요하다.\n맥이나 리눅스 git config --global core.autocrlf input 맥이나 리눅스는 개행문자가 LF이기 때문에 커밋할 때 바꾸지 않아도 되고, 가져올 때도 변경할 필요가 없다. 하지만 혹시라도 로컬에 있는 파일에 CRLF가 있다면 LF로 변경해주길 원한다면 다음과 같은 코드를 사용하자.\n메시지 삭제 오류 메시지만 지우고 알아서 작업하고 싶은 경우에는 다음 코드를 사용하면 된다.\ngit config --global core.autocrlf false ","excerpt":"git을 통해서 윈도우와 맥이나 리눅스 개발자가 협업을 할 때 개행문자의 차이로 인해 whitespace 에러가 발생한다.\n$ …","ref":"/til/git/core.autocrlf/","title":"core.autocrlf"},{"body":"","excerpt":"","ref":"/til/design-patterns/creatinal-patterns/","title":"생성 패턴"},{"body":"","excerpt":"","ref":"/til/css/","title":"CSS"},{"body":"","excerpt":"","ref":"/til/design-patterns/","title":"Design Patterns"},{"body":"","excerpt":"","ref":"/til/django/","title":"Django"},{"body":"문제 발생 깃헙 레파지토리의 변경사항을 로컬에 적용하기 위해 git pull 명령어를 사용했을 때 발생\n$ git pull fatal: the remote end hung up unexpectedly 문제 원인 git의 HTTP POST Buffer 사이즈가 작아서 오버플로우 발생\n 해당 문제는 git pull뿐 아니라 git push에서도 발생할 수 있다.\n 문제 해결 깃 설정을 통해서 버퍼 사이즈를 변경하여 해결하였다.\n$ git config --global http.postBuffer 524288000 #Set to 500MB $ git pull From https://github.com/Jeonghun-Ban/TIL + 047102b...836e520 master -\u003e origin/master (forced update) Already up to date. ","excerpt":"문제 발생 깃헙 레파지토리의 변경사항을 로컬에 적용하기 위해 git pull 명령어를 사용했을 때 발생\n$ git pull …","ref":"/til/git/troubleshooting/fatal-the-remote-end-hang-up-unexpectedly/","title":"fatal: the remote end hung up unexpectedly"},{"body":"","excerpt":"","ref":"/til/flutter/","title":"Flutter"},{"body":"","excerpt":"","ref":"/til/git/","title":"Git"},{"body":"윈도우나 맥에서는 기본적으로 깃 사용자의 아이디 및 비밀번호를 저장하여 관리한다. 반면 우분투에서 깃을 사용하면 git pull/push를 할 때마다 아이디 비밀번호를 입력해야만 한다. 이러한 번거로움을 줄이기 위해 Git Credential이라는 계정정보 저장기능을 사용한다.\n영구 저장 git config --global credential.helper store  global 속성을 제외하면 해당 디렉토리에만 적용된다.\n 캐시로 저장 git config --global credential.helper cache  cache는 기본적으로 15분 동안 인증 절차를 요구하지 않는다.\n git config credential.helper 'cache --timeout=3600' # 3600초 동안 인증 절차를 생략한다.  시간을 설정할 때는 위와 같이 timeout 속성을 이용한다. (단위는 초)\n ","excerpt":"윈도우나 맥에서는 기본적으로 깃 사용자의 아이디 및 비밀번호를 저장하여 관리한다. 반면 우분투에서 깃을 사용하면 git …","ref":"/til/git/git-credential/","title":"Git Credential"},{"body":"적용 방법  프로젝트 폴더 내에 .gitignore 파일 생성 레파지토리에 업로드하지 않을 파일이나 폴더 지정   링크에 프로그래밍 언어나 IDE를 입력하면, 불필요한 파일을 제거하기 위한 .gitignore를 빠르게 작성 가능하다.\n 제대로 적용되지 않는 문제 해결 이미 깃 저장소에 올라간 파일에 대해서 gitignore가 적용되지 않는 경우, 아래와 같은 코드로 해결 가능하다.\n$ git rm -r --cached . $ git add . $ git commit -m \"fixed untracked files\" ","excerpt":"적용 방법  프로젝트 폴더 내에 .gitignore 파일 생성 레파지토리에 업로드하지 않을 파일이나 폴더 지정   링크에 프로 …","ref":"/til/git/gitignore/","title":"gitignore"},{"body":"","excerpt":"","ref":"/til/html5/","title":"html5"},{"body":" Update Packages on your PC before install pip(recommend)  $ sudo apt update Use the following command to install pip  $ sudo apt install python3-pip Check installing pip  pip3 --version ","excerpt":" Update Packages on your PC before install pip(recommend)  $ sudo apt …","ref":"/til/python/install-pip/","title":"Install pip"},{"body":"  Launch Terminal\n  Install Nodejs using apt package manager\nsudo apt install nodejs   Verify the installation\nnodejs --version   Install npm   Install npm using apt package manager\nsudo apt install npm   Verify the installation\nnpm --version   Install yarn   Install yarn using apt package manager\nsudo npm i -g yarn   Verify the installation\nyarn --version   ","excerpt":"  Launch Terminal\n  Install Nodejs using apt package manager\nsudo apt …","ref":"/til/nodejs/installation/","title":"Installation"},{"body":"","excerpt":"","ref":"/til/javascript/","title":"JavaScript"},{"body":"","excerpt":"","ref":"/","title":"Jeonghun-Ban"},{"body":"","excerpt":"","ref":"/til/linux/","title":"Linux"},{"body":"","excerpt":"","ref":"/til/linux/linux-master/","title":"Linux Master"},{"body":"","excerpt":"","ref":"/til/network/","title":"Network"},{"body":"","excerpt":"","ref":"/til/nodejs/","title":"Nodejs"},{"body":"","excerpt":"","ref":"/til/python/","title":"Python"},{"body":"커밋 수정 가장 최근 커밋 수정 $ git commit --amend # vi 등 편집기로 수정 $ git commit --amend -m \"rewrite message\" # 옵션으로 변경도 가능 $ git commit --amend --author=\"auther_name \u003cauther_email\u003e\" git add 명령어로 변경사항을 Staging Area에 넣고, git commit --amend 명령어를 실행하면 최신 커밋에 변경사항이 반영된다.\n특정 커밋 수정 $ git rebase -i \u003ccommit hash\u003e # pick -\u003e edit $ git commit --amend $ git rebase --continue $ git push -f 여러 개의 커밋을 수정하는 것도 가능한데 git rebase -i 명령어를 실행하고 수정할 커밋을 모두 edit으로 지정해주면 된다. 이후에는 git commit --amend와 git rebase --continue 명령어를 반복해서 진행하며 메시지를 하나씩 수정해주면 된다.\n 해시는 git log 명령어로 확인 가능하다.\n 커밋 합치기 $ git rebase -i HEAD~2 # 가장 최근 커밋 두개 # 합치고 없앨 커밋 pick -\u003e f, fixup $ git commit --amend $ git push -f git을 관리하다 보면 커밋을 합쳐야 하는 경우가 있다. 예를 들면 하나의 기능 구현에 대한 커밋이 여러 개로 나누어져 있는 경우, 모두 하나로 합쳐서 올리는 것이 바람직하다. 이럴 때 위 명령어를 이용하면 손쉽게 합칠 수 있다.\n작성시간 변경 $ git rebase -i \u003ccommit hash\u003e pick -\u003e edit $ GIT_COMMITTER_DATE=\"Mon 21 Oct 00:00:00 2019 KST\" git commit --amend --no-edit --date \"Mon 21 Oct 00:00:00 2019 KST\" $ git rebase --continue $ git push -f ","excerpt":"커밋 수정 가장 최근 커밋 수정 $ git commit --amend # vi 등 편집기로 수정 $ git commit …","ref":"/til/git/rebase-command/","title":"Rebase Command"},{"body":"","excerpt":"","ref":"/til/security/","title":"Security"},{"body":" 우분투에는 기본적으로 파이썬2가 설치되어 있다. python 명령어를 사용했을 시 이것이 기본적으로 호출된다. 파이썬3를 사용하기 위해서는 python3 명령어를 사용해야 한다.  문제 원인 $ python3 --version Python 3.6.9 # 현재 설치된 파이썬 버전 $ which python /usr/bin/python # 파이썬 링크 파일 경로 $ ls -al /usr/bin/python lrwxrwxrwx 1 root root 9 Apr 16 2018 /usr/bin/python -\u003e python2.7  현재 /usr/bin/python 파일은 2.7 버전을 링크하고 있다.\n 해결 방법 Linux의 alternative를 사용하면 파이썬 버전을 쉽게 변경하는 것이 가능하고 추후 관리가 용이하다.\n$ sudo update-alternatives --config python update-alternatives: error: no alternatives for python 위와 같이 error가 발생할 수 있는데 아직 alternative를 설정하지 않았기 때문이다.\n$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1 $ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2 사용할 파이썬 버전들을 alternative에 등록하는 과정으로 컴퓨터 상에 설치된 버전에 따라 위 명령어는 상이할 수도 있다.\nsudo update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/bin/python3.6 2 auto mode 1 /usr/bin/python2.7 1 manual mode 2 /usr/bin/python3.6 2 manual mode Press \u003center\u003e to keep the current choice[*], or type selection number: 다시 sudo update-alternatives --config python를 해서 alternative 목록을 조회한 다음, 원하는 버전의 번호를 선택하여 엔터를 치면 해당 버전이 기본으로 설정된다.\n$ python --version Python 3.6.9 이제 python 명령어로 파이썬3가 호출된다.\n","excerpt":" 우분투에는 기본적으로 파이썬2가 설치되어 있다. python 명령어를 사용했을 시 이것이 기본적으로 호출된다. 파이썬3를 사 …","ref":"/til/python/set-default-python-version/","title":"Set default python version"},{"body":" Click Ctrl + , to open Settings Click tap button Open Settings(JSON) Change Value  \"terminal.integrated.shell.windows\":\"C:\\\\Windows\\\\system32\\\\wsl.exe\", store and exit restart VSCode  ","excerpt":" Click Ctrl + , to open Settings Click tap button Open Settings(JSON) …","ref":"/til/vscode/set-default-shell-to-wsl/","title":"Set Default Shell to WSL"},{"body":"프로젝트 진행 중, 프론트 단에서 시간을 불러와야 하는 상황이 발생하였다. 다만 aws ec2 서버의 기준 시간대가 UTC로 잡혀있었고 이를 한국시간대로 변경해야 했다. tzselect 명령어를 사용해봤지만 시간대 적용이 되지 않아 다음과 같은 방법으로 서버시간대를 변경할 수 있었다.\n문제해결 $ cat /etc/localtime TZif2\u0001\u0001\u0001\u0004UTCTZif2\u0001\u0001\u0001\u0001\u0004�UTC UTC0 $ sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime $ date Mon Mar 9 02:21:42 KST 2020 ","excerpt":"프로젝트 진행 중, 프론트 단에서 시간을 불러와야 하는 상황이 발생하였다. 다만 aws ec2 서버의 기준 시간대가 UTC로  …","ref":"/til/linux/set-timezone/","title":"Set Timezone"},{"body":"$ sudo passwd # root 계정 pw 설정 $ sudo passwd 'username' ","excerpt":"$ sudo passwd # root 계정 pw 설정 $ sudo passwd 'username' ","ref":"/til/linux/set-user-password/","title":"Set User Password"},{"body":"","excerpt":"","ref":"/til/django/study/","title":"Study"},{"body":"","excerpt":"","ref":"/til/python/study/","title":"Study"},{"body":"","excerpt":"","ref":"/til/","title":"Today I Learned"},{"body":"","excerpt":"","ref":"/til/git/troubleshooting/","title":"Troubleshooting"},{"body":"","excerpt":"","ref":"/til/vscode/","title":"Visual Studio Code"},{"body":"","excerpt":"","ref":"/til/wsl/","title":"Window Subsystem for Linux"},{"body":"","excerpt":"","ref":"/til/zsh/","title":"Z Shell"},{"body":"Today I Learned I have a lot of things to learn, but unfortunately I can’t learn everything at once. So I organize what today I learned in this repo.\nNotice Now this repo has been changed for migration to hugo blog. If you want to see a previous version of the documents, click here.\n","excerpt":"Today I Learned I have a lot of things to learn, but unfortunately I …","ref":"/til/readme/","title":""},{"body":"oh-my-zsh Customization 사용자 이름 표시 생략 방법은 크게 2가지 정도가 있는데, 모두 ~/.zshrc에 작성해주면 된다.\n기본 유저 변경 DEFAULT_USER=\"$(whoami)\"\r whoami는 기본 유저를 지정하지 않을 때 사용\n prompt context prompt_context(){}\r 중괄호 사이에는 유저를 프롬프트에 표기하는 형식을 지정할 수 있다. 비워두면 유저명이 생략된다.\n 멀티 라인 적용 zsh와 agnoster를 이용해서 리눅스 개발환경을 깔끔하게 할 수 있다. 만약 이때 경로가 너무 길어서 보기 불편하다거나, 경로가 표기되는 줄 이후에 명령줄이 나오면 좋겠다면 다음과 같은 방법으로 멀티 라인 적용이 가능하다.\n# 멀티라인 적용 함수\rprompt_newline() {\rif [[ -n $CURRENT_BG ]]; then\recho -n \"%{%k%F{$CURRENT_BG}%}$SEGMENT_SEPARATOR\r%(?.%F{$CURRENT_BG}.%F{red})❯%f\"\relse\recho -n \"%{%k%}\"\rfi\recho -n \"%{%f%}\"\rCURRENT_BG=''\r}\r우선 위와 같은 코드를 ~/.oh-my-zsh/themes/agnoster.zsh-theme 파일에 작성해준다.\n## Main prompt\rbuild_prompt() {\rRETVAL=$?\rprompt_status\rprompt_virtualenv\rprompt_context\rprompt_dir\rprompt_git\rprompt_hg\rprompt_newline # 멀티라인 호출\rprompt_end\r}\r~/.oh-my-zsh/themes/agnoster.zsh-theme 하단에 위치한 build_prompt()에 prompt_newline를 불러올 수 있도록 추가해준다.\n 참고자료 https://wayhome25.github.io/etc/2017/03/12/zsh-alias/\n","excerpt":"oh-my-zsh Customization 사용자 이름 표시 생략 방법은 크게 2가지 정도가 있는데, 모두 ~/.zshrc에  …","ref":"/til/zsh/oh-my-zsh-customization/","title":""},{"body":"zsh  zsh-syntax-highlighting disable zsh-syntax-highlighting underline oh-my-zsh customization Change Directory Colors  문제해결  how to fix a corrupt zsh history file Register alias on zsh  ","excerpt":"zsh  zsh-syntax-highlighting disable zsh-syntax-highlighting underline …","ref":"/til/zsh/readme/","title":""},{"body":"","excerpt":"","ref":"/categories/","title":"Categories"},{"body":"","excerpt":"","ref":"/search/","title":"Search Results"},{"body":"","excerpt":"","ref":"/tags/","title":"Tags"}]